import { Logger as Logger$1 } from 'tslog';
import { z } from 'zod';
export { z } from 'zod';
import { ModelMessage, SystemModelMessage, UserModelMessage, AssistantModelMessage, ToolModelMessage, LanguageModel } from 'ai';
import { OpenAIProviderSettings } from '@ai-sdk/openai';
import { OpenAIChatModelId } from '@ai-sdk/openai/internal';
import { AnthropicProviderSettings } from '@ai-sdk/anthropic';
import { AnthropicMessagesModelId } from '@ai-sdk/anthropic/internal';
import { GoogleGenerativeAIProviderSettings } from '@ai-sdk/google';
import { GoogleGenerativeAIModelId } from '@ai-sdk/google/internal';

/**
 * The raw response from the fetch call excluding the body.
 */
type RawResponse = Omit<{
    [K in keyof Response as Response[K] extends Function ? never : K]: Response[K];
}, "ok" | "body" | "bodyUsed">;
/**
 * Creates a `RawResponse` from a standard `Response` object.
 */
interface WithRawResponse<T> {
    readonly data: T;
    readonly rawResponse: RawResponse;
}

type Supplier<T> = T | Promise<T> | (() => T | Promise<T>);
declare const Supplier: {
    get: <T>(supplier: Supplier<T>) => Promise<T>;
};

declare const LogLevel: {
    readonly Debug: "debug";
    readonly Info: "info";
    readonly Warn: "warn";
    readonly Error: "error";
};
type LogLevel = (typeof LogLevel)[keyof typeof LogLevel];
interface ILogger {
    /**
     * Logs a debug message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    debug(message: string, ...args: unknown[]): void;
    /**
     * Logs an info message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    info(message: string, ...args: unknown[]): void;
    /**
     * Logs a warning message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    warn(message: string, ...args: unknown[]): void;
    /**
     * Logs an error message.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    error(message: string, ...args: unknown[]): void;
}
/**
 * Configuration for logger initialization.
 */
interface LogConfig {
    /**
     * Minimum log level to output.
     * @default LogLevel.Info
     */
    level?: LogLevel;
    /**
     * Logger implementation to use.
     * @default new ConsoleLogger()
     */
    logger?: ILogger;
    /**
     * Whether logging should be silenced.
     * @default true
     */
    silent?: boolean;
}
/**
 * Logger class that provides level-based logging functionality.
 */
declare class Logger {
    private readonly level;
    private readonly logger;
    private readonly silent;
    /**
     * Creates a new logger instance.
     * @param config - Logger configuration
     */
    constructor(config: Required<LogConfig>);
    /**
     * Checks if a log level should be output based on configuration.
     * @param level - The log level to check
     * @returns True if the level should be logged
     */
    shouldLog(level: LogLevel): boolean;
    /**
     * Checks if debug logging is enabled.
     * @returns True if debug logs should be output
     */
    isDebug(): boolean;
    /**
     * Logs a debug message if debug logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    debug(message: string, ...args: unknown[]): void;
    /**
     * Checks if info logging is enabled.
     * @returns True if info logs should be output
     */
    isInfo(): boolean;
    /**
     * Logs an info message if info logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    info(message: string, ...args: unknown[]): void;
    /**
     * Checks if warning logging is enabled.
     * @returns True if warning logs should be output
     */
    isWarn(): boolean;
    /**
     * Logs a warning message if warning logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    warn(message: string, ...args: unknown[]): void;
    /**
     * Checks if error logging is enabled.
     * @returns True if error logs should be output
     */
    isError(): boolean;
    /**
     * Logs an error message if error logging is enabled.
     * @param message - The message to log
     * @param args - Additional arguments to log
     */
    error(message: string, ...args: unknown[]): void;
}

/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */
declare class HttpResponsePromise<T> extends Promise<T> {
    private innerPromise;
    private unwrappedPromise;
    private constructor();
    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromFunction<F extends (...args: never[]) => Promise<WithRawResponse<T>>, T>(fn: F, ...args: Parameters<F>): HttpResponsePromise<T>;
    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */
    static interceptFunction<F extends (...args: never[]) => Promise<WithRawResponse<T>>, T = Awaited<ReturnType<F>>["data"]>(fn: F): (...args: Parameters<F>) => HttpResponsePromise<T>;
    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromPromise<T>(promise: Promise<WithRawResponse<T>>): HttpResponsePromise<T>;
    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromExecutor<T>(executor: (resolve: (value: WithRawResponse<T>) => void, reject: (reason?: unknown) => void) => void): HttpResponsePromise<T>;
    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromResult<T>(result: WithRawResponse<T>): HttpResponsePromise<T>;
    private unwrap;
    /** @inheritdoc */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null, onrejected?: ((reason: unknown) => TResult2 | PromiseLike<TResult2>) | null): Promise<TResult1 | TResult2>;
    /** @inheritdoc */
    catch<TResult = never>(onrejected?: ((reason: unknown) => TResult | PromiseLike<TResult>) | null): Promise<T | TResult>;
    /** @inheritdoc */
    finally(onfinally?: (() => void) | null): Promise<T>;
    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */
    withRawResponse(): Promise<WithRawResponse<T>>;
}

/**
 * @example
 *     {}
 */
interface FindAlertsRequest {
    page?: number;
    size?: number;
    sorting?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
type GetAlertByIdRequest = {};

/**
 * @example
 *     {}
 */
interface GetWebhookExamplesRequest {
    alertType?: GetWebhookExamplesRequestAlertType;
}

/**
 * @example
 *     {
 *         body: {
 *             webhook: {
 *                 url: "url"
 *             }
 *         }
 *     }
 */
interface UpdateAlertRequest {
    body: AlertWrite;
}

declare const GetWebhookExamplesRequestAlertType: {
    readonly General: "general";
    readonly Slack: "slack";
    readonly Pagerduty: "pagerduty";
};
type GetWebhookExamplesRequestAlertType = (typeof GetWebhookExamplesRequestAlertType)[keyof typeof GetWebhookExamplesRequestAlertType];

/**
 * @example
 *     {
 *         body: {
 *             ids: ["ids"]
 *         }
 *     }
 */
interface AddItemsToAnnotationQueueRequest {
    body: AnnotationQueueItemIds;
}

/**
 * @example
 *     {
 *         annotationQueues: [{
 *                 projectId: "project_id",
 *                 name: "name",
 *                 scope: "trace"
 *             }]
 *     }
 */
interface AnnotationQueueBatchWrite {
    /** List of annotation queues to create */
    annotationQueues: AnnotationQueueWrite[];
}

/**
 * @example
 *     {}
 */
interface AnnotationQueueUpdate {
    name?: string;
    description?: string;
    instructions?: string;
    commentsEnabled?: boolean;
    feedbackDefinitionNames?: string[];
}

/**
 * @example
 *     {}
 */
interface FindAnnotationQueuesRequest {
    page?: number;
    size?: number;
    name?: string;
    filters?: string;
    sorting?: string;
}

/**
 * @example
 *     {}
 */
type GetAnnotationQueueByIdRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             ids: ["ids"]
 *         }
 *     }
 */
interface RemoveItemsFromAnnotationQueueRequest {
    body: AnnotationQueueItemIds;
}

/**
 * @example
 *     {
 *         projectId: "project_id",
 *         entityType: "trace",
 *         entityId: "entity_id",
 *         path: "path"
 *     }
 */
interface AttachmentListRequest {
    page?: number;
    size?: number;
    projectId: string;
    entityType: AttachmentListRequestEntityType;
    entityId: string;
    path: string;
}

/**
 * @example
 *     {
 *         containerId: "container_id",
 *         entityType: "trace",
 *         entityId: "entity_id",
 *         fileName: "x",
 *         mimeType: "x"
 *     }
 */
interface DownloadAttachmentRequest {
    workspaceName?: string;
    containerId: string;
    entityType: DownloadAttachmentRequestEntityType;
    entityId: string;
    fileName: string;
    mimeType: string;
}

/**
 * @example
 *     {
 *         fileName: "file_name",
 *         numOfFileParts: 1,
 *         entityType: "trace",
 *         entityId: "entity_id",
 *         path: "path"
 *     }
 */
interface StartMultipartUploadRequest {
    fileName: string;
    numOfFileParts: number;
    mimeType?: string;
    /** If null, the default project is used */
    projectName?: string;
    entityType: StartMultipartUploadRequestEntityType;
    entityId: string;
    path: string;
}

/**
 * @example
 *     {
 *         fileName: "file_name",
 *         entityType: "trace",
 *         entityId: "entity_id",
 *         body: {
 *             "key": "value"
 *         }
 *     }
 */
interface UploadAttachmentRequest {
    fileName: string;
    projectName?: string;
    mimeType?: string;
    entityType: UploadAttachmentRequestEntityType;
    entityId: string;
    body: Record<string, unknown>;
}

declare const AttachmentListRequestEntityType: {
    readonly Trace: "trace";
    readonly Span: "span";
};
type AttachmentListRequestEntityType = (typeof AttachmentListRequestEntityType)[keyof typeof AttachmentListRequestEntityType];

declare const DownloadAttachmentRequestEntityType: {
    readonly Trace: "trace";
    readonly Span: "span";
};
type DownloadAttachmentRequestEntityType = (typeof DownloadAttachmentRequestEntityType)[keyof typeof DownloadAttachmentRequestEntityType];

declare const StartMultipartUploadRequestEntityType: {
    readonly Trace: "trace";
    readonly Span: "span";
};
type StartMultipartUploadRequestEntityType = (typeof StartMultipartUploadRequestEntityType)[keyof typeof StartMultipartUploadRequestEntityType];

declare const UploadAttachmentRequestEntityType: {
    readonly Trace: "trace";
    readonly Span: "span";
};
type UploadAttachmentRequestEntityType = (typeof UploadAttachmentRequestEntityType)[keyof typeof UploadAttachmentRequestEntityType];

/**
 * @example
 *     {
 *         body: {
 *             ids: ["ids"]
 *         }
 *     }
 */
interface DeleteAutomationRuleEvaluatorBatchRequest {
    projectId?: string;
    body: BatchDelete;
}

/**
 * @example
 *     {}
 */
interface FindEvaluatorsRequest {
    projectId?: string;
    id?: string;
    name?: string;
    filters?: string;
    sorting?: string;
    page?: number;
    size?: number;
}

/**
 * @example
 *     {}
 */
interface GetEvaluatorByIdRequest {
    projectId?: string;
}

/**
 * @example
 *     {}
 */
interface GetEvaluatorLogsByIdRequest {
    size?: number;
}

/**
 * @example
 *     {
 *         body: {
 *             type: "llm_as_judge",
 *             name: "string",
 *             action: "evaluator"
 *         }
 *     }
 */
interface UpdateAutomationRuleEvaluatorRequest {
    body: AutomationRuleEvaluatorUpdate;
}

/**
 * @example
 *     {}
 */
interface ChatCompletionRequest {
    model?: string;
    messages?: Message[];
    temperature?: number;
    topP?: number;
    n?: number;
    stream?: boolean;
    streamOptions?: StreamOptions;
    stop?: string[];
    maxTokens?: number;
    maxCompletionTokens?: number;
    presencePenalty?: number;
    frequencyPenalty?: number;
    logitBias?: Record<string, number>;
    user?: string;
    responseFormat?: ResponseFormat;
    seed?: number;
    tools?: Tool[];
    toolChoice?: Record<string, unknown>;
    parallelToolCalls?: boolean;
    store?: boolean;
    metadata?: Record<string, string>;
    reasoningEffort?: string;
    serviceTier?: string;
    functions?: Function$1[];
    functionCall?: FunctionCall;
}

/**
 * @example
 *     {}
 */
interface DashboardUpdatePublic {
    name?: string;
    description?: string;
    config?: JsonNodePublic;
}

/**
 * @example
 *     {
 *         name: "name",
 *         config: {
 *             "key": "value"
 *         }
 *     }
 */
interface DashboardWrite {
    name: string;
    description?: string;
    config: JsonNodeWrite;
}

/**
 * @example
 *     {}
 */
type DeleteDashboardRequest = {};

/**
 * @example
 *     {}
 */
interface FindDashboardsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
}

/**
 * @example
 *     {}
 */
type GetDashboardByIdRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             "key": "value"
 *         }
 *     }
 */
interface ApplyDatasetItemChangesRequest {
    override?: boolean;
    body: DatasetItemChangesPublic;
}

/**
 * @example
 *     {}
 */
type CompareDatasetVersionsRequest = {};

/**
 * @example
 *     {
 *         file: {
 *             "key": "value"
 *         },
 *         datasetId: "dataset_id"
 *     }
 */
interface CreateDatasetItemsFromCsvRequest {
    file: Record<string, unknown>;
    datasetId: string;
}

/**
 * @example
 *     {
 *         spanIds: ["span_ids"],
 *         enrichmentOptions: {}
 *     }
 */
interface CreateDatasetItemsFromSpansRequest {
    /** Set of span IDs to add to the dataset */
    spanIds: string[];
    enrichmentOptions: SpanEnrichmentOptions;
}

/**
 * @example
 *     {
 *         traceIds: ["trace_ids"],
 *         enrichmentOptions: {}
 *     }
 */
interface CreateDatasetItemsFromTracesRequest {
    /** Set of trace IDs to add to the dataset */
    traceIds: string[];
    enrichmentOptions: TraceEnrichmentOptions;
}

/**
 * @example
 *     {
 *         model: "gpt-4"
 *     }
 */
interface DatasetExpansionWrite {
    /** The model to use for synthetic data generation */
    model: string;
    /** Number of synthetic samples to generate */
    sampleCount?: number;
    /** Fields to preserve patterns from original data */
    preserveFields?: string[];
    /** Additional instructions for data variation */
    variationInstructions?: string;
    /** Custom prompt to use for generation instead of auto-generated one */
    customPrompt?: string;
}

/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface DatasetIdentifier {
    datasetName: string;
}

/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface DatasetIdentifierPublic {
    datasetName: string;
}

/**
 * @example
 *     {
 *         update: {}
 *     }
 */
interface DatasetItemBatchUpdate {
    /** List of dataset item IDs to update (max 1000). Mutually exclusive with 'filters'. */
    ids?: string[];
    filters?: DatasetItemFilter[];
    /** Dataset ID. Required when using 'filters', optional when using 'ids'. */
    datasetId?: string;
    update: DatasetItemUpdate;
    /** If true, merge tags with existing tags instead of replacing them. Default: false. When using 'filters', this is automatically set to true. */
    mergeTags?: boolean;
}

/**
 * @example
 *     {
 *         items: [{
 *                 source: "manual",
 *                 data: {
 *                     "key": "value"
 *                 }
 *             }]
 *     }
 */
interface DatasetItemBatchWrite {
    /** If null, dataset_id must be provided */
    datasetName?: string;
    /** If null, dataset_name must be provided */
    datasetId?: string;
    items: DatasetItemWrite[];
    /** Optional batch group ID to group multiple batches into a single dataset version. If null, mutates the latest version instead of creating a new one. */
    batchGroupId?: string;
}

interface DatasetItemStreamRequest {
    datasetName: string;
    lastRetrievedId?: string;
    steamLimit?: number;
    datasetVersion?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
interface DatasetItemsDelete {
    /** List of dataset item IDs to delete (max 1000). Use this to delete specific items by their IDs. Mutually exclusive with 'dataset_id' and 'filters'. */
    itemIds?: string[];
    /** Dataset ID to scope the deletion. Required when using 'filters'. Mutually exclusive with 'item_ids'. */
    datasetId?: string;
    /** Filters to select dataset items to delete within the specified dataset. Must be used with 'dataset_id'. Mutually exclusive with 'item_ids'. Empty array means 'delete all items in the dataset'. */
    filters?: DatasetItemFilter[];
    /** Optional batch group ID to group multiple delete operations into a single dataset version. If null, mutates the latest version instead of creating a new one. */
    batchGroupId?: string;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface DatasetUpdate {
    name: string;
    description?: string;
    visibility?: DatasetUpdateVisibility;
    tags?: string[];
}

/**
 * @example
 *     {
 *         versionRef: "version_ref"
 *     }
 */
interface DatasetVersionRestorePublic {
    /** Version hash or tag to restore from */
    versionRef: string;
}

/**
 * @example
 *     {
 *         versionName: "v1"
 *     }
 */
interface DatasetVersionRetrieveRequestPublic {
    /** Version name in format 'vN' (e.g., 'v1', 'v373') */
    versionName: string;
}

/**
 * @example
 *     {
 *         tag: "tag"
 *     }
 */
interface DatasetVersionTag {
    tag: string;
}

/**
 * @example
 *     {}
 */
interface DatasetVersionUpdatePublic {
    /** Optional description of changes in this version */
    changeDescription?: string;
    /** Optional list of tags to add to this version */
    tagsToAdd?: string[];
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface DatasetWrite {
    id?: string;
    name: string;
    visibility?: DatasetWriteVisibility;
    tags?: string[];
    description?: string;
}

/**
 * @example
 *     {}
 */
type DeleteDatasetRequest = {};

/**
 * @example
 *     {}
 */
type DeleteVersionTagRequest = {};

/**
 * @example
 *     {}
 */
type DownloadDatasetExportRequest = {};

/**
 * @example
 *     {
 *         experimentIds: "experiment_ids"
 *     }
 */
interface FindDatasetItemsWithExperimentItemsRequest {
    page?: number;
    size?: number;
    experimentIds: string;
    filters?: string;
    sorting?: string;
    search?: string;
    truncate?: boolean;
}

/**
 * @example
 *     {}
 */
interface FindDatasetsRequest {
    page?: number;
    size?: number;
    withExperimentsOnly?: boolean;
    withOptimizationsOnly?: boolean;
    promptId?: string;
    name?: string;
    sorting?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
type GetDatasetByIdRequest = {};

/**
 * @example
 *     {
 *         experimentIds: "experiment_ids"
 *     }
 */
interface GetDatasetExperimentItemsStatsRequest {
    experimentIds: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
type GetDatasetExportJobRequest = {};

/**
 * @example
 *     {}
 */
type GetDatasetItemByIdRequest = {};

/**
 * @example
 *     {}
 */
interface GetDatasetItemsOutputColumnsRequest {
    experimentIds?: string;
}

/**
 * @example
 *     {}
 */
interface GetDatasetItemsRequest {
    page?: number;
    size?: number;
    version?: string;
    filters?: string;
    truncate?: boolean;
}

/**
 * @example
 *     {}
 */
interface ListDatasetVersionsRequest {
    page?: number;
    size?: number;
}

/**
 * @example
 *     {}
 */
type MarkDatasetExportJobViewedRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             source: "manual",
 *             data: {
 *                 "key": "value"
 *             }
 *         }
 *     }
 */
interface PatchDatasetItemRequest {
    body: DatasetItemWrite;
}

/**
 * @example
 *     {}
 */
type StartDatasetExportRequest = {};

declare const DatasetUpdateVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type DatasetUpdateVisibility = (typeof DatasetUpdateVisibility)[keyof typeof DatasetUpdateVisibility];

declare const DatasetWriteVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type DatasetWriteVisibility = (typeof DatasetWriteVisibility)[keyof typeof DatasetWriteVisibility];

/**
 * @example
 *     {
 *         ids: ["ids"],
 *         update: {}
 *     }
 */
interface ExperimentBatchUpdate {
    /** List of experiment IDs to update (max 1000) */
    ids: string[];
    update: ExperimentUpdate;
    /** If true, merge tags with existing tags instead of replacing them. Default: false */
    mergeTags?: boolean;
}

/**
 * @example
 *     {
 *         experimentName: "experiment_name",
 *         datasetName: "dataset_name",
 *         items: [{
 *                 datasetItemId: "dataset_item_id"
 *             }]
 *     }
 */
interface ExperimentItemBulkUploadExperimentItemBulkWriteView {
    experimentName: string;
    datasetName: string;
    /** Optional experiment ID. If provided, items will be added to the existing experiment and experimentName will be ignored. If not provided or experiment with that ID doesn't exist, a new experiment will be created with the given experimentName */
    experimentId?: string;
    items: ExperimentItemBulkRecordExperimentItemBulkWriteView[];
}

interface ExperimentItemStreamRequest {
    experimentName: string;
    limit?: number;
    lastRetrievedId?: string;
    /** Truncate image included in either input, output or metadata */
    truncate?: boolean;
}

/**
 * @example
 *     {
 *         experimentItems: [{
 *                 experimentId: "experiment_id",
 *                 datasetItemId: "dataset_item_id",
 *                 traceId: "trace_id"
 *             }]
 *     }
 */
interface ExperimentItemsBatch {
    experimentItems: ExperimentItem[];
}

/**
 * @example
 *     {
 *         ids: ["ids"]
 *     }
 */
interface ExperimentItemsDelete {
    ids: string[];
}

interface ExperimentStreamRequestPublic {
    name: string;
    limit?: number;
    lastRetrievedId?: string;
}

/**
 * @example
 *     {
 *         datasetName: "dataset_name"
 *     }
 */
interface ExperimentWrite {
    id?: string;
    datasetName: string;
    name?: string;
    metadata?: JsonListStringWrite;
    tags?: string[];
    type?: ExperimentWriteType;
    optimizationId?: string;
    status?: ExperimentWriteStatus;
    experimentScores?: ExperimentScoreWrite[];
    promptVersion?: PromptVersionLinkWrite;
    promptVersions?: PromptVersionLinkWrite[];
    /** ID of the dataset version this experiment is linked to. If not provided at creation, experiment will be automatically linked to the latest version. */
    datasetVersionId?: string;
}

/**
 * @example
 *     {}
 */
interface FindExperimentGroupsAggregationsRequest {
    groups?: string;
    types?: string;
    name?: string;
    projectId?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
interface FindExperimentGroupsRequest {
    groups?: string;
    types?: string;
    name?: string;
    projectId?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
interface FindExperimentsRequest {
    page?: number;
    size?: number;
    datasetId?: string;
    optimizationId?: string;
    types?: string;
    name?: string;
    datasetDeleted?: boolean;
    promptId?: string;
    projectId?: string;
    projectDeleted?: boolean;
    sorting?: string;
    filters?: string;
    experimentIds?: string;
    forceSorting?: boolean;
}

/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNamesRequest {
    experimentIds?: string;
}

/**
 * @example
 *     {}
 */
type GetExperimentByIdRequest = {};

/**
 * @example
 *     {}
 */
type GetExperimentItemByIdRequest = {};

/**
 * @example
 *     {
 *         body: {}
 *     }
 */
interface UpdateExperimentRequest {
    body: ExperimentUpdate;
}

declare const ExperimentWriteStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
};
type ExperimentWriteStatus = (typeof ExperimentWriteStatus)[keyof typeof ExperimentWriteStatus];

declare const ExperimentWriteType: {
    readonly Regular: "regular";
    readonly Trial: "trial";
    readonly MiniBatch: "mini-batch";
};
type ExperimentWriteType = (typeof ExperimentWriteType)[keyof typeof ExperimentWriteType];

/**
 * @example
 *     {}
 */
type DeleteFeedbackDefinitionByIdRequest = {};

/**
 * @example
 *     {}
 */
interface FindFeedbackDefinitionsRequest {
    page?: number;
    size?: number;
    name?: string;
    type?: FindFeedbackDefinitionsRequestType;
}

/**
 * @example
 *     {}
 */
type GetFeedbackDefinitionByIdRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             type: "numerical",
 *             name: "string",
 *             description: "This feedback definition is used to rate response quality"
 *         }
 *     }
 */
interface UpdateFeedbackDefinitionRequest {
    body: FeedbackUpdate;
}

declare const FindFeedbackDefinitionsRequestType: {
    readonly Numerical: "numerical";
    readonly Categorical: "categorical";
    readonly Boolean: "boolean";
};
type FindFeedbackDefinitionsRequestType = (typeof FindFeedbackDefinitionsRequestType)[keyof typeof FindFeedbackDefinitionsRequestType];

/**
 * @example
 *     {
 *         guardrails: [{
 *                 entityId: "entity_id",
 *                 secondaryId: "secondary_id",
 *                 name: "TOPIC",
 *                 result: "passed",
 *                 config: {
 *                     "key": "value"
 *                 },
 *                 details: {
 *                     "key": "value"
 *                 }
 *             }]
 *     }
 */
interface GuardrailBatchWrite {
    guardrails: GuardrailWrite[];
}

/**
 * @example
 *     {}
 */
type GetLlmProviderApiKeyByIdRequest = {};

/**
 * @example
 *     {}
 */
interface ProviderApiKeyUpdate {
    apiKey?: string;
    name?: string;
    /** Provider name - can be set to migrate legacy custom LLM or Bedrock providers to the new multi-provider format. Once set, it cannot be changed. Should only be set for custom LLM and Bedrock providers. */
    providerName?: string;
    headers?: Record<string, string>;
    configuration?: Record<string, string>;
    baseUrl?: string;
}

/**
 * @example
 *     {
 *         provider: "openai"
 *     }
 */
interface ProviderApiKeyWrite {
    provider: ProviderApiKeyWriteProvider;
    apiKey?: string;
    name?: string;
    /** Provider name - required for custom LLM and Bedrock providers to uniquely identify them (e.g., 'ollama', 'vllm', 'Bedrock us-east-1'). Must not be blank for custom and Bedrock providers. Should not be set for standard providers (OpenAI, Anthropic, etc.). This requirement is conditional and validation is enforced programmatically. */
    providerName?: string;
    headers?: Record<string, string>;
    configuration?: Record<string, string>;
    baseUrl?: string;
}

declare const ProviderApiKeyWriteProvider: {
    readonly Openai: "openai";
    readonly Anthropic: "anthropic";
    readonly Gemini: "gemini";
    readonly Openrouter: "openrouter";
    readonly VertexAi: "vertex-ai";
    readonly Bedrock: "bedrock";
    readonly Ollama: "ollama";
    readonly CustomLlm: "custom-llm";
    readonly OpikFree: "opik-free";
};
type ProviderApiKeyWriteProvider = (typeof ProviderApiKeyWriteProvider)[keyof typeof ProviderApiKeyWriteProvider];

/**
 * @example
 *     {}
 */
type CancelStudioOptimizationsRequest = {};

/**
 * @example
 *     {}
 */
interface FindOptimizationsRequest {
    page?: number;
    size?: number;
    datasetId?: string;
    name?: string;
    datasetDeleted?: boolean;
    filters?: string;
}

/**
 * @example
 *     {}
 */
type GetOptimizationByIdRequest = {};

/**
 * @example
 *     {}
 */
type GetStudioOptimizationLogsRequest = {};

/**
 * @example
 *     {}
 */
interface OptimizationUpdate {
    name?: string;
    status?: OptimizationUpdateStatus;
}

declare const OptimizationUpdateStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
    readonly Initialized: "initialized";
    readonly Error: "error";
};
type OptimizationUpdateStatus = (typeof OptimizationUpdateStatus)[keyof typeof OptimizationUpdateStatus];

/**
 * @example
 *     {}
 */
type DeleteProjectByIdRequest = {};

/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNamesByProjectIdsRequest {
    projectIds?: string;
}

/**
 * @example
 *     {}
 */
interface FindProjectsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
}

/**
 * @example
 *     {}
 */
type FindTokenUsageNamesRequest = {};

/**
 * @example
 *     {}
 */
type GetProjectByIdRequest = {};

/**
 * @example
 *     {}
 */
interface GetProjectStatsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
}

/**
 * @example
 *     {}
 */
interface ProjectMetricRequestPublic {
    metricType?: ProjectMetricRequestPublicMetricType;
    interval?: ProjectMetricRequestPublicInterval;
    intervalStart?: Date;
    intervalEnd?: Date;
    spanFilters?: SpanFilterPublic[];
    traceFilters?: TraceFilterPublic[];
    threadFilters?: TraceThreadFilterPublic[];
    breakdown?: BreakdownConfigPublic;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface ProjectRetrieveDetailed {
    name: string;
}

/**
 * @example
 *     {}
 */
interface ProjectUpdate {
    name?: string;
    description?: string;
    visibility?: ProjectUpdateVisibility;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface ProjectWrite {
    name: string;
    visibility?: ProjectWriteVisibility;
    description?: string;
}

declare const ProjectMetricRequestPublicInterval: {
    readonly Hourly: "HOURLY";
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
};
type ProjectMetricRequestPublicInterval = (typeof ProjectMetricRequestPublicInterval)[keyof typeof ProjectMetricRequestPublicInterval];

declare const ProjectMetricRequestPublicMetricType: {
    readonly FeedbackScores: "FEEDBACK_SCORES";
    readonly TraceCount: "TRACE_COUNT";
    readonly TokenUsage: "TOKEN_USAGE";
    readonly Duration: "DURATION";
    readonly Cost: "COST";
    readonly GuardrailsFailedCount: "GUARDRAILS_FAILED_COUNT";
    readonly ThreadCount: "THREAD_COUNT";
    readonly ThreadDuration: "THREAD_DURATION";
    readonly ThreadFeedbackScores: "THREAD_FEEDBACK_SCORES";
    readonly SpanFeedbackScores: "SPAN_FEEDBACK_SCORES";
    readonly SpanCount: "SPAN_COUNT";
    readonly SpanDuration: "SPAN_DURATION";
    readonly SpanTokenUsage: "SPAN_TOKEN_USAGE";
};
type ProjectMetricRequestPublicMetricType = (typeof ProjectMetricRequestPublicMetricType)[keyof typeof ProjectMetricRequestPublicMetricType];

declare const ProjectUpdateVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type ProjectUpdateVisibility = (typeof ProjectUpdateVisibility)[keyof typeof ProjectUpdateVisibility];

declare const ProjectWriteVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type ProjectWriteVisibility = (typeof ProjectWriteVisibility)[keyof typeof ProjectWriteVisibility];

/**
 * @example
 *     {
 *         name: "name",
 *         version: {
 *             template: "template"
 *         }
 *     }
 */
interface CreatePromptVersionDetail {
    name: string;
    version: PromptVersionDetail;
    /** Template structure for the prompt: 'text' or 'chat'. Note: This field is only used when creating a new prompt. If a prompt with the given name already exists, this field is ignored and the existing prompt's template structure is used. Template structure is immutable after prompt creation. */
    templateStructure?: CreatePromptVersionDetailTemplateStructure;
}

/**
 * @example
 *     {}
 */
type DeletePromptRequest = {};

/**
 * @example
 *     {}
 */
type GetPromptByIdRequest = {};

/**
 * @example
 *     {}
 */
interface GetPromptsRequest {
    page?: number;
    size?: number;
    name?: string;
    sorting?: string;
    filters?: string;
}

/**
 * @example
 *     {}
 */
type GetPromptVersionByIdRequest = {};

/**
 * @example
 *     {}
 */
interface GetPromptVersionsRequest {
    page?: number;
    size?: number;
    /** Search text to find in template or change description fields */
    search?: string;
    sorting?: string;
    filters?: string;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptUpdatable {
    name: string;
    description?: string;
    tags?: string[];
}

/**
 * @example
 *     {
 *         ids: ["ids"],
 *         update: {}
 *     }
 */
interface PromptVersionBatchUpdate {
    /** IDs of prompt versions to update */
    ids: string[];
    update: PromptVersionUpdate;
    /**
     * Tag merge behavior:
     * - true: Add new tags to existing tags (union)
     * - false: Replace all existing tags with new tags (default behaviour if not provided)
     */
    mergeTags?: boolean;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptVersionRetrieveDetail {
    name: string;
    commit?: string;
}

/**
 * @example
 *     {
 *         name: "name"
 *     }
 */
interface PromptWrite {
    id?: string;
    name: string;
    description?: string;
    template?: string;
    metadata?: JsonNodeWrite;
    changeDescription?: string;
    type?: PromptWriteType;
    /** Template structure type: 'text' or 'chat'. Immutable after creation. */
    templateStructure?: PromptWriteTemplateStructure;
    tags?: string[];
}

/**
 * @example
 *     {}
 */
type RestorePromptVersionRequest = {};

/** Template structure for the prompt: 'text' or 'chat'. Note: This field is only used when creating a new prompt. If a prompt with the given name already exists, this field is ignored and the existing prompt's template structure is used. Template structure is immutable after prompt creation. */
declare const CreatePromptVersionDetailTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type CreatePromptVersionDetailTemplateStructure = (typeof CreatePromptVersionDetailTemplateStructure)[keyof typeof CreatePromptVersionDetailTemplateStructure];

/** Template structure type: 'text' or 'chat'. Immutable after creation. */
declare const PromptWriteTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type PromptWriteTemplateStructure = (typeof PromptWriteTemplateStructure)[keyof typeof PromptWriteTemplateStructure];

declare const PromptWriteType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};
type PromptWriteType = (typeof PromptWriteType)[keyof typeof PromptWriteType];

/**
 * @example
 *     {
 *         datasetId: "dataset_id",
 *         path: "path"
 *     }
 */
interface DatasetsRedirectRequest {
    datasetId: string;
    workspaceName?: string;
    path: string;
}

/**
 * @example
 *     {
 *         datasetId: "dataset_id",
 *         experimentId: "experiment_id",
 *         path: "path"
 *     }
 */
interface ExperimentsRedirectRequest {
    datasetId: string;
    experimentId: string;
    workspaceName?: string;
    path: string;
}

/**
 * @example
 *     {
 *         datasetId: "dataset_id",
 *         optimizationId: "optimization_id",
 *         path: "path"
 *     }
 */
interface OptimizationsRedirectRequest {
    datasetId: string;
    optimizationId: string;
    workspaceName?: string;
    path: string;
}

/**
 * @example
 *     {
 *         traceId: "trace_id",
 *         path: "path"
 *     }
 */
interface ProjectsRedirectRequest {
    traceId: string;
    workspaceName?: string;
    path: string;
}

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface AddSpanCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {
 *             name: "name",
 *             value: 1.1,
 *             source: "ui"
 *         }
 *     }
 */
interface AddSpanFeedbackScoreRequest {
    body: FeedbackScore;
}

/**
 * @example
 *     {}
 */
type DeleteSpanByIdRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             name: "name"
 *         }
 *     }
 */
interface DeleteSpanFeedbackScoreRequest {
    body: DeleteFeedbackScore;
}

/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNames1Request {
    projectId?: string;
    type?: FindFeedbackScoreNames1RequestType;
}

/**
 * @example
 *     {}
 */
interface GetSpanByIdRequest {
    stripAttachments?: boolean;
}

/**
 * @example
 *     {}
 */
type GetSpanCommentRequest = {};

/**
 * @example
 *     {}
 */
interface GetSpanStatsRequest {
    projectId?: string;
    projectName?: string;
    traceId?: string;
    type?: GetSpanStatsRequestType;
    filters?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {}
 */
interface GetSpansByProjectRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    traceId?: string;
    type?: GetSpansByProjectRequestType;
    filters?: string;
    truncate?: boolean;
    stripAttachments?: boolean;
    sorting?: string;
    exclude?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {
 *         ids: ["ids"],
 *         update: {
 *             traceId: "trace_id"
 *         }
 *     }
 */
interface SpanBatchUpdate {
    /** List of span IDs to update (max 1000) */
    ids: string[];
    update: SpanUpdate$1;
    /** If true, merge tags with existing tags instead of replacing them. Default: false */
    mergeTags?: boolean;
}

/**
 * @example
 *     {
 *         spans: [{
 *                 startTime: new Date("2024-01-15T09:30:00.000Z")
 *             }]
 *     }
 */
interface SpanBatchWrite {
    spans: SpanWrite[];
}

/**
 * @example
 *     {}
 */
interface SpanSearchStreamRequestPublic {
    traceId?: string;
    projectName?: string;
    projectId?: string;
    type?: SpanSearchStreamRequestPublicType;
    filters?: SpanFilterPublic[];
    /** Max number of spans to be streamed */
    limit?: number;
    lastRetrievedId?: string;
    /** Truncate image included in either input, output or metadata */
    truncate?: boolean;
    /** Filter spans created from this time (ISO-8601 format). */
    fromTime?: Date;
    /** Filter spans created up to this time (ISO-8601 format). If not provided, defaults to current time. Must be after 'from_time'. */
    toTime?: Date;
}

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface UpdateSpanCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {
 *             traceId: "trace_id"
 *         }
 *     }
 */
interface UpdateSpanRequest {
    body: SpanUpdate$1;
}

declare const FindFeedbackScoreNames1RequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type FindFeedbackScoreNames1RequestType = (typeof FindFeedbackScoreNames1RequestType)[keyof typeof FindFeedbackScoreNames1RequestType];

declare const GetSpanStatsRequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type GetSpanStatsRequestType = (typeof GetSpanStatsRequestType)[keyof typeof GetSpanStatsRequestType];

declare const GetSpansByProjectRequestType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type GetSpansByProjectRequestType = (typeof GetSpansByProjectRequestType)[keyof typeof GetSpansByProjectRequestType];

declare const SpanSearchStreamRequestPublicType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanSearchStreamRequestPublicType = (typeof SpanSearchStreamRequestPublicType)[keyof typeof SpanSearchStreamRequestPublicType];

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface AddThreadCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface AddTraceCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {
 *             name: "name",
 *             value: 1.1,
 *             source: "ui"
 *         }
 *     }
 */
interface AddTraceFeedbackScoreRequest {
    body: FeedbackScore;
}

/**
 * @example
 *     {
 *         projectName: "project_name",
 *         threadId: "thread_id",
 *         names: ["names"]
 *     }
 */
interface DeleteThreadFeedbackScores {
    projectName: string;
    threadId: string;
    names: string[];
    author?: string;
}

/**
 * @example
 *     {}
 */
type DeleteTraceByIdRequest = {};

/**
 * @example
 *     {
 *         body: {
 *             name: "name"
 *         }
 *     }
 */
interface DeleteTraceFeedbackScoreRequest {
    body: DeleteFeedbackScore;
}

/**
 * @example
 *     {
 *         threadIds: ["thread_ids"]
 *     }
 */
interface DeleteTraceThreads {
    /** If null, project_id must be provided */
    projectName?: string;
    /** If null, project_name must be provided */
    projectId?: string;
    threadIds: string[];
}

/**
 * @example
 *     {
 *         scores: [{
 *                 name: "name",
 *                 value: 1.1,
 *                 source: "ui",
 *                 threadId: "thread_id"
 *             }]
 *     }
 */
interface FeedbackScoreBatchThread {
    scores: FeedbackScoreBatchItemThread[];
}

/**
 * @example
 *     {}
 */
interface FindFeedbackScoreNames2Request {
    projectId?: string;
}

/**
 * @example
 *     {}
 */
interface FindTraceThreadsFeedbackScoreNamesRequest {
    projectId?: string;
}

/**
 * @example
 *     {}
 */
type GetThreadCommentRequest = {};

/**
 * @example
 *     {}
 */
interface GetTraceByIdRequest {
    stripAttachments?: boolean;
}

/**
 * @example
 *     {}
 */
type GetTraceCommentRequest = {};

/**
 * @example
 *     {}
 */
interface GetTraceStatsRequest {
    projectId?: string;
    projectName?: string;
    filters?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {}
 */
interface GetTracesByProjectRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    filters?: string;
    truncate?: boolean;
    stripAttachments?: boolean;
    sorting?: string;
    exclude?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {}
 */
interface GetTraceThreadStatsRequest {
    projectId?: string;
    projectName?: string;
    filters?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {}
 */
interface GetTraceThreadsRequest {
    page?: number;
    size?: number;
    projectName?: string;
    projectId?: string;
    truncate?: boolean;
    stripAttachments?: boolean;
    filters?: string;
    sorting?: string;
    fromTime?: Date;
    toTime?: Date;
}

/**
 * @example
 *     {
 *         ids: ["ids"],
 *         update: {}
 *     }
 */
interface TraceBatchUpdate {
    /** List of trace IDs to update (max 1000) */
    ids: string[];
    update: TraceUpdate;
    /** If true, merge tags with existing tags instead of replacing them. Default: false */
    mergeTags?: boolean;
}

/**
 * @example
 *     {
 *         traces: [{
 *                 startTime: new Date("2024-01-15T09:30:00.000Z")
 *             }]
 *     }
 */
interface TraceBatchWrite {
    traces: TraceWrite[];
}

/**
 * @example
 *     {}
 */
interface TraceSearchStreamRequestPublic {
    projectName?: string;
    projectId?: string;
    filters?: TraceFilterPublic[];
    lastRetrievedId?: string;
    /** Max number of traces to be streamed */
    limit?: number;
    /** Truncate input, output and metadata to slim payloads */
    truncate?: boolean;
    /** If true, returns attachment references like [file.png]; if false, downloads and reinjects stripped attachments */
    stripAttachments?: boolean;
    /** Filter traces created from this time (ISO-8601 format). */
    fromTime?: Date;
    /** Filter traces created up to this time (ISO-8601 format). If not provided, defaults to current time. Must be after 'from_time'. */
    toTime?: Date;
}

/**
 * @example
 *     {}
 */
interface TraceThreadBatchIdentifier {
    projectName?: string;
    projectId?: string;
    threadId?: string;
    threadIds?: string[];
}

/**
 * @example
 *     {
 *         ids: ["ids"],
 *         update: {}
 *     }
 */
interface TraceThreadBatchUpdate {
    /** List of thread model IDs to update (max 1000) */
    ids: string[];
    update: TraceThreadUpdate;
    /** If true, merge tags with existing tags instead of replacing them. Default: false */
    mergeTags?: boolean;
}

/**
 * @example
 *     {}
 */
interface TraceThreadSearchStreamRequest {
    projectName?: string;
    projectId?: string;
    filters?: TraceThreadFilter[];
    lastRetrievedThreadModelId?: string;
    /** Max number of trace thread to be streamed */
    limit?: number;
    /** Truncate input, output and metadata to slim payloads */
    truncate?: boolean;
    /** If true, returns attachment references like [file.png]; if false, downloads and reinjects stripped attachments */
    stripAttachments?: boolean;
    /** Filter trace threads created from this time (ISO-8601 format). */
    fromTime?: Date;
    /** Filter trace threads created up to this time (ISO-8601 format). If not provided, defaults to current time. Must be after 'from_time'. */
    toTime?: Date;
}

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface UpdateThreadCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {}
 *     }
 */
interface UpdateThreadRequest {
    body: TraceThreadUpdate;
}

/**
 * @example
 *     {
 *         body: {
 *             text: "text"
 *         }
 *     }
 */
interface UpdateTraceCommentRequest {
    body: Comment;
}

/**
 * @example
 *     {
 *         body: {}
 *     }
 */
interface UpdateTraceRequest {
    body: TraceUpdate;
}

/**
 * @example
 *     {}
 */
interface WelcomeWizardSubmission {
    /** Optional user role */
    role?: string;
    /** List of integrations the user selected */
    integrations?: string[];
    /** Optional user email */
    email?: string;
    /** Whether user wants to join beta programs */
    joinBetaProgram?: boolean;
}

interface AggregationData {
    experimentCount?: number;
    traceCount?: number;
    totalEstimatedCost?: number;
    totalEstimatedCostAvg?: number;
    duration?: PercentageValues;
    feedbackScores?: FeedbackScoreAverage[];
    experimentScores?: FeedbackScoreAverage[];
}

interface AlertPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: AlertPublic[];
    sortableBy?: string[];
}

interface AlertPublic {
    id?: string;
    name?: string;
    enabled?: boolean;
    alertType?: AlertPublicAlertType;
    metadata?: Record<string, string>;
    webhook: WebhookPublic;
    triggers?: AlertTriggerPublic[];
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

declare const AlertPublicAlertType: {
    readonly General: "general";
    readonly Slack: "slack";
    readonly Pagerduty: "pagerduty";
};
type AlertPublicAlertType = (typeof AlertPublicAlertType)[keyof typeof AlertPublicAlertType];

interface AlertTriggerConfigPublic {
    id?: string;
    alertTriggerId?: string;
    type: AlertTriggerConfigPublicType;
    configValue?: Record<string, string>;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

declare const AlertTriggerConfigPublicType: {
    readonly ScopeProject: "scope:project";
    readonly ThresholdFeedbackScore: "threshold:feedback_score";
    readonly ThresholdCost: "threshold:cost";
    readonly ThresholdLatency: "threshold:latency";
    readonly ThresholdErrors: "threshold:errors";
};
type AlertTriggerConfigPublicType = (typeof AlertTriggerConfigPublicType)[keyof typeof AlertTriggerConfigPublicType];

interface AlertTriggerConfigWrite {
    id?: string;
    type: AlertTriggerConfigWriteType;
    configValue?: Record<string, string>;
}

declare const AlertTriggerConfigWriteType: {
    readonly ScopeProject: "scope:project";
    readonly ThresholdFeedbackScore: "threshold:feedback_score";
    readonly ThresholdCost: "threshold:cost";
    readonly ThresholdLatency: "threshold:latency";
    readonly ThresholdErrors: "threshold:errors";
};
type AlertTriggerConfigWriteType = (typeof AlertTriggerConfigWriteType)[keyof typeof AlertTriggerConfigWriteType];

interface AlertTriggerPublic {
    id?: string;
    alertId?: string;
    eventType: AlertTriggerPublicEventType;
    triggerConfigs?: AlertTriggerConfigPublic[];
    createdAt?: Date;
    createdBy?: string;
}

declare const AlertTriggerPublicEventType: {
    readonly TraceErrors: "trace:errors";
    readonly TraceFeedbackScore: "trace:feedback_score";
    readonly TraceThreadFeedbackScore: "trace_thread:feedback_score";
    readonly PromptCreated: "prompt:created";
    readonly PromptCommitted: "prompt:committed";
    readonly TraceGuardrailsTriggered: "trace:guardrails_triggered";
    readonly PromptDeleted: "prompt:deleted";
    readonly ExperimentFinished: "experiment:finished";
    readonly TraceCost: "trace:cost";
    readonly TraceLatency: "trace:latency";
};
type AlertTriggerPublicEventType = (typeof AlertTriggerPublicEventType)[keyof typeof AlertTriggerPublicEventType];

interface AlertTriggerWrite {
    id?: string;
    eventType: AlertTriggerWriteEventType;
    triggerConfigs?: AlertTriggerConfigWrite[];
}

declare const AlertTriggerWriteEventType: {
    readonly TraceErrors: "trace:errors";
    readonly TraceFeedbackScore: "trace:feedback_score";
    readonly TraceThreadFeedbackScore: "trace_thread:feedback_score";
    readonly PromptCreated: "prompt:created";
    readonly PromptCommitted: "prompt:committed";
    readonly TraceGuardrailsTriggered: "trace:guardrails_triggered";
    readonly PromptDeleted: "prompt:deleted";
    readonly ExperimentFinished: "experiment:finished";
    readonly TraceCost: "trace:cost";
    readonly TraceLatency: "trace:latency";
};
type AlertTriggerWriteEventType = (typeof AlertTriggerWriteEventType)[keyof typeof AlertTriggerWriteEventType];

interface AlertWrite {
    id?: string;
    name?: string;
    enabled?: boolean;
    alertType?: AlertWriteAlertType;
    metadata?: Record<string, string>;
    webhook: WebhookWrite;
    triggers?: AlertTriggerWrite[];
}

declare const AlertWriteAlertType: {
    readonly General: "general";
    readonly Slack: "slack";
    readonly Pagerduty: "pagerduty";
};
type AlertWriteAlertType = (typeof AlertWriteAlertType)[keyof typeof AlertWriteAlertType];

interface AnnotationQueueItemIds {
    ids: string[];
}

interface AnnotationQueuePagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: AnnotationQueuePublic[];
    sortableBy?: string[];
}

interface AnnotationQueuePublic {
    id?: string;
    projectId: string;
    projectName?: string;
    name: string;
    description?: string;
    instructions?: string;
    scope: AnnotationQueuePublicScope;
    commentsEnabled?: boolean;
    feedbackDefinitionNames?: string[];
    reviewers?: AnnotationQueueReviewerPublic[];
    feedbackScores?: FeedbackScoreAveragePublic[];
    itemsCount?: number;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

declare const AnnotationQueuePublicScope: {
    readonly Trace: "trace";
    readonly Thread: "thread";
};
type AnnotationQueuePublicScope = (typeof AnnotationQueuePublicScope)[keyof typeof AnnotationQueuePublicScope];

interface AnnotationQueueReviewerPublic {
    username?: string;
    status?: number;
}

/**
 * List of annotation queues to create
 */
interface AnnotationQueueWrite {
    id?: string;
    projectId: string;
    name: string;
    description?: string;
    instructions?: string;
    scope: AnnotationQueueWriteScope;
    commentsEnabled?: boolean;
    feedbackDefinitionNames?: string[];
}

declare const AnnotationQueueWriteScope: {
    readonly Trace: "trace";
    readonly Thread: "thread";
};
type AnnotationQueueWriteScope = (typeof AnnotationQueueWriteScope)[keyof typeof AnnotationQueueWriteScope];

interface AssistantMessage {
    role?: AssistantMessageRole;
    content?: string;
    reasoningContent?: string;
    name?: string;
    toolCalls?: ToolCall[];
    refusal?: string;
    functionCall?: FunctionCall;
}

declare const AssistantMessageRole: {
    readonly System: "system";
    readonly User: "user";
    readonly Assistant: "assistant";
    readonly Tool: "tool";
    readonly Function: "function";
};
type AssistantMessageRole = (typeof AssistantMessageRole)[keyof typeof AssistantMessageRole];

interface Attachment {
    link?: string;
    fileName: string;
    fileSize: number;
    mimeType: string;
}

interface AttachmentPage {
    page?: number;
    size?: number;
    total?: number;
    content?: Attachment[];
    sortableBy?: string[];
}

interface AudioUrl {
    url: string;
}

interface AudioUrlPublic {
    url: string;
}

interface AudioUrlWrite {
    url: string;
}

type AuthDetailsHolder = Record<string, unknown>;

interface AutomationRuleEvaluatorLlmAsJudgePublic {
    filters?: TraceFilterPublic[];
    code?: LlmAsJudgeCodePublic;
}

interface AutomationRuleEvaluatorLlmAsJudgeWrite {
    filters?: TraceFilterWrite[];
    code?: LlmAsJudgeCodeWrite;
}

type AutomationRuleEvaluatorObjectObjectPublic = AutomationRuleEvaluatorObjectObjectPublic.LlmAsJudge | AutomationRuleEvaluatorObjectObjectPublic.UserDefinedMetricPython | AutomationRuleEvaluatorObjectObjectPublic.TraceThreadLlmAsJudge | AutomationRuleEvaluatorObjectObjectPublic.TraceThreadUserDefinedMetricPython | AutomationRuleEvaluatorObjectObjectPublic.SpanLlmAsJudge | AutomationRuleEvaluatorObjectObjectPublic.SpanUserDefinedMetricPython;
declare namespace AutomationRuleEvaluatorObjectObjectPublic {
    interface LlmAsJudge extends AutomationRuleEvaluatorLlmAsJudgePublic, _Base {
        type: "llm_as_judge";
    }
    interface UserDefinedMetricPython extends AutomationRuleEvaluatorUserDefinedMetricPythonPublic, _Base {
        type: "user_defined_metric_python";
    }
    interface TraceThreadLlmAsJudge extends AutomationRuleEvaluatorTraceThreadLlmAsJudgePublic, _Base {
        type: "trace_thread_llm_as_judge";
    }
    interface TraceThreadUserDefinedMetricPython extends AutomationRuleEvaluatorTraceThreadUserDefinedMetricPythonPublic, _Base {
        type: "trace_thread_user_defined_metric_python";
    }
    interface SpanLlmAsJudge extends AutomationRuleEvaluatorSpanLlmAsJudgePublic, _Base {
        type: "span_llm_as_judge";
    }
    interface SpanUserDefinedMetricPython extends AutomationRuleEvaluatorSpanUserDefinedMetricPythonPublic, _Base {
        type: "span_user_defined_metric_python";
    }
    interface _Base {
        id?: string;
        /** Primary project ID (legacy field for backwards compatibility) */
        projectId?: string;
        /** Primary project name (legacy field for backwards compatibility) */
        projectName?: string;
        /** Projects assigned to this rule (unique, sorted alphabetically by name) */
        projects?: ProjectReferencePublic[];
        name: string;
        samplingRate?: number;
        enabled?: boolean;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
        action: AutomationRuleEvaluatorObjectObjectPublicAction;
    }
}

declare const AutomationRuleEvaluatorObjectObjectPublicAction: {
    readonly Evaluator: "evaluator";
};
type AutomationRuleEvaluatorObjectObjectPublicAction = (typeof AutomationRuleEvaluatorObjectObjectPublicAction)[keyof typeof AutomationRuleEvaluatorObjectObjectPublicAction];

interface AutomationRuleEvaluatorPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: AutomationRuleEvaluatorObjectObjectPublic[];
    sortableBy?: string[];
}

type AutomationRuleEvaluatorPublic = AutomationRuleEvaluatorPublic.LlmAsJudge | AutomationRuleEvaluatorPublic.UserDefinedMetricPython | AutomationRuleEvaluatorPublic.TraceThreadLlmAsJudge | AutomationRuleEvaluatorPublic.TraceThreadUserDefinedMetricPython | AutomationRuleEvaluatorPublic.SpanLlmAsJudge | AutomationRuleEvaluatorPublic.SpanUserDefinedMetricPython;
declare namespace AutomationRuleEvaluatorPublic {
    interface LlmAsJudge extends AutomationRuleEvaluatorLlmAsJudgePublic, _Base {
        type: "llm_as_judge";
    }
    interface UserDefinedMetricPython extends AutomationRuleEvaluatorUserDefinedMetricPythonPublic, _Base {
        type: "user_defined_metric_python";
    }
    interface TraceThreadLlmAsJudge extends AutomationRuleEvaluatorTraceThreadLlmAsJudgePublic, _Base {
        type: "trace_thread_llm_as_judge";
    }
    interface TraceThreadUserDefinedMetricPython extends AutomationRuleEvaluatorTraceThreadUserDefinedMetricPythonPublic, _Base {
        type: "trace_thread_user_defined_metric_python";
    }
    interface SpanLlmAsJudge extends AutomationRuleEvaluatorSpanLlmAsJudgePublic, _Base {
        type: "span_llm_as_judge";
    }
    interface SpanUserDefinedMetricPython extends AutomationRuleEvaluatorSpanUserDefinedMetricPythonPublic, _Base {
        type: "span_user_defined_metric_python";
    }
    interface _Base {
        id?: string;
        /** Primary project ID (legacy field for backwards compatibility) */
        projectId?: string;
        /** Primary project name (legacy field for backwards compatibility) */
        projectName?: string;
        /** Projects assigned to this rule (unique, sorted alphabetically by name) */
        projects?: ProjectReferencePublic[];
        name: string;
        samplingRate?: number;
        enabled?: boolean;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
        action: AutomationRuleEvaluatorPublicAction;
    }
}

declare const AutomationRuleEvaluatorPublicAction: {
    readonly Evaluator: "evaluator";
};
type AutomationRuleEvaluatorPublicAction = (typeof AutomationRuleEvaluatorPublicAction)[keyof typeof AutomationRuleEvaluatorPublicAction];

interface AutomationRuleEvaluatorSpanLlmAsJudgePublic {
    filters?: SpanFilterPublic[];
    code?: SpanLlmAsJudgeCodePublic;
}

interface AutomationRuleEvaluatorSpanLlmAsJudgeWrite {
    filters?: SpanFilterWrite[];
    code?: SpanLlmAsJudgeCodeWrite;
}

interface AutomationRuleEvaluatorSpanUserDefinedMetricPythonPublic {
    filters?: SpanFilterPublic[];
    code?: SpanUserDefinedMetricPythonCodePublic;
}

interface AutomationRuleEvaluatorSpanUserDefinedMetricPythonWrite {
    filters?: SpanFilterWrite[];
    code?: SpanUserDefinedMetricPythonCodeWrite;
}

interface AutomationRuleEvaluatorTraceThreadLlmAsJudgePublic {
    filters?: TraceThreadFilterPublic[];
    code?: TraceThreadLlmAsJudgeCodePublic;
}

interface AutomationRuleEvaluatorTraceThreadLlmAsJudgeWrite {
    filters?: TraceThreadFilterWrite[];
    code?: TraceThreadLlmAsJudgeCodeWrite;
}

interface AutomationRuleEvaluatorTraceThreadUserDefinedMetricPythonPublic {
    filters?: TraceThreadFilterPublic[];
    code?: TraceThreadUserDefinedMetricPythonCodePublic;
}

interface AutomationRuleEvaluatorTraceThreadUserDefinedMetricPythonWrite {
    filters?: TraceThreadFilterWrite[];
    code?: TraceThreadUserDefinedMetricPythonCodeWrite;
}

type AutomationRuleEvaluatorUpdate = AutomationRuleEvaluatorUpdate.LlmAsJudge | AutomationRuleEvaluatorUpdate.UserDefinedMetricPython | AutomationRuleEvaluatorUpdate.TraceThreadLlmAsJudge | AutomationRuleEvaluatorUpdate.TraceThreadUserDefinedMetricPython | AutomationRuleEvaluatorUpdate.SpanLlmAsJudge | AutomationRuleEvaluatorUpdate.SpanUserDefinedMetricPython;
declare namespace AutomationRuleEvaluatorUpdate {
    interface LlmAsJudge extends AutomationRuleEvaluatorUpdateLlmAsJudge, _Base {
        type: "llm_as_judge";
    }
    interface UserDefinedMetricPython extends AutomationRuleEvaluatorUpdateUserDefinedMetricPython, _Base {
        type: "user_defined_metric_python";
    }
    interface TraceThreadLlmAsJudge extends AutomationRuleEvaluatorUpdateTraceThreadLlmAsJudge, _Base {
        type: "trace_thread_llm_as_judge";
    }
    interface TraceThreadUserDefinedMetricPython extends AutomationRuleEvaluatorUpdateTraceThreadUserDefinedMetricPython, _Base {
        type: "trace_thread_user_defined_metric_python";
    }
    interface SpanLlmAsJudge extends AutomationRuleEvaluatorUpdateSpanLlmAsJudge, _Base {
        type: "span_llm_as_judge";
    }
    interface SpanUserDefinedMetricPython extends AutomationRuleEvaluatorUpdateSpanUserDefinedMetricPython, _Base {
        type: "span_user_defined_metric_python";
    }
    interface _Base {
        name: string;
        samplingRate?: number;
        enabled?: boolean;
        /** Primary project ID (legacy field, maintained for backwards compatibility) */
        projectId?: string;
        /** Multiple project IDs (new field for multi-project support) */
        projectIds?: string[];
        action: AutomationRuleEvaluatorUpdateAction;
    }
}

declare const AutomationRuleEvaluatorUpdateAction: {
    readonly Evaluator: "evaluator";
};
type AutomationRuleEvaluatorUpdateAction = (typeof AutomationRuleEvaluatorUpdateAction)[keyof typeof AutomationRuleEvaluatorUpdateAction];

interface AutomationRuleEvaluatorUpdateLlmAsJudge {
    filters?: TraceFilter[];
    code?: LlmAsJudgeCode;
}

interface AutomationRuleEvaluatorUpdateSpanLlmAsJudge {
    filters?: SpanFilter[];
    code?: SpanLlmAsJudgeCode;
}

interface AutomationRuleEvaluatorUpdateSpanUserDefinedMetricPython {
    filters?: SpanFilter[];
    code?: SpanUserDefinedMetricPythonCode;
}

interface AutomationRuleEvaluatorUpdateTraceThreadLlmAsJudge {
    filters?: TraceThreadFilter[];
    code?: TraceThreadLlmAsJudgeCode;
}

interface AutomationRuleEvaluatorUpdateTraceThreadUserDefinedMetricPython {
    filters?: TraceThreadFilter[];
    code?: TraceThreadUserDefinedMetricPythonCode;
}

interface AutomationRuleEvaluatorUpdateUserDefinedMetricPython {
    filters?: TraceFilter[];
    code?: UserDefinedMetricPythonCode;
}

interface AutomationRuleEvaluatorUserDefinedMetricPythonPublic {
    filters?: TraceFilterPublic[];
    code?: UserDefinedMetricPythonCodePublic;
}

interface AutomationRuleEvaluatorUserDefinedMetricPythonWrite {
    filters?: TraceFilterWrite[];
    code?: UserDefinedMetricPythonCodeWrite;
}

type AutomationRuleEvaluatorWrite = AutomationRuleEvaluatorWrite.LlmAsJudge | AutomationRuleEvaluatorWrite.UserDefinedMetricPython | AutomationRuleEvaluatorWrite.TraceThreadLlmAsJudge | AutomationRuleEvaluatorWrite.TraceThreadUserDefinedMetricPython | AutomationRuleEvaluatorWrite.SpanLlmAsJudge | AutomationRuleEvaluatorWrite.SpanUserDefinedMetricPython;
declare namespace AutomationRuleEvaluatorWrite {
    interface LlmAsJudge extends AutomationRuleEvaluatorLlmAsJudgeWrite, _Base {
        type: "llm_as_judge";
    }
    interface UserDefinedMetricPython extends AutomationRuleEvaluatorUserDefinedMetricPythonWrite, _Base {
        type: "user_defined_metric_python";
    }
    interface TraceThreadLlmAsJudge extends AutomationRuleEvaluatorTraceThreadLlmAsJudgeWrite, _Base {
        type: "trace_thread_llm_as_judge";
    }
    interface TraceThreadUserDefinedMetricPython extends AutomationRuleEvaluatorTraceThreadUserDefinedMetricPythonWrite, _Base {
        type: "trace_thread_user_defined_metric_python";
    }
    interface SpanLlmAsJudge extends AutomationRuleEvaluatorSpanLlmAsJudgeWrite, _Base {
        type: "span_llm_as_judge";
    }
    interface SpanUserDefinedMetricPython extends AutomationRuleEvaluatorSpanUserDefinedMetricPythonWrite, _Base {
        type: "span_user_defined_metric_python";
    }
    interface _Base {
        /** Primary project ID (legacy field for backwards compatibility) */
        projectId?: string;
        /** Project IDs for write operations (used when creating/updating rules) */
        projectIds?: string[];
        name: string;
        samplingRate?: number;
        enabled?: boolean;
        action: AutomationRuleEvaluatorWriteAction;
    }
}

declare const AutomationRuleEvaluatorWriteAction: {
    readonly Evaluator: "evaluator";
};
type AutomationRuleEvaluatorWriteAction = (typeof AutomationRuleEvaluatorWriteAction)[keyof typeof AutomationRuleEvaluatorWriteAction];

interface AvgValueStatPublic {
    value?: number;
}

interface BatchDelete {
    ids: string[];
}

interface BiInformation {
    workspaceId?: string;
    user?: string;
    count?: number;
}

interface BiInformationResponse {
    biInformation?: BiInformation[];
}

interface BooleanFeedbackDefinitionCreate {
    details?: BooleanFeedbackDetailCreate;
}

interface BooleanFeedbackDefinitionPublic {
    details?: BooleanFeedbackDetailPublic;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

interface BooleanFeedbackDefinitionUpdate {
    details?: BooleanFeedbackDetailUpdate;
}

interface BooleanFeedbackDetailCreate {
    /** Label for true/1 value */
    trueLabel: string;
    /** Label for false/0 value */
    falseLabel: string;
}

interface BooleanFeedbackDetailPublic {
    /** Label for true/1 value */
    trueLabel: string;
    /** Label for false/0 value */
    falseLabel: string;
}

interface BooleanFeedbackDetailUpdate {
    /** Label for true/1 value */
    trueLabel: string;
    /** Label for false/0 value */
    falseLabel: string;
}

interface BreakdownConfigPublic {
    field?: BreakdownConfigPublicField;
    metadataKey?: string;
    subMetric?: string;
}

declare const BreakdownConfigPublicField: {
    readonly None: "none";
    readonly Tags: "tags";
    readonly Metadata: "metadata";
    readonly Name: "name";
    readonly ErrorInfo: "error_info";
    readonly Model: "model";
    readonly Provider: "provider";
    readonly Type: "type";
};
type BreakdownConfigPublicField = (typeof BreakdownConfigPublicField)[keyof typeof BreakdownConfigPublicField];

interface CategoricalFeedbackDefinitionCreate {
    details?: CategoricalFeedbackDetailCreate;
}

interface CategoricalFeedbackDefinitionPublic {
    details?: CategoricalFeedbackDetailPublic;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

interface CategoricalFeedbackDefinitionUpdate {
    details?: CategoricalFeedbackDetailUpdate;
}

interface CategoricalFeedbackDetailCreate {
    categories: Record<string, number>;
}

interface CategoricalFeedbackDetailPublic {
    categories: Record<string, number>;
}

interface CategoricalFeedbackDetailUpdate {
    categories: Record<string, number>;
}

interface ChatCompletionChoice {
    index?: number;
    message?: AssistantMessage;
    delta?: Delta;
    finishReason?: string;
}

interface ChatCompletionResponse {
    id?: string;
    created?: number;
    model?: string;
    choices?: ChatCompletionChoice[];
    usage?: Usage;
    systemFingerprint?: string;
    serviceTier?: string;
}

interface Check {
    name?: CheckName;
    result?: CheckResult;
}

declare const CheckName: {
    readonly Topic: "TOPIC";
    readonly Pii: "PII";
};
type CheckName = (typeof CheckName)[keyof typeof CheckName];

interface CheckPublic {
    name?: CheckPublicName;
    result?: CheckPublicResult;
}

declare const CheckPublicName: {
    readonly Topic: "TOPIC";
    readonly Pii: "PII";
};
type CheckPublicName = (typeof CheckPublicName)[keyof typeof CheckPublicName];

declare const CheckPublicResult: {
    readonly Passed: "passed";
    readonly Failed: "failed";
};
type CheckPublicResult = (typeof CheckPublicResult)[keyof typeof CheckPublicResult];

declare const CheckResult: {
    readonly Passed: "passed";
    readonly Failed: "failed";
};
type CheckResult = (typeof CheckResult)[keyof typeof CheckResult];

interface Column {
    name?: string;
    types?: ColumnTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

interface ColumnCompare {
    name?: string;
    types?: ColumnCompareTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

declare const ColumnCompareTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};
type ColumnCompareTypesItem = (typeof ColumnCompareTypesItem)[keyof typeof ColumnCompareTypesItem];

interface ColumnPublic {
    name?: string;
    types?: ColumnPublicTypesItem[];
    filterFieldPrefix?: string;
    /** The field to use for filtering */
    filterField?: string;
}

declare const ColumnPublicTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};
type ColumnPublicTypesItem = (typeof ColumnPublicTypesItem)[keyof typeof ColumnPublicTypesItem];

declare const ColumnTypesItem: {
    readonly String: "string";
    readonly Number: "number";
    readonly Object: "object";
    readonly Boolean: "boolean";
    readonly Array: "array";
    readonly Null: "null";
};
type ColumnTypesItem = (typeof ColumnTypesItem)[keyof typeof ColumnTypesItem];

interface Comment {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

interface CommentCompare {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

interface CommentPublic {
    id?: string;
    text: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

interface CompleteMultipartUploadRequest {
    fileName: string;
    /** If null, the default project is used */
    projectName?: string;
    entityType: CompleteMultipartUploadRequestEntityType;
    entityId: string;
    containerId?: string;
    fileSize: number;
    mimeType?: string;
    uploadId: string;
    uploadedFileParts: MultipartUploadPart[];
}

declare const CompleteMultipartUploadRequestEntityType: {
    readonly Trace: "trace";
    readonly Span: "span";
};
type CompleteMultipartUploadRequestEntityType = (typeof CompleteMultipartUploadRequestEntityType)[keyof typeof CompleteMultipartUploadRequestEntityType];

interface CompletionTokensDetails {
    reasoningTokens?: number;
}

interface CountValueStatPublic {
    value?: number;
}

interface DashboardPagePublic {
    content?: DashboardPublic[];
    page?: number;
    size?: number;
    total?: number;
    sortableBy?: string[];
}

interface DashboardPublic {
    id?: string;
    workspaceId?: string;
    name: string;
    slug?: string;
    description?: string;
    config: JsonNodePublic;
    createdBy?: string;
    lastUpdatedBy?: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
}

interface DataPointNumberPublic {
    time: Date;
    value?: number;
}

interface DatasetExpansionResponse {
    /** List of generated synthetic dataset items */
    generatedSamples?: DatasetItem[];
    /** Model used for generation */
    model?: string;
    /** Total number of samples generated */
    totalGenerated?: number;
    /** Generation timestamp */
    generationTime?: Date;
}

interface DatasetExportJobPublic {
    id?: string;
    datasetId?: string;
    datasetName?: string;
    status?: DatasetExportJobPublicStatus;
    filePath?: string;
    errorMessage?: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    expiresAt?: Date;
    viewedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

declare const DatasetExportJobPublicStatus: {
    readonly Pending: "PENDING";
    readonly Processing: "PROCESSING";
    readonly Completed: "COMPLETED";
    readonly Failed: "FAILED";
};
type DatasetExportJobPublicStatus = (typeof DatasetExportJobPublicStatus)[keyof typeof DatasetExportJobPublicStatus];

interface DatasetItem {
    id?: string;
    datasetItemId?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemSource;
    data: JsonNode;
    tags?: string[];
    experimentItems?: ExperimentItem[];
    datasetId?: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

type DatasetItemChangesPublic = Record<string, unknown>;

interface DatasetItemCompare {
    id?: string;
    datasetItemId?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemCompareSource;
    data: JsonNode;
    tags?: string[];
    experimentItems?: ExperimentItemCompare[];
    datasetId?: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

declare const DatasetItemCompareSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};
type DatasetItemCompareSource = (typeof DatasetItemCompareSource)[keyof typeof DatasetItemCompareSource];

/**
 * Filters to select dataset items to delete within the specified dataset. Must be used with 'dataset_id'. Mutually exclusive with 'item_ids'. Empty array means 'delete all items in the dataset'.
 */
interface DatasetItemFilter {
    field?: string;
    operator?: DatasetItemFilterOperator;
    key?: string;
    value?: string;
}

declare const DatasetItemFilterOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type DatasetItemFilterOperator = (typeof DatasetItemFilterOperator)[keyof typeof DatasetItemFilterOperator];

interface DatasetItemPageCompare {
    content?: DatasetItemCompare[];
    page?: number;
    size?: number;
    total?: number;
    columns?: ColumnCompare[];
    sortableBy?: string[];
}

interface DatasetItemPagePublic {
    content?: DatasetItemPublic[];
    page?: number;
    size?: number;
    total?: number;
    columns?: ColumnPublic[];
    sortableBy?: string[];
}

interface DatasetItemPublic {
    id?: string;
    datasetItemId?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemPublicSource;
    data: JsonNode;
    tags?: string[];
    experimentItems?: ExperimentItemPublic[];
    datasetId?: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
}

declare const DatasetItemPublicSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};
type DatasetItemPublicSource = (typeof DatasetItemPublicSource)[keyof typeof DatasetItemPublicSource];

declare const DatasetItemSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};
type DatasetItemSource = (typeof DatasetItemSource)[keyof typeof DatasetItemSource];

/**
 * Dataset item update request
 */
interface DatasetItemUpdate {
    /** Dataset item input */
    input?: string;
    /** Dataset item expected output */
    expectedOutput?: string;
    metadata?: JsonNode;
    data?: JsonNode;
    /** Tags */
    tags?: string[];
}

interface DatasetItemWrite {
    id?: string;
    traceId?: string;
    spanId?: string;
    source: DatasetItemWriteSource;
    data: JsonNode;
    tags?: string[];
}

declare const DatasetItemWriteSource: {
    readonly Manual: "manual";
    readonly Trace: "trace";
    readonly Span: "span";
    readonly Sdk: "sdk";
};
type DatasetItemWriteSource = (typeof DatasetItemWriteSource)[keyof typeof DatasetItemWriteSource];

interface DatasetPagePublic {
    content?: DatasetPublic[];
    page?: number;
    size?: number;
    total?: number;
    sortableBy?: string[];
}

interface DatasetPublic {
    id?: string;
    name: string;
    visibility?: DatasetPublicVisibility;
    tags?: string[];
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    experimentCount?: number;
    datasetItemsCount?: number;
    optimizationCount?: number;
    mostRecentExperimentAt?: Date;
    lastCreatedExperimentAt?: Date;
    mostRecentOptimizationAt?: Date;
    lastCreatedOptimizationAt?: Date;
    status?: DatasetPublicStatus;
    latestVersion?: DatasetVersionSummaryPublic;
}

declare const DatasetPublicStatus: {
    readonly Unknown: "unknown";
    readonly Processing: "processing";
    readonly Completed: "completed";
    readonly Failed: "failed";
};
type DatasetPublicStatus = (typeof DatasetPublicStatus)[keyof typeof DatasetPublicStatus];

declare const DatasetPublicVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type DatasetPublicVisibility = (typeof DatasetPublicVisibility)[keyof typeof DatasetPublicVisibility];

interface DatasetVersionDiff {
    fromVersion?: string;
    toVersion?: string;
    statistics?: DatasetVersionDiffStats;
}

interface DatasetVersionDiffStats {
    itemsAdded?: number;
    itemsModified?: number;
    itemsDeleted?: number;
    itemsUnchanged?: number;
}

interface DatasetVersionPagePublic {
    content?: DatasetVersionPublic[];
    page?: number;
    size?: number;
    total?: number;
}

interface DatasetVersionPublic {
    id?: string;
    datasetId?: string;
    versionHash?: string;
    tags?: string[];
    /** Indicates whether this is the latest version of the dataset */
    isLatest?: boolean;
    /** Sequential version name formatted as 'v1', 'v2', etc. */
    versionName?: string;
    /** Total number of items in this version */
    itemsTotal?: number;
    /** Number of items added since last version */
    itemsAdded?: number;
    /** Number of items modified since last version */
    itemsModified?: number;
    /** Number of items deleted since last version */
    itemsDeleted?: number;
    changeDescription?: string;
    metadata?: Record<string, string>;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

/**
 * Summary of the latest dataset version
 */
interface DatasetVersionSummaryPublic {
    /** Unique identifier of the version */
    id?: string;
    /** Hash of the version content */
    versionHash?: string;
    /** Sequential version name formatted as 'v1', 'v2', etc. */
    versionName?: string;
    /** Description of changes in this version */
    changeDescription?: string;
    /** Tags associated with this version */
    tags?: string[];
}

interface DeleteFeedbackScore {
    name: string;
    author?: string;
}

interface DeleteIdsHolder {
    ids: string[];
}

interface Delta {
    role?: string;
    content?: string;
    reasoningContent?: string;
    toolCalls?: ToolCall[];
    functionCall?: FunctionCall;
}

interface ErrorCountWithDeviation {
    count?: number;
    deviation?: number;
    deviationPercentage?: number;
}

interface ErrorCountWithDeviationDetailed {
    count?: number;
    deviation?: number;
    deviationPercentage?: number;
}

interface ErrorInfo {
    exceptionType: string;
    message?: string;
    traceback: string;
}

interface ErrorInfoExperimentItemBulkWriteView {
    exceptionType: string;
    message?: string;
    traceback: string;
}

interface ErrorInfoPublic {
    exceptionType: string;
    message?: string;
    traceback: string;
}

interface ErrorInfoWrite {
    exceptionType: string;
    message?: string;
    traceback: string;
}

interface ExperimentGroupAggregationsResponse {
    content?: Record<string, GroupContentWithAggregations>;
}

interface ExperimentGroupResponse {
    content?: Record<string, GroupContent>;
    details?: GroupDetails;
}

interface ExperimentItem {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    input?: JsonListString;
    output?: JsonListString;
    feedbackScores?: FeedbackScore[];
    comments?: Comment[];
    totalEstimatedCost?: number;
    duration?: number;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    traceVisibilityMode?: ExperimentItemTraceVisibilityMode;
}

interface ExperimentItemBulkRecordExperimentItemBulkWriteView {
    datasetItemId: string;
    evaluateTaskResult?: JsonListStringExperimentItemBulkWriteView;
    trace?: TraceExperimentItemBulkWriteView;
    spans?: SpanExperimentItemBulkWriteView[];
    feedbackScores?: FeedbackScoreExperimentItemBulkWriteView[];
}

interface ExperimentItemCompare {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    input?: JsonListStringCompare;
    output?: JsonListStringCompare;
    feedbackScores?: FeedbackScoreCompare[];
    comments?: CommentCompare[];
    totalEstimatedCost?: number;
    duration?: number;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    traceVisibilityMode?: ExperimentItemCompareTraceVisibilityMode;
}

declare const ExperimentItemCompareTraceVisibilityMode: {
    readonly Default: "default";
    readonly Hidden: "hidden";
};
type ExperimentItemCompareTraceVisibilityMode = (typeof ExperimentItemCompareTraceVisibilityMode)[keyof typeof ExperimentItemCompareTraceVisibilityMode];

interface ExperimentItemPublic {
    id?: string;
    experimentId: string;
    datasetItemId: string;
    traceId: string;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    traceVisibilityMode?: ExperimentItemPublicTraceVisibilityMode;
}

declare const ExperimentItemPublicTraceVisibilityMode: {
    readonly Default: "default";
    readonly Hidden: "hidden";
};
type ExperimentItemPublicTraceVisibilityMode = (typeof ExperimentItemPublicTraceVisibilityMode)[keyof typeof ExperimentItemPublicTraceVisibilityMode];

/**
 * Experiment reference with ID, name, dataset ID, and dataset item ID
 */
interface ExperimentItemReference {
    /** Experiment ID */
    id: string;
    /** Experiment name */
    name: string;
    /** Dataset ID */
    datasetId: string;
    /** Dataset Item ID */
    datasetItemId: string;
}

/**
 * Experiment reference with ID, name, dataset ID, and dataset item ID
 */
interface ExperimentItemReferencePublic {
    /** Experiment ID */
    id: string;
    /** Experiment name */
    name: string;
    /** Dataset ID */
    datasetId: string;
    /** Dataset Item ID */
    datasetItemId: string;
}

declare const ExperimentItemTraceVisibilityMode: {
    readonly Default: "default";
    readonly Hidden: "hidden";
};
type ExperimentItemTraceVisibilityMode = (typeof ExperimentItemTraceVisibilityMode)[keyof typeof ExperimentItemTraceVisibilityMode];

interface ExperimentPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: ExperimentPublic[];
    sortableBy?: string[];
}

interface ExperimentPublic {
    id?: string;
    datasetName: string;
    datasetId?: string;
    projectId?: string;
    projectName?: string;
    name?: string;
    metadata?: JsonListStringPublic;
    tags?: string[];
    type?: ExperimentPublicType;
    optimizationId?: string;
    feedbackScores?: FeedbackScoreAveragePublic[];
    comments?: CommentPublic[];
    traceCount?: number;
    createdAt?: Date;
    duration?: PercentageValuesPublic;
    totalEstimatedCost?: number;
    totalEstimatedCostAvg?: number;
    usage?: Record<string, number>;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    status?: ExperimentPublicStatus;
    experimentScores?: ExperimentScorePublic[];
    promptVersion?: PromptVersionLinkPublic;
    promptVersions?: PromptVersionLinkPublic[];
    /** ID of the dataset version this experiment is linked to. If not provided at creation, experiment will be automatically linked to the latest version. */
    datasetVersionId?: string;
    datasetVersionSummary?: DatasetVersionSummaryPublic;
}

declare const ExperimentPublicStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
};
type ExperimentPublicStatus = (typeof ExperimentPublicStatus)[keyof typeof ExperimentPublicStatus];

declare const ExperimentPublicType: {
    readonly Regular: "regular";
    readonly Trial: "trial";
    readonly MiniBatch: "mini-batch";
};
type ExperimentPublicType = (typeof ExperimentPublicType)[keyof typeof ExperimentPublicType];

interface ExperimentScore {
    name: string;
    value: number;
}

interface ExperimentScorePublic {
    name: string;
    value: number;
}

interface ExperimentScoreWrite {
    name: string;
    value: number;
}

declare const ExperimentType: {
    readonly Regular: "regular";
    readonly Trial: "trial";
    readonly MiniBatch: "mini-batch";
};
type ExperimentType = (typeof ExperimentType)[keyof typeof ExperimentType];

interface ExperimentUpdate {
    name?: string;
    metadata?: JsonNode;
    tags?: string[];
    type?: ExperimentUpdateType;
    /** The status of the experiment */
    status?: ExperimentUpdateStatus;
    experimentScores?: ExperimentScore[];
}

/** The status of the experiment */
declare const ExperimentUpdateStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
};
type ExperimentUpdateStatus = (typeof ExperimentUpdateStatus)[keyof typeof ExperimentUpdateStatus];

declare const ExperimentUpdateType: {
    readonly Regular: "regular";
    readonly Trial: "trial";
    readonly MiniBatch: "mini-batch";
};
type ExperimentUpdateType = (typeof ExperimentUpdateType)[keyof typeof ExperimentUpdateType];

type FeedbackCreate = FeedbackCreate.Numerical | FeedbackCreate.Categorical | FeedbackCreate.Boolean;
declare namespace FeedbackCreate {
    interface Numerical extends NumericalFeedbackDefinitionCreate, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionCreate, _Base {
        type: "categorical";
    }
    interface Boolean extends BooleanFeedbackDefinitionCreate, _Base {
        type: "boolean";
    }
    interface _Base {
        id?: string;
        name: string;
        /** Optional description for the feedback definition */
        description?: string;
    }
}

interface FeedbackDefinitionPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: FeedbackObjectPublic[];
}

type FeedbackObjectPublic = FeedbackObjectPublic.Numerical | FeedbackObjectPublic.Categorical | FeedbackObjectPublic.Boolean;
declare namespace FeedbackObjectPublic {
    interface Numerical extends NumericalFeedbackDefinitionPublic, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionPublic, _Base {
        type: "categorical";
    }
    interface Boolean extends BooleanFeedbackDefinitionPublic, _Base {
        type: "boolean";
    }
    interface _Base {
        id?: string;
        name: string;
        /** Optional description for the feedback definition */
        description?: string;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
    }
    type Request = FeedbackObjectPublic.Numerical | FeedbackObjectPublic.Categorical | FeedbackObjectPublic.Boolean;
}

type FeedbackPublic = FeedbackPublic.Numerical | FeedbackPublic.Categorical | FeedbackPublic.Boolean;
declare namespace FeedbackPublic {
    interface Numerical extends NumericalFeedbackDefinitionPublic, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionPublic, _Base {
        type: "categorical";
    }
    interface Boolean extends BooleanFeedbackDefinitionPublic, _Base {
        type: "boolean";
    }
    interface _Base {
        id?: string;
        name: string;
        /** Optional description for the feedback definition */
        description?: string;
        createdAt?: Date;
        createdBy?: string;
        lastUpdatedAt?: Date;
        lastUpdatedBy?: string;
    }
    type Request = FeedbackPublic.Numerical | FeedbackPublic.Categorical | FeedbackPublic.Boolean;
}

interface FeedbackScore {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    valueByAuthor?: Record<string, ValueEntry>;
}

interface FeedbackScoreAverage {
    name: string;
    value: number;
}

interface FeedbackScoreAverageDetailed {
    name: string;
    value: number;
}

interface FeedbackScoreAveragePublic {
    name: string;
    value: number;
}

interface FeedbackScoreBatch {
    scores: FeedbackScoreBatchItem[];
}

interface FeedbackScoreBatchItem {
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreBatchItemSource;
    author?: string;
    id: string;
}

declare const FeedbackScoreBatchItemSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScoreBatchItemSource = (typeof FeedbackScoreBatchItemSource)[keyof typeof FeedbackScoreBatchItemSource];

interface FeedbackScoreBatchItemThread {
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreBatchItemThreadSource;
    author?: string;
    threadId: string;
}

declare const FeedbackScoreBatchItemThreadSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScoreBatchItemThreadSource = (typeof FeedbackScoreBatchItemThreadSource)[keyof typeof FeedbackScoreBatchItemThreadSource];

interface FeedbackScoreCompare {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreCompareSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    valueByAuthor?: Record<string, ValueEntryCompare>;
}

declare const FeedbackScoreCompareSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScoreCompareSource = (typeof FeedbackScoreCompareSource)[keyof typeof FeedbackScoreCompareSource];

interface FeedbackScoreExperimentItemBulkWriteView {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScoreExperimentItemBulkWriteViewSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    valueByAuthor?: Record<string, ValueEntryExperimentItemBulkWriteView>;
}

declare const FeedbackScoreExperimentItemBulkWriteViewSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScoreExperimentItemBulkWriteViewSource = (typeof FeedbackScoreExperimentItemBulkWriteViewSource)[keyof typeof FeedbackScoreExperimentItemBulkWriteViewSource];

interface FeedbackScoreNames {
    scores?: ScoreName[];
}

/**
 * Aggregated feedback scores from all spans in this trace, averaged by score name
 */
interface FeedbackScorePublic {
    name: string;
    categoryName?: string;
    value: number;
    reason?: string;
    source: FeedbackScorePublicSource;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    valueByAuthor?: Record<string, ValueEntryPublic>;
}

declare const FeedbackScorePublicSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScorePublicSource = (typeof FeedbackScorePublicSource)[keyof typeof FeedbackScorePublicSource];

declare const FeedbackScoreSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type FeedbackScoreSource = (typeof FeedbackScoreSource)[keyof typeof FeedbackScoreSource];

type FeedbackUpdate = FeedbackUpdate.Numerical | FeedbackUpdate.Categorical | FeedbackUpdate.Boolean;
declare namespace FeedbackUpdate {
    interface Numerical extends NumericalFeedbackDefinitionUpdate, _Base {
        type: "numerical";
    }
    interface Categorical extends CategoricalFeedbackDefinitionUpdate, _Base {
        type: "categorical";
    }
    interface Boolean extends BooleanFeedbackDefinitionUpdate, _Base {
        type: "boolean";
    }
    interface _Base {
        id?: string;
        name: string;
        /** Optional description for the feedback definition */
        description?: string;
    }
}

interface Function$1 {
    name?: string;
    description?: string;
    strict?: boolean;
    parameters?: Record<string, Record<string, unknown>>;
}

interface FunctionCall {
    name?: string;
    arguments?: string;
}

interface GroupContent {
    label?: string;
}

interface GroupContentWithAggregations {
    label?: string;
    aggregations?: AggregationData;
}

interface GroupDetail {
    groupSorting?: string[];
}

interface GroupDetails {
    groupsDetails?: GroupDetail[];
}

interface GuardrailsValidation {
    spanId?: string;
    checks?: Check[];
}

interface GuardrailsValidationPublic {
    spanId?: string;
    checks?: CheckPublic[];
}

interface GuardrailWrite {
    entityId: string;
    secondaryId: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    name: GuardrailWriteName;
    result: GuardrailWriteResult;
    config: JsonNode;
    details: JsonNode;
}

declare const GuardrailWriteName: {
    readonly Topic: "TOPIC";
    readonly Pii: "PII";
};
type GuardrailWriteName = (typeof GuardrailWriteName)[keyof typeof GuardrailWriteName];

declare const GuardrailWriteResult: {
    readonly Passed: "passed";
    readonly Failed: "failed";
};
type GuardrailWriteResult = (typeof GuardrailWriteResult)[keyof typeof GuardrailWriteResult];

interface ImageUrl {
    url: string;
    detail?: string;
}

interface ImageUrlPublic {
    url: string;
    detail?: string;
}

interface ImageUrlWrite {
    url: string;
    detail?: string;
}

type JsonListString = Record<string, unknown> | Record<string, unknown>[] | string;

type JsonListStringCompare = Record<string, unknown> | Record<string, unknown>[] | string;

type JsonListStringExperimentItemBulkWriteView = Record<string, unknown> | Record<string, unknown>[] | string;

type JsonListStringPublic = Record<string, unknown> | Record<string, unknown>[] | string;

type JsonListStringWrite = Record<string, unknown> | Record<string, unknown>[] | string;

type JsonNode = Record<string, unknown>;

type JsonNodeDetail = Record<string, unknown>;

type JsonNodePublic = Record<string, unknown>;

type JsonNodeWrite = Record<string, unknown>;

interface JsonSchema {
    name?: string;
    strict?: boolean;
    schema?: Record<string, Record<string, unknown>>;
}

interface LlmAsJudgeCode {
    model: LlmAsJudgeModelParameters;
    messages: LlmAsJudgeMessage[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchema[];
}

interface LlmAsJudgeCodePublic {
    model: LlmAsJudgeModelParametersPublic;
    messages: LlmAsJudgeMessagePublic[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchemaPublic[];
}

interface LlmAsJudgeCodeWrite {
    model: LlmAsJudgeModelParametersWrite;
    messages: LlmAsJudgeMessageWrite[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchemaWrite[];
}

interface LlmAsJudgeMessage {
    role: LlmAsJudgeMessageRole;
    content?: string;
    contentArray?: LlmAsJudgeMessageContent[];
    stringContent?: boolean;
    structuredContent?: boolean;
}

interface LlmAsJudgeMessageContent {
    type: string;
    text?: string;
    imageUrl?: ImageUrl;
    videoUrl?: VideoUrl;
    audioUrl?: AudioUrl;
}

interface LlmAsJudgeMessageContentPublic {
    type: string;
    text?: string;
    imageUrl?: ImageUrlPublic;
    videoUrl?: VideoUrlPublic;
    audioUrl?: AudioUrlPublic;
}

interface LlmAsJudgeMessageContentWrite {
    type: string;
    text?: string;
    imageUrl?: ImageUrlWrite;
    videoUrl?: VideoUrlWrite;
    audioUrl?: AudioUrlWrite;
}

interface LlmAsJudgeMessagePublic {
    role: LlmAsJudgeMessagePublicRole;
    content?: string;
    contentArray?: LlmAsJudgeMessageContentPublic[];
    stringContent?: boolean;
    structuredContent?: boolean;
}

declare const LlmAsJudgeMessagePublicRole: {
    readonly System: "SYSTEM";
    readonly User: "USER";
    readonly Ai: "AI";
    readonly ToolExecutionResult: "TOOL_EXECUTION_RESULT";
    readonly Custom: "CUSTOM";
};
type LlmAsJudgeMessagePublicRole = (typeof LlmAsJudgeMessagePublicRole)[keyof typeof LlmAsJudgeMessagePublicRole];

declare const LlmAsJudgeMessageRole: {
    readonly System: "SYSTEM";
    readonly User: "USER";
    readonly Ai: "AI";
    readonly ToolExecutionResult: "TOOL_EXECUTION_RESULT";
    readonly Custom: "CUSTOM";
};
type LlmAsJudgeMessageRole = (typeof LlmAsJudgeMessageRole)[keyof typeof LlmAsJudgeMessageRole];

interface LlmAsJudgeMessageWrite {
    role: LlmAsJudgeMessageWriteRole;
    content?: string;
    contentArray?: LlmAsJudgeMessageContentWrite[];
    stringContent?: boolean;
    structuredContent?: boolean;
}

declare const LlmAsJudgeMessageWriteRole: {
    readonly System: "SYSTEM";
    readonly User: "USER";
    readonly Ai: "AI";
    readonly ToolExecutionResult: "TOOL_EXECUTION_RESULT";
    readonly Custom: "CUSTOM";
};
type LlmAsJudgeMessageWriteRole = (typeof LlmAsJudgeMessageWriteRole)[keyof typeof LlmAsJudgeMessageWriteRole];

interface LlmAsJudgeModelParameters {
    name: string;
    temperature: number;
    seed?: number;
    customParameters?: JsonNode;
}

interface LlmAsJudgeModelParametersPublic {
    name: string;
    temperature: number;
    seed?: number;
    customParameters?: JsonNodePublic;
}

interface LlmAsJudgeModelParametersWrite {
    name: string;
    temperature: number;
    seed?: number;
    customParameters?: JsonNodeWrite;
}

interface LlmAsJudgeOutputSchema {
    name: string;
    type: LlmAsJudgeOutputSchemaType;
    description: string;
}

interface LlmAsJudgeOutputSchemaPublic {
    name: string;
    type: LlmAsJudgeOutputSchemaPublicType;
    description: string;
}

declare const LlmAsJudgeOutputSchemaPublicType: {
    readonly Boolean: "BOOLEAN";
    readonly Integer: "INTEGER";
    readonly Double: "DOUBLE";
};
type LlmAsJudgeOutputSchemaPublicType = (typeof LlmAsJudgeOutputSchemaPublicType)[keyof typeof LlmAsJudgeOutputSchemaPublicType];

declare const LlmAsJudgeOutputSchemaType: {
    readonly Boolean: "BOOLEAN";
    readonly Integer: "INTEGER";
    readonly Double: "DOUBLE";
};
type LlmAsJudgeOutputSchemaType = (typeof LlmAsJudgeOutputSchemaType)[keyof typeof LlmAsJudgeOutputSchemaType];

interface LlmAsJudgeOutputSchemaWrite {
    name: string;
    type: LlmAsJudgeOutputSchemaWriteType;
    description: string;
}

declare const LlmAsJudgeOutputSchemaWriteType: {
    readonly Boolean: "BOOLEAN";
    readonly Integer: "INTEGER";
    readonly Double: "DOUBLE";
};
type LlmAsJudgeOutputSchemaWriteType = (typeof LlmAsJudgeOutputSchemaWriteType)[keyof typeof LlmAsJudgeOutputSchemaWriteType];

interface LogItem {
    timestamp?: Date;
    ruleId?: string;
    level?: LogItemLevel;
    message?: string;
    markers?: Record<string, string>;
}

declare const LogItemLevel: {
    readonly Info: "INFO";
    readonly Warn: "WARN";
    readonly Error: "ERROR";
    readonly Debug: "DEBUG";
    readonly Trace: "TRACE";
};
type LogItemLevel = (typeof LogItemLevel)[keyof typeof LogItemLevel];

interface LogPage {
    content?: LogItem[];
    page?: number;
    size?: number;
    total?: number;
}

interface ManualEvaluationRequest {
    /** Project ID */
    projectId: string;
    /** List of entity IDs (trace IDs or thread IDs) to evaluate */
    entityIds: string[];
    /** List of automation rule IDs to apply */
    ruleIds: string[];
    /** Type of entity to evaluate (trace or thread) */
    entityType: ManualEvaluationRequestEntityType;
}

/** Type of entity to evaluate (trace or thread) */
declare const ManualEvaluationRequestEntityType: {
    readonly Trace: "trace";
    readonly Thread: "thread";
    readonly Span: "span";
};
type ManualEvaluationRequestEntityType = (typeof ManualEvaluationRequestEntityType)[keyof typeof ManualEvaluationRequestEntityType];

interface ManualEvaluationResponse {
    /** Number of entities queued for evaluation */
    entitiesQueued?: number;
    /** Number of rules that will be applied */
    rulesApplied?: number;
}

type Message = Record<string, unknown>;

interface MultipartUploadPart {
    eTag: string;
    partNumber: number;
}

interface NumericalFeedbackDefinitionCreate {
    details?: NumericalFeedbackDetailCreate;
}

interface NumericalFeedbackDefinitionPublic {
    details?: NumericalFeedbackDetailPublic;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

interface NumericalFeedbackDefinitionUpdate {
    details?: NumericalFeedbackDetailUpdate;
}

interface NumericalFeedbackDetailCreate {
    max: number;
    min: number;
}

interface NumericalFeedbackDetailPublic {
    max: number;
    min: number;
}

interface NumericalFeedbackDetailUpdate {
    max: number;
    min: number;
}

/**
 * Response from Ollama connection test.
 */
interface OllamaConnectionTestResponse {
    /** Whether the connection was successful */
    connected?: boolean;
    /** Server version (returned even if connection failed or version is incompatible) */
    version?: string;
    /** Error message if connection failed */
    errorMessage?: string;
}

/**
 * Request with Ollama instance base URL for connection testing or model discovery.
 */
interface OllamaInstanceBaseUrlRequest {
    /** Base URL of the Ollama instance. May include /v1 suffix which will be automatically removed for connection testing. For inference, use the URL with /v1 suffix for OpenAI-compatible endpoints. */
    baseUrl: string;
    /** Optional API key for authenticated Ollama instances. If provided, will be sent as Bearer token in Authorization header. */
    apiKey?: string;
}

/**
 * Ollama model information
 */
interface OllamaModel {
    /** Model name */
    name: string;
    /** Model size in bytes */
    size?: number;
    /** Model digest/hash */
    digest?: string;
    /** Model modification date */
    modifiedAt?: Date;
}

interface OptimizationPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: OptimizationPublic[];
    sortableBy?: string[];
}

interface OptimizationPublic {
    id?: string;
    name?: string;
    datasetName: string;
    objectiveName: string;
    status: OptimizationPublicStatus;
    metadata?: JsonListStringPublic;
    studioConfig?: OptimizationStudioConfigPublic;
    datasetId?: string;
    numTrials?: number;
    feedbackScores?: FeedbackScoreAveragePublic[];
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

declare const OptimizationPublicStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
    readonly Initialized: "initialized";
    readonly Error: "error";
};
type OptimizationPublicStatus = (typeof OptimizationPublicStatus)[keyof typeof OptimizationPublicStatus];

interface OptimizationStudioConfigPublic {
    datasetName: string;
    prompt: StudioPromptPublic;
    llmModel: StudioLlmModelPublic;
    evaluation: StudioEvaluationPublic;
    optimizer: StudioOptimizerPublic;
}

interface OptimizationStudioConfigWrite {
    datasetName: string;
    prompt: StudioPromptWrite;
    llmModel: StudioLlmModelWrite;
    evaluation: StudioEvaluationWrite;
    optimizer: StudioOptimizerWrite;
}

interface OptimizationStudioLog {
    url?: string;
    lastModified?: Date;
    expiresAt?: Date;
}

interface OptimizationWrite {
    id?: string;
    name?: string;
    datasetName: string;
    objectiveName: string;
    status: OptimizationWriteStatus;
    metadata?: JsonListStringWrite;
    studioConfig?: OptimizationStudioConfigWrite;
    lastUpdatedAt?: Date;
}

declare const OptimizationWriteStatus: {
    readonly Running: "running";
    readonly Completed: "completed";
    readonly Cancelled: "cancelled";
    readonly Initialized: "initialized";
    readonly Error: "error";
};
type OptimizationWriteStatus = (typeof OptimizationWriteStatus)[keyof typeof OptimizationWriteStatus];

interface PageColumns {
    columns?: Column[];
}

interface PercentageValueStatPublic {
    value?: PercentageValuesPublic;
}

interface PercentageValues {
    p50?: number;
    p90?: number;
    p99?: number;
}

interface PercentageValuesDetailed {
    p50?: number;
    p90?: number;
    p99?: number;
}

interface PercentageValuesPublic {
    p50?: number;
    p90?: number;
    p99?: number;
}

interface ProjectDetailed {
    id?: string;
    name: string;
    visibility?: ProjectDetailedVisibility;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    lastUpdatedTraceAt?: Date;
    feedbackScores?: FeedbackScoreAverageDetailed[];
    duration?: PercentageValuesDetailed;
    totalEstimatedCost?: number;
    totalEstimatedCostSum?: number;
    usage?: Record<string, number>;
    traceCount?: number;
    threadCount?: number;
    guardrailsFailedCount?: number;
    errorCount?: ErrorCountWithDeviationDetailed;
}

declare const ProjectDetailedVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type ProjectDetailedVisibility = (typeof ProjectDetailedVisibility)[keyof typeof ProjectDetailedVisibility];

interface ProjectMetricResponsePublic {
    projectId?: string;
    metricType?: ProjectMetricResponsePublicMetricType;
    interval?: ProjectMetricResponsePublicInterval;
    results?: ResultsNumberPublic[];
}

declare const ProjectMetricResponsePublicInterval: {
    readonly Hourly: "HOURLY";
    readonly Daily: "DAILY";
    readonly Weekly: "WEEKLY";
};
type ProjectMetricResponsePublicInterval = (typeof ProjectMetricResponsePublicInterval)[keyof typeof ProjectMetricResponsePublicInterval];

declare const ProjectMetricResponsePublicMetricType: {
    readonly FeedbackScores: "FEEDBACK_SCORES";
    readonly TraceCount: "TRACE_COUNT";
    readonly TokenUsage: "TOKEN_USAGE";
    readonly Duration: "DURATION";
    readonly Cost: "COST";
    readonly GuardrailsFailedCount: "GUARDRAILS_FAILED_COUNT";
    readonly ThreadCount: "THREAD_COUNT";
    readonly ThreadDuration: "THREAD_DURATION";
    readonly ThreadFeedbackScores: "THREAD_FEEDBACK_SCORES";
    readonly SpanFeedbackScores: "SPAN_FEEDBACK_SCORES";
    readonly SpanCount: "SPAN_COUNT";
    readonly SpanDuration: "SPAN_DURATION";
    readonly SpanTokenUsage: "SPAN_TOKEN_USAGE";
};
type ProjectMetricResponsePublicMetricType = (typeof ProjectMetricResponsePublicMetricType)[keyof typeof ProjectMetricResponsePublicMetricType];

interface ProjectPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: ProjectPublic[];
    sortableBy?: string[];
}

interface ProjectPublic {
    id?: string;
    name: string;
    visibility?: ProjectPublicVisibility;
    description?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    lastUpdatedTraceAt?: Date;
}

declare const ProjectPublicVisibility: {
    readonly Private: "private";
    readonly Public: "public";
};
type ProjectPublicVisibility = (typeof ProjectPublicVisibility)[keyof typeof ProjectPublicVisibility];

/**
 * Project reference with ID and name
 */
interface ProjectReferencePublic {
    /** Project ID */
    projectId: string;
    /** Project name */
    projectName: string;
}

type ProjectStatItemObjectPublic = ProjectStatItemObjectPublic.Percentage | ProjectStatItemObjectPublic.Count | ProjectStatItemObjectPublic.Avg;
declare namespace ProjectStatItemObjectPublic {
    interface Percentage extends PercentageValueStatPublic, _Base {
        type: "PERCENTAGE";
    }
    interface Count extends CountValueStatPublic, _Base {
        type: "COUNT";
    }
    interface Avg extends AvgValueStatPublic, _Base {
        type: "AVG";
    }
    interface _Base {
        name?: string;
    }
}

interface ProjectStatsPublic {
    stats?: ProjectStatItemObjectPublic[];
}

interface ProjectStatsSummary {
    content?: ProjectStatsSummaryItem[];
}

interface ProjectStatsSummaryItem {
    projectId?: string;
    feedbackScores?: FeedbackScoreAverage[];
    duration?: PercentageValues;
    totalEstimatedCost?: number;
    totalEstimatedCostSum?: number;
    usage?: Record<string, number>;
    traceCount?: number;
    threadCount?: number;
    guardrailsFailedCount?: number;
    errorCount?: ErrorCountWithDeviation;
}

interface PromptDetail {
    id?: string;
    name: string;
    description?: string;
    /** Template structure type: 'text' or 'chat'. Immutable after creation. */
    templateStructure?: PromptDetailTemplateStructure;
    tags?: string[];
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    versionCount?: number;
    latestVersion?: PromptVersionDetail;
}

/** Template structure type: 'text' or 'chat'. Immutable after creation. */
declare const PromptDetailTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type PromptDetailTemplateStructure = (typeof PromptDetailTemplateStructure)[keyof typeof PromptDetailTemplateStructure];

interface PromptPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: PromptPublic[];
    sortableBy?: string[];
}

interface PromptPublic {
    id?: string;
    name: string;
    description?: string;
    /** Template structure type: 'text' or 'chat'. Immutable after creation. */
    templateStructure?: PromptPublicTemplateStructure;
    tags?: string[];
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    versionCount?: number;
}

/** Template structure type: 'text' or 'chat'. Immutable after creation. */
declare const PromptPublicTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type PromptPublicTemplateStructure = (typeof PromptPublicTemplateStructure)[keyof typeof PromptPublicTemplateStructure];

interface PromptTokensDetails {
    cachedTokens?: number;
}

interface PromptVersionDetail {
    /** version unique identifier, generated if absent */
    id?: string;
    promptId?: string;
    /** version short unique identifier, generated if absent. it must be 8 characters long */
    commit?: string;
    template: string;
    metadata?: JsonNodeDetail;
    type?: PromptVersionDetailType;
    changeDescription?: string;
    tags?: string[];
    variables?: string[];
    templateStructure?: PromptVersionDetailTemplateStructure;
    createdAt?: Date;
    createdBy?: string;
}

declare const PromptVersionDetailTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type PromptVersionDetailTemplateStructure = (typeof PromptVersionDetailTemplateStructure)[keyof typeof PromptVersionDetailTemplateStructure];

declare const PromptVersionDetailType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};
type PromptVersionDetailType = (typeof PromptVersionDetailType)[keyof typeof PromptVersionDetailType];

interface PromptVersionLinkPublic {
    id: string;
    commit?: string;
    promptId?: string;
    promptName?: string;
}

interface PromptVersionLinkWrite {
    id: string;
}

interface PromptVersionPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: PromptVersionPublic[];
    sortableBy?: string[];
}

interface PromptVersionPublic {
    /** version unique identifier, generated if absent */
    id?: string;
    promptId?: string;
    /** version short unique identifier, generated if absent. it must be 8 characters long */
    commit?: string;
    template: string;
    metadata?: JsonNodePublic;
    type?: PromptVersionPublicType;
    changeDescription?: string;
    tags?: string[];
    templateStructure?: PromptVersionPublicTemplateStructure;
    createdAt?: Date;
    createdBy?: string;
}

declare const PromptVersionPublicTemplateStructure: {
    readonly Text: "text";
    readonly Chat: "chat";
};
type PromptVersionPublicTemplateStructure = (typeof PromptVersionPublicTemplateStructure)[keyof typeof PromptVersionPublicTemplateStructure];

declare const PromptVersionPublicType: {
    readonly Mustache: "mustache";
    readonly Jinja2: "jinja2";
};
type PromptVersionPublicType = (typeof PromptVersionPublicType)[keyof typeof PromptVersionPublicType];

/**
 * Update to apply to prompt versions.
 * Note: Prompt versions are immutable by design.
 * Only organizational properties (such as tags etc.) can be updated.
 * Core properties like template, metadata etc. cannot be modified after creation.
 */
interface PromptVersionUpdate {
    /**
     * Tags to set or merge with existing tags. Follows PATCH semantics:
     * - If merge_tags is true, these tags will be added to existing tags.
     * - If merge_tags is false, these tags will replace all existing tags.
     * - null: preserve existing tags (no change).
     * - empty set: clear all tags merge_tags is false.
     */
    tags?: string[];
}

interface ProviderApiKeyPagePublic {
    size?: number;
    total?: number;
    content?: ProviderApiKeyPublic[];
    sortableBy?: string[];
}

interface ProviderApiKeyPublic {
    id?: string;
    provider: ProviderApiKeyPublicProvider;
    apiKey?: string;
    name?: string;
    /** Provider name - required for custom LLM and Bedrock providers to uniquely identify them (e.g., 'ollama', 'vllm', 'Bedrock us-east-1'). Must not be blank for custom and Bedrock providers. Should not be set for standard providers (OpenAI, Anthropic, etc.). This requirement is conditional and validation is enforced programmatically. */
    providerName?: string;
    headers?: Record<string, string>;
    configuration?: Record<string, string>;
    baseUrl?: string;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    /** If true, this provider is system-managed and cannot be edited or deleted */
    readOnly?: boolean;
}

declare const ProviderApiKeyPublicProvider: {
    readonly Openai: "openai";
    readonly Anthropic: "anthropic";
    readonly Gemini: "gemini";
    readonly Openrouter: "openrouter";
    readonly VertexAi: "vertex-ai";
    readonly Bedrock: "bedrock";
    readonly Ollama: "ollama";
    readonly CustomLlm: "custom-llm";
    readonly OpikFree: "opik-free";
};
type ProviderApiKeyPublicProvider = (typeof ProviderApiKeyPublicProvider)[keyof typeof ProviderApiKeyPublicProvider];

interface ResponseFormat {
    type?: ResponseFormatType;
    jsonSchema?: JsonSchema;
}

declare const ResponseFormatType: {
    readonly Text: "text";
    readonly JsonObject: "json_object";
    readonly JsonSchema: "json_schema";
};
type ResponseFormatType = (typeof ResponseFormatType)[keyof typeof ResponseFormatType];

interface Result {
    name?: string;
    current?: number;
    previous?: number;
}

interface ResultsNumberPublic {
    name?: string;
    data?: DataPointNumberPublic[];
}

interface ScoreName {
    name?: string;
    type?: string;
}

interface ServiceTogglesConfig {
    pythonEvaluatorEnabled: boolean;
    traceThreadPythonEvaluatorEnabled: boolean;
    spanLlmAsJudgeEnabled: boolean;
    spanUserDefinedMetricPythonEnabled: boolean;
    guardrailsEnabled: boolean;
    opikAiEnabled: boolean;
    alertsEnabled: boolean;
    welcomeWizardEnabled: boolean;
    csvUploadEnabled: boolean;
    exportEnabled: boolean;
    optimizationStudioEnabled: boolean;
    datasetVersioningEnabled: boolean;
    datasetExportEnabled: boolean;
    openaiProviderEnabled: boolean;
    anthropicProviderEnabled: boolean;
    geminiProviderEnabled: boolean;
    openrouterProviderEnabled: boolean;
    vertexaiProviderEnabled: boolean;
    bedrockProviderEnabled: boolean;
    customllmProviderEnabled: boolean;
    ollamaProviderEnabled: boolean;
    collaboratorsTabEnabled: boolean;
}

interface Span$1 {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    traceId?: string;
    parentSpanId?: string;
    name?: string;
    type?: SpanType;
    startTime: Date;
    endTime?: Date;
    input?: JsonListString;
    output?: JsonListString;
    metadata?: JsonListString;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfo;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScore[];
    comments?: Comment[];
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
}

/**
 * Options for enriching span data
 */
interface SpanEnrichmentOptions {
    includeTags?: boolean;
    includeFeedbackScores?: boolean;
    includeComments?: boolean;
    includeUsage?: boolean;
    includeMetadata?: boolean;
}

interface SpanExperimentItemBulkWriteView {
    id?: string;
    parentSpanId?: string;
    name?: string;
    type?: SpanExperimentItemBulkWriteViewType;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringExperimentItemBulkWriteView;
    output?: JsonListStringExperimentItemBulkWriteView;
    metadata?: JsonListStringExperimentItemBulkWriteView;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfoExperimentItemBulkWriteView;
    lastUpdatedAt?: Date;
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
}

declare const SpanExperimentItemBulkWriteViewType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanExperimentItemBulkWriteViewType = (typeof SpanExperimentItemBulkWriteViewType)[keyof typeof SpanExperimentItemBulkWriteViewType];

interface SpanFilter {
    field?: string;
    operator?: SpanFilterOperator;
    key?: string;
    value?: string;
}

declare const SpanFilterOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type SpanFilterOperator = (typeof SpanFilterOperator)[keyof typeof SpanFilterOperator];

interface SpanFilterPublic {
    field?: string;
    operator?: SpanFilterPublicOperator;
    key?: string;
    value?: string;
}

declare const SpanFilterPublicOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type SpanFilterPublicOperator = (typeof SpanFilterPublicOperator)[keyof typeof SpanFilterPublicOperator];

interface SpanFilterWrite {
    field?: string;
    operator?: SpanFilterWriteOperator;
    key?: string;
    value?: string;
}

declare const SpanFilterWriteOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type SpanFilterWriteOperator = (typeof SpanFilterWriteOperator)[keyof typeof SpanFilterWriteOperator];

interface SpanLlmAsJudgeCode {
    model: LlmAsJudgeModelParameters;
    messages: LlmAsJudgeMessage[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchema[];
}

interface SpanLlmAsJudgeCodePublic {
    model: LlmAsJudgeModelParametersPublic;
    messages: LlmAsJudgeMessagePublic[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchemaPublic[];
}

interface SpanLlmAsJudgeCodeWrite {
    model: LlmAsJudgeModelParametersWrite;
    messages: LlmAsJudgeMessageWrite[];
    variables: Record<string, string>;
    schema: LlmAsJudgeOutputSchemaWrite[];
}

interface SpanPagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: SpanPublic[];
    sortableBy?: string[];
}

interface SpanPublic {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    traceId?: string;
    parentSpanId?: string;
    name?: string;
    type?: SpanPublicType;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringPublic;
    output?: JsonListStringPublic;
    metadata?: JsonListStringPublic;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfoPublic;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScorePublic[];
    comments?: CommentPublic[];
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
}

declare const SpanPublicType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanPublicType = (typeof SpanPublicType)[keyof typeof SpanPublicType];

interface SpansCountResponse {
    workspacesSpansCount?: WorkspaceSpansCount[];
}

declare const SpanType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanType = (typeof SpanType)[keyof typeof SpanType];

interface SpanUpdate$1 {
    /** If null and project_id not specified, Default Project is assumed */
    projectName?: string;
    /** If null and project_name not specified, Default Project is assumed */
    projectId?: string;
    traceId: string;
    parentSpanId?: string;
    name?: string;
    type?: SpanUpdateType;
    endTime?: Date;
    input?: JsonListString;
    output?: JsonListString;
    metadata?: JsonListString;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    totalEstimatedCost?: number;
    errorInfo?: ErrorInfo;
}

declare const SpanUpdateType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanUpdateType = (typeof SpanUpdateType)[keyof typeof SpanUpdateType];

interface SpanUserDefinedMetricPythonCode {
    metric: string;
    arguments: Record<string, string>;
}

interface SpanUserDefinedMetricPythonCodePublic {
    metric: string;
    arguments: Record<string, string>;
}

interface SpanUserDefinedMetricPythonCodeWrite {
    metric: string;
    arguments: Record<string, string>;
}

interface SpanWrite {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    traceId?: string;
    parentSpanId?: string;
    name?: string;
    type?: SpanWriteType;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringWrite;
    output?: JsonListStringWrite;
    metadata?: JsonListStringWrite;
    model?: string;
    provider?: string;
    tags?: string[];
    usage?: Record<string, number>;
    errorInfo?: ErrorInfoWrite;
    lastUpdatedAt?: Date;
    totalEstimatedCost?: number;
    totalEstimatedCostVersion?: string;
}

declare const SpanWriteType: {
    readonly General: "general";
    readonly Tool: "tool";
    readonly Llm: "llm";
    readonly Guardrail: "guardrail";
};
type SpanWriteType = (typeof SpanWriteType)[keyof typeof SpanWriteType];

interface StartMultipartUploadResponse {
    uploadId: string;
    preSignUrls: string[];
}

interface StreamOptions {
    includeUsage?: boolean;
}

interface StudioEvaluationPublic {
    metrics: StudioMetricPublic[];
}

interface StudioEvaluationWrite {
    metrics: StudioMetricWrite[];
}

interface StudioLlmModelPublic {
    model: string;
    parameters?: JsonNodePublic;
}

interface StudioLlmModelWrite {
    model: string;
    parameters?: JsonNodeWrite;
}

interface StudioMessagePublic {
    role: string;
    content: string;
}

interface StudioMessageWrite {
    role: string;
    content: string;
}

interface StudioMetricPublic {
    type: string;
    parameters?: JsonNodePublic;
}

interface StudioMetricWrite {
    type: string;
    parameters?: JsonNodeWrite;
}

interface StudioOptimizerPublic {
    type: string;
    parameters?: JsonNodePublic;
}

interface StudioOptimizerWrite {
    type: string;
    parameters?: JsonNodeWrite;
}

interface StudioPromptPublic {
    messages: StudioMessagePublic[];
}

interface StudioPromptWrite {
    messages: StudioMessageWrite[];
}

interface TokenUsageNames {
    names?: string[];
}

interface Tool {
    type?: ToolType;
    function?: Function$1;
}

interface ToolCall {
    id?: string;
    index?: number;
    type?: ToolCallType;
    function?: FunctionCall;
}

declare const ToolCallType: {
    readonly Function: "function";
};
type ToolCallType = (typeof ToolCallType)[keyof typeof ToolCallType];

declare const ToolType: {
    readonly Function: "function";
};
type ToolType = (typeof ToolType)[keyof typeof ToolType];

interface Trace$1 {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    projectId?: string;
    name?: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonListString;
    output?: JsonListString;
    metadata?: JsonListString;
    tags?: string[];
    errorInfo?: ErrorInfo;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScore[];
    /** Aggregated feedback scores from all spans in this trace, averaged by score name */
    spanFeedbackScores?: FeedbackScore[];
    comments?: Comment[];
    guardrailsValidations?: GuardrailsValidation[];
    totalEstimatedCost?: number;
    spanCount?: number;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
    threadId?: string;
    visibilityMode?: TraceVisibilityMode;
    llmSpanCount?: number;
    hasToolSpans?: boolean;
    /** List of unique provider names from all spans in this trace, sorted alphabetically */
    providers?: string[];
    experiment?: ExperimentItemReference;
}

interface TraceCountResponse {
    workspacesTracesCount?: WorkspaceTraceCount[];
}

/**
 * Options for enriching trace data
 */
interface TraceEnrichmentOptions {
    includeSpans?: boolean;
    includeTags?: boolean;
    includeFeedbackScores?: boolean;
    includeComments?: boolean;
    includeUsage?: boolean;
    includeMetadata?: boolean;
}

/**
 * Please provide either none, only one of evaluate_task_result or trace, but never both
 */
interface TraceExperimentItemBulkWriteView {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    name?: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringExperimentItemBulkWriteView;
    output?: JsonListStringExperimentItemBulkWriteView;
    metadata?: JsonListStringExperimentItemBulkWriteView;
    tags?: string[];
    errorInfo?: ErrorInfoExperimentItemBulkWriteView;
    lastUpdatedAt?: Date;
    threadId?: string;
}

interface TraceFilter {
    field?: string;
    operator?: TraceFilterOperator;
    key?: string;
    value?: string;
}

declare const TraceFilterOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceFilterOperator = (typeof TraceFilterOperator)[keyof typeof TraceFilterOperator];

interface TraceFilterPublic {
    field?: string;
    operator?: TraceFilterPublicOperator;
    key?: string;
    value?: string;
}

declare const TraceFilterPublicOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceFilterPublicOperator = (typeof TraceFilterPublicOperator)[keyof typeof TraceFilterPublicOperator];

interface TraceFilterWrite {
    field?: string;
    operator?: TraceFilterWriteOperator;
    key?: string;
    value?: string;
}

declare const TraceFilterWriteOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceFilterWriteOperator = (typeof TraceFilterWriteOperator)[keyof typeof TraceFilterWriteOperator];

interface TracePagePublic {
    page?: number;
    size?: number;
    total?: number;
    content?: TracePublic[];
    sortableBy?: string[];
}

interface TracePublic {
    id?: string;
    projectId?: string;
    name?: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringPublic;
    output?: JsonListStringPublic;
    metadata?: JsonListStringPublic;
    tags?: string[];
    errorInfo?: ErrorInfoPublic;
    usage?: Record<string, number>;
    createdAt?: Date;
    lastUpdatedAt?: Date;
    createdBy?: string;
    lastUpdatedBy?: string;
    feedbackScores?: FeedbackScorePublic[];
    /** Aggregated feedback scores from all spans in this trace, averaged by score name */
    spanFeedbackScores?: FeedbackScorePublic[];
    comments?: CommentPublic[];
    guardrailsValidations?: GuardrailsValidationPublic[];
    totalEstimatedCost?: number;
    spanCount?: number;
    /** Duration in milliseconds as a decimal number to support sub-millisecond precision */
    duration?: number;
    threadId?: string;
    visibilityMode?: TracePublicVisibilityMode;
    llmSpanCount?: number;
    hasToolSpans?: boolean;
    /** List of unique provider names from all spans in this trace, sorted alphabetically */
    providers?: string[];
    experiment?: ExperimentItemReferencePublic;
}

declare const TracePublicVisibilityMode: {
    readonly Default: "default";
    readonly Hidden: "hidden";
};
type TracePublicVisibilityMode = (typeof TracePublicVisibilityMode)[keyof typeof TracePublicVisibilityMode];

interface TraceThread {
    id?: string;
    projectId?: string;
    threadModelId?: string;
    startTime?: Date;
    endTime?: Date;
    duration?: number;
    firstMessage?: JsonListString;
    lastMessage?: JsonListString;
    feedbackScores?: FeedbackScore[];
    status?: TraceThreadStatus;
    numberOfMessages?: number;
    totalEstimatedCost?: number;
    usage?: Record<string, number>;
    comments?: Comment[];
    tags?: string[];
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
    createdBy?: string;
    createdAt?: Date;
}

interface TraceThreadFilter {
    field?: string;
    operator?: TraceThreadFilterOperator;
    key?: string;
    value?: string;
}

declare const TraceThreadFilterOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceThreadFilterOperator = (typeof TraceThreadFilterOperator)[keyof typeof TraceThreadFilterOperator];

interface TraceThreadFilterPublic {
    field?: string;
    operator?: TraceThreadFilterPublicOperator;
    key?: string;
    value?: string;
}

declare const TraceThreadFilterPublicOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceThreadFilterPublicOperator = (typeof TraceThreadFilterPublicOperator)[keyof typeof TraceThreadFilterPublicOperator];

interface TraceThreadFilterWrite {
    field?: string;
    operator?: TraceThreadFilterWriteOperator;
    key?: string;
    value?: string;
}

declare const TraceThreadFilterWriteOperator: {
    readonly Contains: "contains";
    readonly NotContains: "not_contains";
    readonly StartsWith: "starts_with";
    readonly EndsWith: "ends_with";
    readonly EqualTo: "=";
    readonly NotEquals: "!=";
    readonly GreaterThan: ">";
    readonly GreaterThanOrEqualTo: ">=";
    readonly LessThan: "<";
    readonly LessThanOrEqualTo: "<=";
    readonly IsEmpty: "is_empty";
    readonly IsNotEmpty: "is_not_empty";
};
type TraceThreadFilterWriteOperator = (typeof TraceThreadFilterWriteOperator)[keyof typeof TraceThreadFilterWriteOperator];

interface TraceThreadIdentifier {
    projectName?: string;
    projectId?: string;
    threadId: string;
    truncate?: boolean;
}

interface TraceThreadLlmAsJudgeCode {
    model: LlmAsJudgeModelParameters;
    messages: LlmAsJudgeMessage[];
    schema: LlmAsJudgeOutputSchema[];
}

interface TraceThreadLlmAsJudgeCodePublic {
    model: LlmAsJudgeModelParametersPublic;
    messages: LlmAsJudgeMessagePublic[];
    schema: LlmAsJudgeOutputSchemaPublic[];
}

interface TraceThreadLlmAsJudgeCodeWrite {
    model: LlmAsJudgeModelParametersWrite;
    messages: LlmAsJudgeMessageWrite[];
    schema: LlmAsJudgeOutputSchemaWrite[];
}

interface TraceThreadPage {
    page?: number;
    size?: number;
    total?: number;
    content?: TraceThread[];
    sortableBy?: string[];
}

declare const TraceThreadStatus: {
    readonly Active: "active";
    readonly Inactive: "inactive";
};
type TraceThreadStatus = (typeof TraceThreadStatus)[keyof typeof TraceThreadStatus];

interface TraceThreadUpdate {
    tags?: string[];
}

interface TraceThreadUserDefinedMetricPythonCode {
    metric: string;
}

interface TraceThreadUserDefinedMetricPythonCodePublic {
    metric: string;
}

interface TraceThreadUserDefinedMetricPythonCodeWrite {
    metric: string;
}

interface TraceUpdate {
    /** If null and project_id not specified, Default Project is assumed */
    projectName?: string;
    /** If null and project_name not specified, Default Project is assumed */
    projectId?: string;
    name?: string;
    endTime?: Date;
    input?: JsonListString;
    output?: JsonListString;
    metadata?: JsonListString;
    tags?: string[];
    errorInfo?: ErrorInfo;
    threadId?: string;
}

declare const TraceVisibilityMode: {
    readonly Default: "default";
    readonly Hidden: "hidden";
};
type TraceVisibilityMode = (typeof TraceVisibilityMode)[keyof typeof TraceVisibilityMode];

interface TraceWrite {
    id?: string;
    /** If null, the default project is used */
    projectName?: string;
    name?: string;
    startTime: Date;
    endTime?: Date;
    input?: JsonListStringWrite;
    output?: JsonListStringWrite;
    metadata?: JsonListStringWrite;
    tags?: string[];
    errorInfo?: ErrorInfoWrite;
    lastUpdatedAt?: Date;
    threadId?: string;
}

interface Usage {
    totalTokens?: number;
    promptTokens?: number;
    promptTokensDetails?: PromptTokensDetails;
    completionTokens?: number;
    completionTokensDetails?: CompletionTokensDetails;
}

interface UserDefinedMetricPythonCode {
    metric: string;
    arguments: Record<string, string>;
}

interface UserDefinedMetricPythonCodePublic {
    metric: string;
    arguments: Record<string, string>;
}

interface UserDefinedMetricPythonCodeWrite {
    metric: string;
    arguments: Record<string, string>;
}

interface ValueEntry {
    value?: number;
    reason?: string;
    categoryName?: string;
    source?: ValueEntrySource;
    lastUpdatedAt?: Date;
    spanType?: string;
    spanId?: string;
}

interface ValueEntryCompare {
    value?: number;
    reason?: string;
    categoryName?: string;
    source?: ValueEntryCompareSource;
    lastUpdatedAt?: Date;
    spanType?: string;
    spanId?: string;
}

declare const ValueEntryCompareSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type ValueEntryCompareSource = (typeof ValueEntryCompareSource)[keyof typeof ValueEntryCompareSource];

interface ValueEntryExperimentItemBulkWriteView {
    value?: number;
    reason?: string;
    categoryName?: string;
    source?: ValueEntryExperimentItemBulkWriteViewSource;
    lastUpdatedAt?: Date;
    spanType?: string;
    spanId?: string;
}

declare const ValueEntryExperimentItemBulkWriteViewSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type ValueEntryExperimentItemBulkWriteViewSource = (typeof ValueEntryExperimentItemBulkWriteViewSource)[keyof typeof ValueEntryExperimentItemBulkWriteViewSource];

interface ValueEntryPublic {
    value?: number;
    reason?: string;
    categoryName?: string;
    source?: ValueEntryPublicSource;
    lastUpdatedAt?: Date;
    spanType?: string;
    spanId?: string;
}

declare const ValueEntryPublicSource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type ValueEntryPublicSource = (typeof ValueEntryPublicSource)[keyof typeof ValueEntryPublicSource];

declare const ValueEntrySource: {
    readonly Ui: "ui";
    readonly Sdk: "sdk";
    readonly OnlineScoring: "online_scoring";
};
type ValueEntrySource = (typeof ValueEntrySource)[keyof typeof ValueEntrySource];

interface VideoUrl {
    url: string;
}

interface VideoUrlPublic {
    url: string;
}

interface VideoUrlWrite {
    url: string;
}

interface WebhookExamples {
    responseExamples?: Record<string, Record<string, unknown>>;
}

interface WebhookPublic {
    id?: string;
    name?: string;
    url: string;
    secretToken?: string;
    headers?: Record<string, string>;
    createdAt?: Date;
    createdBy?: string;
    lastUpdatedAt?: Date;
    lastUpdatedBy?: string;
}

interface WebhookTestResult {
    status?: WebhookTestResultStatus;
    statusCode?: number;
    requestBody?: string;
    errorMessage?: string;
}

declare const WebhookTestResultStatus: {
    readonly Success: "success";
    readonly Failure: "failure";
};
type WebhookTestResultStatus = (typeof WebhookTestResultStatus)[keyof typeof WebhookTestResultStatus];

interface WebhookWrite {
    id?: string;
    name?: string;
    url: string;
    secretToken?: string;
    headers?: Record<string, string>;
}

interface WelcomeWizardTracking {
    /** Whether the welcome wizard has been completed */
    completed?: boolean;
}

interface WorkspaceConfiguration {
    /** Duration in ISO-8601 format (e.g., PT30M for 30 minutes, PT2H for 2 hours, P1D for 1 day). Minimum precision supported is seconds, please use a duration with seconds precision or higher. Also, the max duration allowed is 7 days. */
    timeoutToMarkThreadAsInactive?: string;
    /** Enable or disable data truncation in table views. When disabled, the frontend will limit pagination to prevent performance issues. Default: true (truncation enabled). */
    truncationOnTables?: boolean;
}

interface WorkspaceMetricResponse {
    results?: Result[];
}

interface WorkspaceMetricsSummaryRequest {
    projectIds?: string[];
    intervalStart: Date;
    intervalEnd: Date;
    startBeforeEnd?: boolean;
}

interface WorkspaceMetricsSummaryResponse {
    results?: Result[];
}

interface WorkspaceNameHolder {
    workspaceName?: string;
}

interface WorkspaceSpansCount {
    workspace?: string;
    spanCount?: number;
}

interface WorkspaceTraceCount {
    workspace?: string;
    traceCount?: number;
}

declare const OpikApiEnvironment: {
    readonly Default: "http://localhost:5173/api";
};
type OpikApiEnvironment = typeof OpikApiEnvironment.Default;

interface BaseClientOptions {
    environment?: Supplier<OpikApiEnvironment | string>;
    /** Specify a custom URL to connect the client to. */
    baseUrl?: Supplier<string>;
    /** Override the Authorization header */
    apiKey?: Supplier<string | undefined>;
    /** Override the Comet-Workspace header */
    workspaceName?: Supplier<string | undefined>;
    /** Additional headers to include in requests. */
    headers?: Record<string, string | Supplier<string | null | undefined> | null | undefined>;
    /** The default maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The default number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** Provide a custom fetch implementation. Useful for platforms that don't have a built-in fetch or need a custom implementation. */
    fetch?: typeof fetch;
    /** Configure logging for the client. */
    logging?: LogConfig | Logger;
}
interface BaseRequestOptions {
    /** The maximum time to wait for a response in seconds. */
    timeoutInSeconds?: number;
    /** The number of times to retry the request. Defaults to 2. */
    maxRetries?: number;
    /** A hook to abort the request. */
    abortSignal?: AbortSignal;
    /** Override the Authorization header */
    apiKey?: string | undefined;
    /** Override the Comet-Workspace header */
    workspaceName?: string | undefined;
    /** Additional query string parameters to include in the request. */
    queryParams?: Record<string, unknown>;
    /** Additional headers to include in the request. */
    headers?: Record<string, string | Supplier<string | null | undefined> | null | undefined>;
}
type NormalizedClientOptions<T extends BaseClientOptions = BaseClientOptions> = T & {
    logging: Logger;
};

declare namespace AlertsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Alert resources
 */
declare class AlertsClient {
    protected readonly _options: NormalizedClientOptions<AlertsClient.Options>;
    constructor(options?: AlertsClient.Options);
    /**
     * Find alerts
     *
     * @param {OpikApi.FindAlertsRequest} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alerts.findAlerts()
     */
    findAlerts(request?: FindAlertsRequest, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<AlertPagePublic>;
    private __findAlerts;
    /**
     * Create alert
     *
     * @param {OpikApi.AlertWrite} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.alerts.createAlert({
     *         webhook: {
     *             url: "url"
     *         }
     *     })
     */
    createAlert(request: AlertWrite, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<void>;
    private __createAlert;
    /**
     * Delete multiple alerts by their IDs
     *
     * @param {OpikApi.BatchDelete} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.alerts.deleteAlertBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteAlertBatch(request: BatchDelete, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteAlertBatch;
    /**
     * Get Alert by id
     *
     * @param {string} id
     * @param {OpikApi.GetAlertByIdRequest} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.alerts.getAlertById("id")
     */
    getAlertById(id: string, request?: GetAlertByIdRequest, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<AlertPublic>;
    private __getAlertById;
    /**
     * Update alert
     *
     * @param {string} id
     * @param {OpikApi.UpdateAlertRequest} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.alerts.updateAlert("id", {
     *         body: {
     *             webhook: {
     *                 url: "url"
     *             }
     *         }
     *     })
     */
    updateAlert(id: string, request: UpdateAlertRequest, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateAlert;
    /**
     * Get webhook payload examples for all alert event types, optionally filtered by alert type
     *
     * @param {OpikApi.GetWebhookExamplesRequest} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.alerts.getWebhookExamples()
     */
    getWebhookExamples(request?: GetWebhookExamplesRequest, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<WebhookExamples>;
    private __getWebhookExamples;
    /**
     * Test alert webhook
     *
     * @param {OpikApi.AlertWrite} request
     * @param {AlertsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.alerts.testWebhook({
     *         webhook: {
     *             url: "url"
     *         }
     *     })
     */
    testWebhook(request: AlertWrite, requestOptions?: AlertsClient.RequestOptions): HttpResponsePromise<WebhookTestResult>;
    private __testWebhook;
}

declare namespace AnnotationQueuesClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Private annotation queue operations
 */
declare class AnnotationQueuesClient {
    protected readonly _options: NormalizedClientOptions<AnnotationQueuesClient.Options>;
    constructor(options?: AnnotationQueuesClient.Options);
    /**
     * Add traces or threads to annotation queue
     *
     * @param {string} id
     * @param {OpikApi.AddItemsToAnnotationQueueRequest} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.annotationQueues.addItemsToAnnotationQueue("id", {
     *         body: {
     *             ids: ["ids"]
     *         }
     *     })
     */
    addItemsToAnnotationQueue(id: string, request: AddItemsToAnnotationQueueRequest, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __addItemsToAnnotationQueue;
    /**
     * Find annotation queues with filtering and sorting
     *
     * @param {OpikApi.FindAnnotationQueuesRequest} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.annotationQueues.findAnnotationQueues()
     */
    findAnnotationQueues(request?: FindAnnotationQueuesRequest, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<AnnotationQueuePagePublic>;
    private __findAnnotationQueues;
    /**
     * Create annotation queue for human annotation workflows
     *
     * @param {OpikApi.AnnotationQueueWrite} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.annotationQueues.createAnnotationQueue({
     *         projectId: "project_id",
     *         name: "name",
     *         scope: "trace"
     *     })
     */
    createAnnotationQueue(request: AnnotationQueueWrite, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __createAnnotationQueue;
    /**
     * Create multiple annotation queues for human annotation workflows
     *
     * @param {OpikApi.AnnotationQueueBatchWrite} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.annotationQueues.createAnnotationQueueBatch({
     *         annotationQueues: [{
     *                 projectId: "project_id",
     *                 name: "name",
     *                 scope: "trace"
     *             }]
     *     })
     */
    createAnnotationQueueBatch(request: AnnotationQueueBatchWrite, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __createAnnotationQueueBatch;
    /**
     * Delete multiple annotation queues by their IDs
     *
     * @param {OpikApi.BatchDelete} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.annotationQueues.deleteAnnotationQueueBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteAnnotationQueueBatch(request: BatchDelete, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteAnnotationQueueBatch;
    /**
     * Get annotation queue by id
     *
     * @param {string} id
     * @param {OpikApi.GetAnnotationQueueByIdRequest} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.annotationQueues.getAnnotationQueueById("id")
     */
    getAnnotationQueueById(id: string, request?: GetAnnotationQueueByIdRequest, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<AnnotationQueuePublic>;
    private __getAnnotationQueueById;
    /**
     * Update annotation queue by id
     *
     * @param {string} id
     * @param {OpikApi.AnnotationQueueUpdate} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.annotationQueues.updateAnnotationQueue("id")
     */
    updateAnnotationQueue(id: string, request?: AnnotationQueueUpdate, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __updateAnnotationQueue;
    /**
     * Remove items from annotation queue
     *
     * @param {string} id
     * @param {OpikApi.RemoveItemsFromAnnotationQueueRequest} request
     * @param {AnnotationQueuesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.annotationQueues.removeItemsFromAnnotationQueue("id", {
     *         body: {
     *             ids: ["ids"]
     *         }
     *     })
     */
    removeItemsFromAnnotationQueue(id: string, request: RemoveItemsFromAnnotationQueueRequest, requestOptions?: AnnotationQueuesClient.RequestOptions): HttpResponsePromise<void>;
    private __removeItemsFromAnnotationQueue;
}

declare namespace AttachmentsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Attachments related resources
 */
declare class AttachmentsClient {
    protected readonly _options: NormalizedClientOptions<AttachmentsClient.Options>;
    constructor(options?: AttachmentsClient.Options);
    /**
     * Attachments list for entity
     *
     * @param {OpikApi.AttachmentListRequest} request
     * @param {AttachmentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.attachments.attachmentList({
     *         projectId: "project_id",
     *         entityType: "trace",
     *         entityId: "entity_id",
     *         path: "path"
     *     })
     */
    attachmentList(request: AttachmentListRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<AttachmentPage>;
    private __attachmentList;
    /**
     * Complete multipart attachment upload
     *
     * @param {OpikApi.CompleteMultipartUploadRequest} request
     * @param {AttachmentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.attachments.completeMultiPartUpload({
     *         fileName: "file_name",
     *         entityType: "trace",
     *         entityId: "entity_id",
     *         fileSize: 1000000,
     *         uploadId: "upload_id",
     *         uploadedFileParts: [{
     *                 eTag: "e_tag",
     *                 partNumber: 1
     *             }]
     *     })
     */
    completeMultiPartUpload(request: CompleteMultipartUploadRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<void>;
    private __completeMultiPartUpload;
    /**
     * Delete attachments
     *
     * @param {OpikApi.CompleteMultipartUploadRequest} request
     * @param {AttachmentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.attachments.deleteAttachments({
     *         fileName: "file_name",
     *         entityType: "trace",
     *         entityId: "entity_id",
     *         fileSize: 1000000,
     *         uploadId: "upload_id",
     *         uploadedFileParts: [{
     *                 eTag: "e_tag",
     *                 partNumber: 1
     *             }]
     *     })
     */
    deleteAttachments(request: CompleteMultipartUploadRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteAttachments;
    /**
     * Download attachment from MinIO
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     */
    downloadAttachment(request: DownloadAttachmentRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __downloadAttachment;
    /**
     * Start multipart attachment upload
     *
     * @param {OpikApi.StartMultipartUploadRequest} request
     * @param {AttachmentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.attachments.startMultiPartUpload({
     *         fileName: "file_name",
     *         numOfFileParts: 1,
     *         entityType: "trace",
     *         entityId: "entity_id",
     *         path: "path"
     *     })
     */
    startMultiPartUpload(request: StartMultipartUploadRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<StartMultipartUploadResponse>;
    private __startMultiPartUpload;
    /**
     * Upload attachment to MinIO
     *
     * @param {OpikApi.UploadAttachmentRequest} request
     * @param {AttachmentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.attachments.uploadAttachment({
     *         fileName: "file_name",
     *         entityType: "trace",
     *         entityId: "entity_id",
     *         body: {
     *             "key": "value"
     *         }
     *     })
     */
    uploadAttachment(request: UploadAttachmentRequest, requestOptions?: AttachmentsClient.RequestOptions): HttpResponsePromise<void>;
    private __uploadAttachment;
}

declare namespace AutomationRuleEvaluatorsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Automation rule evaluators resource
 */
declare class AutomationRuleEvaluatorsClient {
    protected readonly _options: NormalizedClientOptions<AutomationRuleEvaluatorsClient.Options>;
    constructor(options?: AutomationRuleEvaluatorsClient.Options);
    /**
     * Find project Evaluators
     *
     * @param {OpikApi.FindEvaluatorsRequest} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.findEvaluators()
     */
    findEvaluators(request?: FindEvaluatorsRequest, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<AutomationRuleEvaluatorPagePublic>;
    private __findEvaluators;
    /**
     * Create automation rule evaluator
     *
     * @param {OpikApi.AutomationRuleEvaluatorWrite} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.createAutomationRuleEvaluator({
     *         type: "llm_as_judge",
     *         name: "string",
     *         action: "evaluator"
     *     })
     */
    createAutomationRuleEvaluator(request: AutomationRuleEvaluatorWrite, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<void>;
    private __createAutomationRuleEvaluator;
    /**
     * Delete automation rule evaluators batch
     *
     * @param {OpikApi.DeleteAutomationRuleEvaluatorBatchRequest} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.deleteAutomationRuleEvaluatorBatch({
     *         body: {
     *             ids: ["ids"]
     *         }
     *     })
     */
    deleteAutomationRuleEvaluatorBatch(request: DeleteAutomationRuleEvaluatorBatchRequest, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteAutomationRuleEvaluatorBatch;
    /**
     * Get automation rule by id
     *
     * @param {string} id
     * @param {OpikApi.GetEvaluatorByIdRequest} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorById("id")
     */
    getEvaluatorById(id: string, request?: GetEvaluatorByIdRequest, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<AutomationRuleEvaluatorPublic>;
    private __getEvaluatorById;
    /**
     * Update Automation Rule Evaluator by id
     *
     * @param {string} id
     * @param {OpikApi.UpdateAutomationRuleEvaluatorRequest} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.updateAutomationRuleEvaluator("id", {
     *         body: {
     *             type: "llm_as_judge",
     *             name: "string",
     *             action: "evaluator"
     *         }
     *     })
     */
    updateAutomationRuleEvaluator(id: string, request: UpdateAutomationRuleEvaluatorRequest, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateAutomationRuleEvaluator;
    /**
     * Get automation rule evaluator logs by id
     *
     * @param {string} id
     * @param {OpikApi.GetEvaluatorLogsByIdRequest} request
     * @param {AutomationRuleEvaluatorsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.automationRuleEvaluators.getEvaluatorLogsById("id")
     */
    getEvaluatorLogsById(id: string, request?: GetEvaluatorLogsByIdRequest, requestOptions?: AutomationRuleEvaluatorsClient.RequestOptions): HttpResponsePromise<LogPage>;
    private __getEvaluatorLogsById;
}

declare namespace ChatCompletionsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Chat Completions related resources
 */
declare class ChatCompletionsClient {
    protected readonly _options: NormalizedClientOptions<ChatCompletionsClient.Options>;
    constructor(options?: ChatCompletionsClient.Options);
    /**
     * Create chat completions
     *
     * @param {OpikApi.ChatCompletionRequest} request
     * @param {ChatCompletionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.chatCompletions.createChatCompletions()
     */
    createChatCompletions(request?: ChatCompletionRequest, requestOptions?: ChatCompletionsClient.RequestOptions): HttpResponsePromise<ChatCompletionResponse>;
    private __createChatCompletions;
}

declare namespace CheckClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Access check resources
 */
declare class CheckClient {
    protected readonly _options: NormalizedClientOptions<CheckClient.Options>;
    constructor(options?: CheckClient.Options);
    /**
     * Check user access to workspace
     *
     * @param {OpikApi.AuthDetailsHolder} request
     * @param {CheckClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.check.access({
     *         "key": "value"
     *     })
     */
    access(request: AuthDetailsHolder, requestOptions?: CheckClient.RequestOptions): HttpResponsePromise<void>;
    private __access;
    /**
     * User's default workspace name
     *
     * @param {CheckClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.check.getWorkspaceName()
     */
    getWorkspaceName(requestOptions?: CheckClient.RequestOptions): HttpResponsePromise<WorkspaceNameHolder>;
    private __getWorkspaceName;
}

declare namespace DashboardsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Workspace Dashboard resources
 */
declare class DashboardsClient {
    protected readonly _options: NormalizedClientOptions<DashboardsClient.Options>;
    constructor(options?: DashboardsClient.Options);
    /**
     * Find dashboards in a workspace
     *
     * @param {OpikApi.FindDashboardsRequest} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dashboards.findDashboards()
     */
    findDashboards(request?: FindDashboardsRequest, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<DashboardPagePublic>;
    private __findDashboards;
    /**
     * Create a new dashboard in a workspace
     *
     * @param {OpikApi.DashboardWrite} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dashboards.createDashboard({
     *         name: "name",
     *         config: {
     *             "key": "value"
     *         }
     *     })
     */
    createDashboard(request: DashboardWrite, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<DashboardPublic>;
    private __createDashboard;
    /**
     * Get dashboard by id
     *
     * @param {string} dashboardId
     * @param {OpikApi.GetDashboardByIdRequest} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.dashboards.getDashboardById("dashboardId")
     */
    getDashboardById(dashboardId: string, request?: GetDashboardByIdRequest, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<DashboardPublic>;
    private __getDashboardById;
    /**
     * Delete dashboard by id
     *
     * @param {string} dashboardId
     * @param {OpikApi.DeleteDashboardRequest} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dashboards.deleteDashboard("dashboardId")
     */
    deleteDashboard(dashboardId: string, request?: DeleteDashboardRequest, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDashboard;
    /**
     * Update dashboard by id. Partial updates are supported - only provided fields will be updated.
     *
     * @param {string} dashboardId
     * @param {OpikApi.DashboardUpdatePublic} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.dashboards.updateDashboard("dashboardId")
     */
    updateDashboard(dashboardId: string, request?: DashboardUpdatePublic, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<DashboardPublic>;
    private __updateDashboard;
    /**
     * Delete dashboards batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {DashboardsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dashboards.deleteDashboardsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteDashboardsBatch(request: BatchDelete, requestOptions?: DashboardsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDashboardsBatch;
}

declare namespace DatasetsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Dataset resources
 */
declare class DatasetsClient {
    protected readonly _options: NormalizedClientOptions<DatasetsClient.Options>;
    constructor(options?: DatasetsClient.Options);
    /**
     * Apply delta changes (add, edit, delete) to a dataset version with conflict detection.
     *
     * This endpoint:
     * - Creates a new version with the applied changes
     * - Validates that baseVersion matches the latest version (unless override=true)
     * - Returns 409 Conflict if baseVersion is stale and override is not set
     *
     * Use `override=true` query parameter to force version creation even with stale baseVersion.
     *
     * @param {string} id
     * @param {OpikApi.ApplyDatasetItemChangesRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.applyDatasetItemChanges("id", {
     *         body: {
     *             "key": "value"
     *         }
     *     })
     */
    applyDatasetItemChanges(id: string, request: ApplyDatasetItemChangesRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionPublic>;
    private __applyDatasetItemChanges;
    /**
     * Update multiple dataset items
     *
     * @param {OpikApi.DatasetItemBatchUpdate} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.batchUpdateDatasetItems({
     *         update: {}
     *     })
     */
    batchUpdateDatasetItems(request: DatasetItemBatchUpdate, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __batchUpdateDatasetItems;
    /**
     * Find datasets
     *
     * @param {OpikApi.FindDatasetsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasets()
     */
    findDatasets(request?: FindDatasetsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetPagePublic>;
    private __findDatasets;
    /**
     * Create dataset
     *
     * @param {OpikApi.DatasetWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDataset({
     *         name: "name"
     *     })
     */
    createDataset(request: DatasetWrite, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createDataset;
    /**
     * Create/update dataset items based on dataset item id
     *
     * @param {OpikApi.DatasetItemBatchWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createOrUpdateDatasetItems({
     *         items: [{
     *                 source: "manual",
     *                 data: {
     *                     "key": "value"
     *                 }
     *             }]
     *     })
     */
    createOrUpdateDatasetItems(request: DatasetItemBatchWrite, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createOrUpdateDatasetItems;
    /**
     * Create dataset items from uploaded CSV file. CSV should have headers in the first row. Processing happens asynchronously in batches.
     *
     * @param {OpikApi.CreateDatasetItemsFromCsvRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.datasets.createDatasetItemsFromCsv({
     *         file: {
     *             "key": "value"
     *         },
     *         datasetId: "dataset_id"
     *     })
     */
    createDatasetItemsFromCsv(request: CreateDatasetItemsFromCsvRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createDatasetItemsFromCsv;
    /**
     * Create dataset items from spans with enriched metadata
     *
     * @param {string} dataset_id
     * @param {OpikApi.CreateDatasetItemsFromSpansRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDatasetItemsFromSpans("dataset_id", {
     *         spanIds: ["span_ids"],
     *         enrichmentOptions: {}
     *     })
     */
    createDatasetItemsFromSpans(dataset_id: string, request: CreateDatasetItemsFromSpansRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createDatasetItemsFromSpans;
    /**
     * Create dataset items from traces with enriched metadata
     *
     * @param {string} dataset_id
     * @param {OpikApi.CreateDatasetItemsFromTracesRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.createDatasetItemsFromTraces("dataset_id", {
     *         traceIds: ["trace_ids"],
     *         enrichmentOptions: {}
     *     })
     */
    createDatasetItemsFromTraces(dataset_id: string, request: CreateDatasetItemsFromTracesRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createDatasetItemsFromTraces;
    /**
     * Get dataset by id
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetByIdRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetById("id")
     */
    getDatasetById(id: string, request?: GetDatasetByIdRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetPublic>;
    private __getDatasetById;
    /**
     * Update dataset by id
     *
     * @param {string} id
     * @param {OpikApi.DatasetUpdate} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.updateDataset("id", {
     *         name: "name"
     *     })
     */
    updateDataset(id: string, request: DatasetUpdate, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateDataset;
    /**
     * Delete dataset by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteDatasetRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDataset("id")
     */
    deleteDataset(id: string, request?: DeleteDatasetRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDataset;
    /**
     * Delete dataset by name
     *
     * @param {OpikApi.DatasetIdentifier} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetByName({
     *         datasetName: "dataset_name"
     *     })
     */
    deleteDatasetByName(request: DatasetIdentifier, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDatasetByName;
    /**
     * Delete dataset items using one of two modes:
     * 1. **Delete by IDs**: Provide 'item_ids' to delete specific items by their IDs
     * 2. **Delete by filters**: Provide 'dataset_id' with optional 'filters' to delete items matching criteria
     *
     * When using filters, an empty 'filters' array will delete all items in the specified dataset.
     *
     * @param {OpikApi.DatasetItemsDelete} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.deleteDatasetItems()
     */
    deleteDatasetItems(request?: DatasetItemsDelete, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDatasetItems;
    /**
     * Delete datasets batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteDatasetsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteDatasetsBatch(request: BatchDelete, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteDatasetsBatch;
    /**
     * Downloads the exported CSV file for a completed export job. This endpoint proxies the file download to avoid exposing internal storage URLs.
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     */
    downloadDatasetExport(jobId: string, request?: DownloadDatasetExportRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __downloadDatasetExport;
    /**
     * Generate synthetic dataset samples using LLM based on existing data patterns
     *
     * @param {string} id
     * @param {OpikApi.DatasetExpansionWrite} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.expandDataset("id", {
     *         model: "gpt-4"
     *     })
     */
    expandDataset(id: string, request: DatasetExpansionWrite, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetExpansionResponse>;
    private __expandDataset;
    /**
     * Find dataset items with experiment items
     *
     * @param {string} id
     * @param {OpikApi.FindDatasetItemsWithExperimentItemsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.findDatasetItemsWithExperimentItems("id", {
     *         experimentIds: "experiment_ids"
     *     })
     */
    findDatasetItemsWithExperimentItems(id: string, request: FindDatasetItemsWithExperimentItemsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetItemPageCompare>;
    private __findDatasetItemsWithExperimentItems;
    /**
     * Get dataset by name
     *
     * @param {OpikApi.DatasetIdentifierPublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetByIdentifier({
     *         datasetName: "dataset_name"
     *     })
     */
    getDatasetByIdentifier(request: DatasetIdentifierPublic, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetPublic>;
    private __getDatasetByIdentifier;
    /**
     * Get experiment items stats for dataset
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetExperimentItemsStatsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetExperimentItemsStats("id", {
     *         experimentIds: "experiment_ids"
     *     })
     */
    getDatasetExperimentItemsStats(id: string, request: GetDatasetExperimentItemsStatsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<ProjectStatsPublic>;
    private __getDatasetExperimentItemsStats;
    /**
     * Retrieves the current status of a dataset export job
     *
     * @param {string} jobId
     * @param {OpikApi.GetDatasetExportJobRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.getDatasetExportJob("jobId")
     */
    getDatasetExportJob(jobId: string, request?: GetDatasetExportJobRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetExportJobPublic>;
    private __getDatasetExportJob;
    /**
     * Retrieves all export jobs for the workspace. This is used to restore the export panel state after page refresh.
     *
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetExportJobs()
     */
    getDatasetExportJobs(requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetExportJobPublic[]>;
    private __getDatasetExportJobs;
    /**
     * Get dataset item by id
     *
     * @param {string} itemId
     * @param {OpikApi.GetDatasetItemByIdRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemById("itemId")
     */
    getDatasetItemById(itemId: string, request?: GetDatasetItemByIdRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetItemPublic>;
    private __getDatasetItemById;
    /**
     * Partially update dataset item by id. Only provided fields will be updated.
     *
     * @param {string} itemId
     * @param {OpikApi.PatchDatasetItemRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.patchDatasetItem("itemId", {
     *         body: {
     *             source: "manual",
     *             data: {
     *                 "key": "value"
     *             }
     *         }
     *     })
     */
    patchDatasetItem(itemId: string, request: PatchDatasetItemRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __patchDatasetItem;
    /**
     * Get dataset items
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItems("id")
     */
    getDatasetItems(id: string, request?: GetDatasetItemsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetItemPagePublic>;
    private __getDatasetItems;
    /**
     * Get dataset items output columns
     *
     * @param {string} id
     * @param {OpikApi.GetDatasetItemsOutputColumnsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.getDatasetItemsOutputColumns("id")
     */
    getDatasetItemsOutputColumns(id: string, request?: GetDatasetItemsOutputColumnsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<PageColumns>;
    private __getDatasetItemsOutputColumns;
    /**
     * Marks a dataset export job as viewed by setting the viewed_at timestamp. This is used to track that a user has seen a failed job's error message. This operation is idempotent.
     *
     * @param {string} jobId
     * @param {OpikApi.MarkDatasetExportJobViewedRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.markDatasetExportJobViewed("jobId")
     */
    markDatasetExportJobViewed(jobId: string, request?: MarkDatasetExportJobViewedRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __markDatasetExportJobViewed;
    /**
     * Initiates an asynchronous CSV export job for the dataset. Returns immediately with job details for polling.
     *
     * @param {string} id
     * @param {OpikApi.StartDatasetExportRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.startDatasetExport("id")
     */
    startDatasetExport(id: string, request?: StartDatasetExportRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetExportJobPublic>;
    private __startDatasetExport;
    /**
     * Stream dataset items
     */
    streamDatasetItems(request: DatasetItemStreamRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __streamDatasetItems;
    /**
     * Compare the latest committed dataset version with the current draft state. This endpoint provides insights into changes made since the last version was committed. The comparison calculates additions, modifications, deletions, and unchanged items between the latest version snapshot and current draft.
     *
     * @param {string} id
     * @param {OpikApi.CompareDatasetVersionsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.compareDatasetVersions("id")
     */
    compareDatasetVersions(id: string, request?: CompareDatasetVersionsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionDiff>;
    private __compareDatasetVersions;
    /**
     * Add a tag to a specific dataset version for easy reference (e.g., 'baseline', 'v1.0', 'production')
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {OpikApi.DatasetVersionTag} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.createVersionTag("id", "versionHash", {
     *         tag: "tag"
     *     })
     */
    createVersionTag(id: string, versionHash: string, request: DatasetVersionTag, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __createVersionTag;
    /**
     * Remove a tag from a dataset version. The version itself is not deleted, only the tag reference.
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {string} tag
     * @param {OpikApi.DeleteVersionTagRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.datasets.deleteVersionTag("id", "versionHash", "tag")
     */
    deleteVersionTag(id: string, versionHash: string, tag: string, request?: DeleteVersionTagRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteVersionTag;
    /**
     * Get paginated list of versions for a dataset, ordered by creation time (newest first)
     *
     * @param {string} id
     * @param {OpikApi.ListDatasetVersionsRequest} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.datasets.listDatasetVersions("id")
     */
    listDatasetVersions(id: string, request?: ListDatasetVersionsRequest, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionPagePublic>;
    private __listDatasetVersions;
    /**
     * Restores the dataset to a previous version state by creating a new version with items copied from the specified version. If the version is already the latest, returns it as-is (no-op).
     *
     * @param {string} id
     * @param {OpikApi.DatasetVersionRestorePublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.restoreDatasetVersion("id", {
     *         versionRef: "version_ref"
     *     })
     */
    restoreDatasetVersion(id: string, request: DatasetVersionRestorePublic, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionPublic>;
    private __restoreDatasetVersion;
    /**
     * Get a specific version by its version name (e.g., 'v1', 'v373'). This is more efficient than paginating through all versions for large datasets.
     *
     * @param {string} id
     * @param {OpikApi.DatasetVersionRetrieveRequestPublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.datasets.retrieveDatasetVersion("id", {
     *         versionName: "v1"
     *     })
     */
    retrieveDatasetVersion(id: string, request: DatasetVersionRetrieveRequestPublic, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionPublic>;
    private __retrieveDatasetVersion;
    /**
     * Update a dataset version's change_description and/or add new tags
     *
     * @param {string} id
     * @param {string} versionHash
     * @param {OpikApi.DatasetVersionUpdatePublic} request
     * @param {DatasetsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.datasets.updateDatasetVersion("id", "versionHash")
     */
    updateDatasetVersion(id: string, versionHash: string, request?: DatasetVersionUpdatePublic, requestOptions?: DatasetsClient.RequestOptions): HttpResponsePromise<DatasetVersionPublic>;
    private __updateDatasetVersion;
}

declare namespace ExperimentsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Experiment resources
 */
declare class ExperimentsClient {
    protected readonly _options: NormalizedClientOptions<ExperimentsClient.Options>;
    constructor(options?: ExperimentsClient.Options);
    /**
     * Update multiple experiments
     *
     * @param {OpikApi.ExperimentBatchUpdate} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.experiments.batchUpdateExperiments({
     *         ids: ["ids"],
     *         update: {}
     *     })
     */
    batchUpdateExperiments(request: ExperimentBatchUpdate, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __batchUpdateExperiments;
    /**
     * Find experiments
     *
     * @param {OpikApi.FindExperimentsRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.experiments.findExperiments()
     */
    findExperiments(request?: FindExperimentsRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ExperimentPagePublic>;
    private __findExperiments;
    /**
     * Create experiment
     *
     * @param {OpikApi.ExperimentWrite} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.createExperiment({
     *         datasetName: "dataset_name"
     *     })
     */
    createExperiment(request: ExperimentWrite, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __createExperiment;
    /**
     * Create experiment items
     *
     * @param {OpikApi.ExperimentItemsBatch} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.createExperimentItems({
     *         experimentItems: [{
     *                 experimentId: "experiment_id",
     *                 datasetItemId: "dataset_item_id",
     *                 traceId: "trace_id"
     *             }]
     *     })
     */
    createExperimentItems(request: ExperimentItemsBatch, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __createExperimentItems;
    /**
     * Delete experiment items
     *
     * @param {OpikApi.ExperimentItemsDelete} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.deleteExperimentItems({
     *         ids: ["ids"]
     *     })
     */
    deleteExperimentItems(request: ExperimentItemsDelete, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteExperimentItems;
    /**
     * Delete experiments by id
     *
     * @param {OpikApi.DeleteIdsHolder} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.deleteExperimentsById({
     *         ids: ["ids"]
     *     })
     */
    deleteExperimentsById(request: DeleteIdsHolder, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteExperimentsById;
    /**
     * Record experiment items in bulk with traces, spans, and feedback scores. Maximum request size is 4MB.
     *
     * @param {OpikApi.ExperimentItemBulkUploadExperimentItemBulkWriteView} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.experiments.experimentItemsBulk({
     *         experimentName: "experiment_name",
     *         datasetName: "dataset_name",
     *         items: [{
     *                 datasetItemId: "dataset_item_id"
     *             }]
     *     })
     */
    experimentItemsBulk(request: ExperimentItemBulkUploadExperimentItemBulkWriteView, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __experimentItemsBulk;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNamesRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.experiments.findFeedbackScoreNames()
     */
    findFeedbackScoreNames(request?: FindFeedbackScoreNamesRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<string[]>;
    private __findFeedbackScoreNames;
    /**
     * Find experiments grouped by specified fields
     *
     * @param {OpikApi.FindExperimentGroupsRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.experiments.findExperimentGroups()
     */
    findExperimentGroups(request?: FindExperimentGroupsRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ExperimentGroupResponse>;
    private __findExperimentGroups;
    /**
     * Find experiments grouped by specified fields with aggregation metrics
     *
     * @param {OpikApi.FindExperimentGroupsAggregationsRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.experiments.findExperimentGroupsAggregations()
     */
    findExperimentGroupsAggregations(request?: FindExperimentGroupsAggregationsRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ExperimentGroupAggregationsResponse>;
    private __findExperimentGroupsAggregations;
    /**
     * Finish experiments and trigger alert events
     *
     * @param {OpikApi.DeleteIdsHolder} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.experiments.finishExperiments({
     *         ids: ["ids"]
     *     })
     */
    finishExperiments(request: DeleteIdsHolder, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __finishExperiments;
    /**
     * Get experiment by id
     *
     * @param {string} id
     * @param {OpikApi.GetExperimentByIdRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.getExperimentById("id")
     */
    getExperimentById(id: string, request?: GetExperimentByIdRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ExperimentPublic>;
    private __getExperimentById;
    /**
     * Update experiment by id
     *
     * @param {string} id
     * @param {OpikApi.UpdateExperimentRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.updateExperiment("id", {
     *         body: {}
     *     })
     */
    updateExperiment(id: string, request: UpdateExperimentRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateExperiment;
    /**
     * Get experiment item by id
     *
     * @param {string} id
     * @param {OpikApi.GetExperimentItemByIdRequest} request
     * @param {ExperimentsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.experiments.getExperimentItemById("id")
     */
    getExperimentItemById(id: string, request?: GetExperimentItemByIdRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ExperimentItemPublic>;
    private __getExperimentItemById;
    /**
     * Stream experiment items
     */
    streamExperimentItems(request: ExperimentItemStreamRequest, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __streamExperimentItems;
    /**
     * Stream experiments
     */
    streamExperiments(request: ExperimentStreamRequestPublic, requestOptions?: ExperimentsClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __streamExperiments;
}

declare namespace FeedbackDefinitionsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Feedback definitions related resources
 */
declare class FeedbackDefinitionsClient {
    protected readonly _options: NormalizedClientOptions<FeedbackDefinitionsClient.Options>;
    constructor(options?: FeedbackDefinitionsClient.Options);
    /**
     * Find Feedback definitions
     *
     * @param {OpikApi.FindFeedbackDefinitionsRequest} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.findFeedbackDefinitions()
     */
    findFeedbackDefinitions(request?: FindFeedbackDefinitionsRequest, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<FeedbackDefinitionPagePublic>;
    private __findFeedbackDefinitions;
    /**
     * Get feedback definition
     *
     * @param {OpikApi.FeedbackCreate} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.createFeedbackDefinition({
     *         type: "numerical",
     *         name: "string",
     *         description: "This feedback definition is used to rate response quality"
     *     })
     */
    createFeedbackDefinition(request: FeedbackCreate, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<void>;
    private __createFeedbackDefinition;
    /**
     * Get feedback definition by id
     *
     * @param {string} id
     * @param {OpikApi.GetFeedbackDefinitionByIdRequest} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.getFeedbackDefinitionById("id")
     */
    getFeedbackDefinitionById(id: string, request?: GetFeedbackDefinitionByIdRequest, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<FeedbackPublic>;
    private __getFeedbackDefinitionById;
    /**
     * Update feedback definition by id
     *
     * @param {string} id
     * @param {OpikApi.UpdateFeedbackDefinitionRequest} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.feedbackDefinitions.updateFeedbackDefinition("id", {
     *         body: {
     *             type: "numerical",
     *             name: "string",
     *             description: "This feedback definition is used to rate response quality"
     *         }
     *     })
     */
    updateFeedbackDefinition(id: string, request: UpdateFeedbackDefinitionRequest, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateFeedbackDefinition;
    /**
     * Delete feedback definition by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteFeedbackDefinitionByIdRequest} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.feedbackDefinitions.deleteFeedbackDefinitionById("id")
     */
    deleteFeedbackDefinitionById(id: string, request?: DeleteFeedbackDefinitionByIdRequest, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteFeedbackDefinitionById;
    /**
     * Delete feedback definitions batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {FeedbackDefinitionsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.feedbackDefinitions.deleteFeedbackDefinitionsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteFeedbackDefinitionsBatch(request: BatchDelete, requestOptions?: FeedbackDefinitionsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteFeedbackDefinitionsBatch;
}

declare namespace GuardrailsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Guardrails related resources
 */
declare class GuardrailsClient {
    protected readonly _options: NormalizedClientOptions<GuardrailsClient.Options>;
    constructor(options?: GuardrailsClient.Options);
    /**
     * Batch guardrails for traces
     *
     * @param {OpikApi.GuardrailBatchWrite} request
     * @param {GuardrailsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.guardrails.createGuardrails({
     *         guardrails: [{
     *                 entityId: "entity_id",
     *                 secondaryId: "secondary_id",
     *                 name: "TOPIC",
     *                 result: "passed",
     *                 config: {
     *                     "key": "value"
     *                 },
     *                 details: {
     *                     "key": "value"
     *                 }
     *             }]
     *     })
     */
    createGuardrails(request: GuardrailBatchWrite, requestOptions?: GuardrailsClient.RequestOptions): HttpResponsePromise<void>;
    private __createGuardrails;
}

declare namespace LlmProviderKeyClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * LLM Provider Key
 */
declare class LlmProviderKeyClient {
    protected readonly _options: NormalizedClientOptions<LlmProviderKeyClient.Options>;
    constructor(options?: LlmProviderKeyClient.Options);
    /**
     * Delete LLM Provider's ApiKeys batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {LlmProviderKeyClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.llmProviderKey.deleteLlmProviderApiKeysBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteLlmProviderApiKeysBatch(request: BatchDelete, requestOptions?: LlmProviderKeyClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteLlmProviderApiKeysBatch;
    /**
     * Find LLM Provider's ApiKeys
     *
     * @param {LlmProviderKeyClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.llmProviderKey.findLlmProviderKeys()
     */
    findLlmProviderKeys(requestOptions?: LlmProviderKeyClient.RequestOptions): HttpResponsePromise<ProviderApiKeyPagePublic>;
    private __findLlmProviderKeys;
    /**
     * Store LLM Provider's ApiKey
     *
     * @param {OpikApi.ProviderApiKeyWrite} request
     * @param {LlmProviderKeyClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     *
     * @example
     *     await client.llmProviderKey.storeLlmProviderApiKey({
     *         provider: "openai"
     *     })
     */
    storeLlmProviderApiKey(request: ProviderApiKeyWrite, requestOptions?: LlmProviderKeyClient.RequestOptions): HttpResponsePromise<void>;
    private __storeLlmProviderApiKey;
    /**
     * Get LLM Provider's ApiKey by id
     *
     * @param {string} id
     * @param {OpikApi.GetLlmProviderApiKeyByIdRequest} request
     * @param {LlmProviderKeyClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.llmProviderKey.getLlmProviderApiKeyById("id")
     */
    getLlmProviderApiKeyById(id: string, request?: GetLlmProviderApiKeyByIdRequest, requestOptions?: LlmProviderKeyClient.RequestOptions): HttpResponsePromise<ProviderApiKeyPublic>;
    private __getLlmProviderApiKeyById;
    /**
     * Update LLM Provider's ApiKey
     *
     * @param {string} id
     * @param {OpikApi.ProviderApiKeyUpdate} request
     * @param {LlmProviderKeyClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnauthorizedError}
     * @throws {@link OpikApi.ForbiddenError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.llmProviderKey.updateLlmProviderApiKey("id")
     */
    updateLlmProviderApiKey(id: string, request?: ProviderApiKeyUpdate, requestOptions?: LlmProviderKeyClient.RequestOptions): HttpResponsePromise<void>;
    private __updateLlmProviderApiKey;
}

declare namespace ManualEvaluationClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Manual evaluation resources for traces, threads, and spans
 */
declare class ManualEvaluationClient {
    protected readonly _options: NormalizedClientOptions<ManualEvaluationClient.Options>;
    constructor(options?: ManualEvaluationClient.Options);
    /**
     * Manually trigger evaluation rules on selected spans. Bypasses sampling and enqueues all specified spans for evaluation.
     *
     * @param {OpikApi.ManualEvaluationRequest} request
     * @param {ManualEvaluationClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.manualEvaluation.evaluateSpans({
     *         projectId: "550e8400-e29b-41d4-a716-446655440000",
     *         entityIds: ["550e8400-e29b-41d4-a716-446655440000", "550e8400-e29b-41d4-a716-446655440001"],
     *         ruleIds: ["660e8400-e29b-41d4-a716-446655440000"],
     *         entityType: "trace"
     *     })
     */
    evaluateSpans(request: ManualEvaluationRequest, requestOptions?: ManualEvaluationClient.RequestOptions): HttpResponsePromise<ManualEvaluationResponse>;
    private __evaluateSpans;
    /**
     * Manually trigger evaluation rules on selected threads. Bypasses sampling and enqueues all specified threads for evaluation.
     *
     * @param {OpikApi.ManualEvaluationRequest} request
     * @param {ManualEvaluationClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.manualEvaluation.evaluateThreads({
     *         projectId: "550e8400-e29b-41d4-a716-446655440000",
     *         entityIds: ["550e8400-e29b-41d4-a716-446655440000", "550e8400-e29b-41d4-a716-446655440001"],
     *         ruleIds: ["660e8400-e29b-41d4-a716-446655440000"],
     *         entityType: "trace"
     *     })
     */
    evaluateThreads(request: ManualEvaluationRequest, requestOptions?: ManualEvaluationClient.RequestOptions): HttpResponsePromise<ManualEvaluationResponse>;
    private __evaluateThreads;
    /**
     * Manually trigger evaluation rules on selected traces. Bypasses sampling and enqueues all specified traces for evaluation.
     *
     * @param {OpikApi.ManualEvaluationRequest} request
     * @param {ManualEvaluationClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.manualEvaluation.evaluateTraces({
     *         projectId: "550e8400-e29b-41d4-a716-446655440000",
     *         entityIds: ["550e8400-e29b-41d4-a716-446655440000", "550e8400-e29b-41d4-a716-446655440001"],
     *         ruleIds: ["660e8400-e29b-41d4-a716-446655440000"],
     *         entityType: "trace"
     *     })
     */
    evaluateTraces(request: ManualEvaluationRequest, requestOptions?: ManualEvaluationClient.RequestOptions): HttpResponsePromise<ManualEvaluationResponse>;
    private __evaluateTraces;
}

declare namespace OllamaClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Ollama provider configuration endpoints with OpenAI-compatible API support.
 */
declare class OllamaClient {
    protected readonly _options: NormalizedClientOptions<OllamaClient.Options>;
    constructor(options?: OllamaClient.Options);
    /**
     * Fetches the list of models available from the Ollama instance. URL may be provided with or without /v1 suffix (e.g., http://localhost:11434 or http://localhost:11434/v1). The /v1 suffix will be automatically removed for model discovery. For actual LLM inference, use the URL with /v1 suffix for OpenAI-compatible endpoints.
     *
     * @param {OpikApi.OllamaInstanceBaseUrlRequest} request
     * @param {OllamaClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnprocessableEntityError}
     * @throws {@link OpikApi.InternalServerError}
     * @throws {@link OpikApi.ServiceUnavailableError}
     *
     * @example
     *     await client.ollama.listModels({
     *         baseUrl: "http://localhost:11434/v1"
     *     })
     */
    listModels(request: OllamaInstanceBaseUrlRequest, requestOptions?: OllamaClient.RequestOptions): HttpResponsePromise<OllamaModel[]>;
    private __listModels;
    /**
     * Validates that the provided Ollama URL is reachable. URL may be provided with or without /v1 suffix (e.g., http://localhost:11434 or http://localhost:11434/v1). The /v1 suffix will be automatically removed for connection testing. For inference, use the URL with /v1 suffix.
     *
     * @param {OpikApi.OllamaInstanceBaseUrlRequest} request
     * @param {OllamaClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.UnprocessableEntityError}
     * @throws {@link OpikApi.BadGatewayError}
     * @throws {@link OpikApi.ServiceUnavailableError}
     *
     * @example
     *     await client.ollama.testConnection({
     *         baseUrl: "http://localhost:11434/v1"
     *     })
     */
    testConnection(request: OllamaInstanceBaseUrlRequest, requestOptions?: OllamaClient.RequestOptions): HttpResponsePromise<OllamaConnectionTestResponse>;
    private __testConnection;
}

declare namespace OpenTelemetryIngestionClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Resource to ingest Traces and Spans via OpenTelemetry
 */
declare class OpenTelemetryIngestionClient {
    protected readonly _options: NormalizedClientOptions<OpenTelemetryIngestionClient.Options>;
    constructor(options?: OpenTelemetryIngestionClient.Options);
    /**
     * @param {OpenTelemetryIngestionClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.openTelemetryIngestion.receiveProtobufTraces()
     */
    receiveProtobufTraces(requestOptions?: OpenTelemetryIngestionClient.RequestOptions): HttpResponsePromise<unknown>;
    private __receiveProtobufTraces;
}

declare namespace OptimizationsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Optimization resources
 */
declare class OptimizationsClient {
    protected readonly _options: NormalizedClientOptions<OptimizationsClient.Options>;
    constructor(options?: OptimizationsClient.Options);
    /**
     * Cancel Studio optimizations by id
     *
     * @param {string} id
     * @param {OpikApi.CancelStudioOptimizationsRequest} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotImplementedError}
     *
     * @example
     *     await client.optimizations.cancelStudioOptimizations("id")
     */
    cancelStudioOptimizations(id: string, request?: CancelStudioOptimizationsRequest, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<void>;
    private __cancelStudioOptimizations;
    /**
     * Find optimizations
     *
     * @param {OpikApi.FindOptimizationsRequest} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.optimizations.findOptimizations()
     */
    findOptimizations(request?: FindOptimizationsRequest, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<OptimizationPagePublic>;
    private __findOptimizations;
    /**
     * Create optimization
     *
     * @param {OpikApi.OptimizationWrite} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.optimizations.createOptimization({
     *         datasetName: "dataset_name",
     *         objectiveName: "objective_name",
     *         status: "running"
     *     })
     */
    createOptimization(request: OptimizationWrite, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<void>;
    private __createOptimization;
    /**
     * Upsert optimization
     *
     * @param {OpikApi.OptimizationWrite} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.optimizations.upsertOptimization({
     *         datasetName: "dataset_name",
     *         objectiveName: "objective_name",
     *         status: "running"
     *     })
     */
    upsertOptimization(request: OptimizationWrite, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<void>;
    private __upsertOptimization;
    /**
     * Delete optimizations by id
     *
     * @param {OpikApi.DeleteIdsHolder} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.optimizations.deleteOptimizationsById({
     *         ids: ["ids"]
     *     })
     */
    deleteOptimizationsById(request: DeleteIdsHolder, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteOptimizationsById;
    /**
     * Get optimization by id
     *
     * @param {string} id
     * @param {OpikApi.GetOptimizationByIdRequest} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.optimizations.getOptimizationById("id")
     */
    getOptimizationById(id: string, request?: GetOptimizationByIdRequest, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<OptimizationPublic>;
    private __getOptimizationById;
    /**
     * Update optimization by id
     *
     * @param {string} id
     * @param {OpikApi.OptimizationUpdate} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.optimizations.updateOptimizationsById("id")
     */
    updateOptimizationsById(id: string, request?: OptimizationUpdate, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateOptimizationsById;
    /**
     * Get presigned S3 URL for downloading optimization logs
     *
     * @param {string} id
     * @param {OpikApi.GetStudioOptimizationLogsRequest} request
     * @param {OptimizationsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.optimizations.getStudioOptimizationLogs("id")
     */
    getStudioOptimizationLogs(id: string, request?: GetStudioOptimizationLogsRequest, requestOptions?: OptimizationsClient.RequestOptions): HttpResponsePromise<OptimizationStudioLog>;
    private __getStudioOptimizationLogs;
}

declare namespace ProjectsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Project related resources
 */
declare class ProjectsClient {
    protected readonly _options: NormalizedClientOptions<ProjectsClient.Options>;
    constructor(options?: ProjectsClient.Options);
    /**
     * Find projects
     *
     * @param {OpikApi.FindProjectsRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.findProjects()
     */
    findProjects(request?: FindProjectsRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<ProjectPagePublic>;
    private __findProjects;
    /**
     * Create project
     *
     * @param {OpikApi.ProjectWrite} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.createProject({
     *         name: "name"
     *     })
     */
    createProject(request: ProjectWrite, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<void>;
    private __createProject;
    /**
     * Get project by id
     *
     * @param {string} id
     * @param {OpikApi.GetProjectByIdRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.getProjectById("id")
     */
    getProjectById(id: string, request?: GetProjectByIdRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<ProjectPublic>;
    private __getProjectById;
    /**
     * Delete project by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteProjectByIdRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.projects.deleteProjectById("id")
     */
    deleteProjectById(id: string, request?: DeleteProjectByIdRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteProjectById;
    /**
     * Update project by id
     *
     * @param {string} id
     * @param {OpikApi.ProjectUpdate} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.updateProject("id")
     */
    updateProject(id: string, request?: ProjectUpdate, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<void>;
    private __updateProject;
    /**
     * Delete projects batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.deleteProjectsBatch({
     *         ids: ["ids"]
     *     })
     */
    deleteProjectsBatch(request: BatchDelete, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteProjectsBatch;
    /**
     * Find Feedback Score names By Project Ids
     *
     * @param {OpikApi.FindFeedbackScoreNamesByProjectIdsRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.findFeedbackScoreNamesByProjectIds()
     */
    findFeedbackScoreNamesByProjectIds(request?: FindFeedbackScoreNamesByProjectIdsRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<FeedbackScoreNames>;
    private __findFeedbackScoreNamesByProjectIds;
    /**
     * Find Token Usage names
     *
     * @param {string} id
     * @param {OpikApi.FindTokenUsageNamesRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.findTokenUsageNames("id")
     */
    findTokenUsageNames(id: string, request?: FindTokenUsageNamesRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<TokenUsageNames>;
    private __findTokenUsageNames;
    /**
     * Gets specified metrics for a project
     *
     * @param {string} id
     * @param {OpikApi.ProjectMetricRequestPublic} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.projects.getProjectMetrics("id")
     */
    getProjectMetrics(id: string, request?: ProjectMetricRequestPublic, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<ProjectMetricResponsePublic>;
    private __getProjectMetrics;
    /**
     * Get Project Stats
     *
     * @param {OpikApi.GetProjectStatsRequest} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.projects.getProjectStats()
     */
    getProjectStats(request?: GetProjectStatsRequest, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<ProjectStatsSummary>;
    private __getProjectStats;
    /**
     * Retrieve project
     *
     * @param {OpikApi.ProjectRetrieveDetailed} request
     * @param {ProjectsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.projects.retrieveProject({
     *         name: "name"
     *     })
     */
    retrieveProject(request: ProjectRetrieveDetailed, requestOptions?: ProjectsClient.RequestOptions): HttpResponsePromise<ProjectDetailed>;
    private __retrieveProject;
}

declare namespace PromptsClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Prompt resources
 */
declare class PromptsClient {
    protected readonly _options: NormalizedClientOptions<PromptsClient.Options>;
    constructor(options?: PromptsClient.Options);
    /**
     * Get prompts
     *
     * @param {OpikApi.GetPromptsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.getPrompts()
     */
    getPrompts(request?: GetPromptsRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptPagePublic>;
    private __getPrompts;
    /**
     * Create prompt
     *
     * @param {OpikApi.PromptWrite} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.createPrompt({
     *         name: "name"
     *     })
     */
    createPrompt(request: PromptWrite, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<void>;
    private __createPrompt;
    /**
     * Create prompt version
     *
     * @param {OpikApi.CreatePromptVersionDetail} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.createPromptVersion({
     *         name: "name",
     *         version: {
     *             template: "template"
     *         }
     *     })
     */
    createPromptVersion(request: CreatePromptVersionDetail, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptVersionDetail>;
    private __createPromptVersion;
    /**
     * Update one or more prompt versions.
     *
     * Note: Prompt versions are immutable by design.
     * Only organizational properties, such as tags etc., can be updated.
     * Core properties like template and metadata cannot be modified after creation.
     *
     * PATCH semantics:
     * - non-empty values update the field
     * - null values preserve existing field values (no change)
     * - empty values explicitly clear the field
     *
     * @param {OpikApi.PromptVersionBatchUpdate} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.prompts.updatePromptVersions({
     *         ids: ["ids"],
     *         update: {}
     *     })
     */
    updatePromptVersions(request: PromptVersionBatchUpdate, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<void>;
    private __updatePromptVersions;
    /**
     * Get prompt by id
     *
     * @param {string} id
     * @param {OpikApi.GetPromptByIdRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.prompts.getPromptById("id")
     */
    getPromptById(id: string, request?: GetPromptByIdRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptDetail>;
    private __getPromptById;
    /**
     * Update prompt
     *
     * @param {string} id
     * @param {OpikApi.PromptUpdatable} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.ConflictError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.updatePrompt("id", {
     *         name: "name"
     *     })
     */
    updatePrompt(id: string, request: PromptUpdatable, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<void>;
    private __updatePrompt;
    /**
     * Delete prompt
     *
     * @param {string} id
     * @param {OpikApi.DeletePromptRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.deletePrompt("id")
     */
    deletePrompt(id: string, request?: DeletePromptRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<void>;
    private __deletePrompt;
    /**
     * Delete prompts batch
     *
     * @param {OpikApi.BatchDelete} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.deletePromptsBatch({
     *         ids: ["ids"]
     *     })
     */
    deletePromptsBatch(request: BatchDelete, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<void>;
    private __deletePromptsBatch;
    /**
     * Get prompt version by id
     *
     * @param {string} versionId
     * @param {OpikApi.GetPromptVersionByIdRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.prompts.getPromptVersionById("versionId")
     */
    getPromptVersionById(versionId: string, request?: GetPromptVersionByIdRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptVersionDetail>;
    private __getPromptVersionById;
    /**
     * Get prompt versions
     *
     * @param {string} id
     * @param {OpikApi.GetPromptVersionsRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.prompts.getPromptVersions("id")
     */
    getPromptVersions(id: string, request?: GetPromptVersionsRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptVersionPagePublic>;
    private __getPromptVersions;
    /**
     * Restore a prompt version by creating a new version with the content from the specified version
     *
     * @param {string} promptId
     * @param {string} versionId
     * @param {OpikApi.RestorePromptVersionRequest} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.prompts.restorePromptVersion("promptId", "versionId")
     */
    restorePromptVersion(promptId: string, versionId: string, request?: RestorePromptVersionRequest, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptVersionDetail>;
    private __restorePromptVersion;
    /**
     * Retrieve prompt version
     *
     * @param {OpikApi.PromptVersionRetrieveDetail} request
     * @param {PromptsClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.prompts.retrievePromptVersion({
     *         name: "name"
     *     })
     */
    retrievePromptVersion(request: PromptVersionRetrieveDetail, requestOptions?: PromptsClient.RequestOptions): HttpResponsePromise<PromptVersionDetail>;
    private __retrievePromptVersion;
}

declare namespace RedirectClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Redirects for SDK generated links
 */
declare class RedirectClient {
    protected readonly _options: NormalizedClientOptions<RedirectClient.Options>;
    constructor(options?: RedirectClient.Options);
    /**
     * Create dataset redirect url
     *
     * @param {OpikApi.DatasetsRedirectRequest} request
     * @param {RedirectClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.redirect.datasetsRedirect({
     *         datasetId: "dataset_id",
     *         path: "path"
     *     })
     */
    datasetsRedirect(request: DatasetsRedirectRequest, requestOptions?: RedirectClient.RequestOptions): HttpResponsePromise<void>;
    private __datasetsRedirect;
    /**
     * Create experiment redirect url
     *
     * @param {OpikApi.ExperimentsRedirectRequest} request
     * @param {RedirectClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.redirect.experimentsRedirect({
     *         datasetId: "dataset_id",
     *         experimentId: "experiment_id",
     *         path: "path"
     *     })
     */
    experimentsRedirect(request: ExperimentsRedirectRequest, requestOptions?: RedirectClient.RequestOptions): HttpResponsePromise<void>;
    private __experimentsRedirect;
    /**
     * Create optimization redirect url
     *
     * @param {OpikApi.OptimizationsRedirectRequest} request
     * @param {RedirectClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.redirect.optimizationsRedirect({
     *         datasetId: "dataset_id",
     *         optimizationId: "optimization_id",
     *         path: "path"
     *     })
     */
    optimizationsRedirect(request: OptimizationsRedirectRequest, requestOptions?: RedirectClient.RequestOptions): HttpResponsePromise<void>;
    private __optimizationsRedirect;
    /**
     * Create project redirect url
     *
     * @param {OpikApi.ProjectsRedirectRequest} request
     * @param {RedirectClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.redirect.projectsRedirect({
     *         traceId: "trace_id",
     *         path: "path"
     *     })
     */
    projectsRedirect(request: ProjectsRedirectRequest, requestOptions?: RedirectClient.RequestOptions): HttpResponsePromise<void>;
    private __projectsRedirect;
}

declare namespace ServiceTogglesClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Service Toggles resources
 */
declare class ServiceTogglesClient {
    protected readonly _options: NormalizedClientOptions<ServiceTogglesClient.Options>;
    constructor(options?: ServiceTogglesClient.Options);
    /**
     * Get Service Toggles
     *
     * @param {ServiceTogglesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.serviceToggles.getServiceToggles()
     */
    getServiceToggles(requestOptions?: ServiceTogglesClient.RequestOptions): HttpResponsePromise<ServiceTogglesConfig>;
    private __getServiceToggles;
}

declare namespace SpansClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Span related resources
 */
declare class SpansClient {
    protected readonly _options: NormalizedClientOptions<SpansClient.Options>;
    constructor(options?: SpansClient.Options);
    /**
     * Add span comment
     *
     * @param {string} id
     * @param {OpikApi.AddSpanCommentRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.addSpanComment("id", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    addSpanComment(id: string, request: AddSpanCommentRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __addSpanComment;
    /**
     * Add span feedback score
     *
     * @param {string} id
     * @param {OpikApi.AddSpanFeedbackScoreRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.addSpanFeedbackScore("id", {
     *         body: {
     *             name: "name",
     *             value: 1.1,
     *             source: "ui"
     *         }
     *     })
     */
    addSpanFeedbackScore(id: string, request: AddSpanFeedbackScoreRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __addSpanFeedbackScore;
    /**
     * Create spans
     *
     * @param {OpikApi.SpanBatchWrite} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.createSpans({
     *         spans: [{
     *                 startTime: new Date("2024-01-15T09:30:00.000Z")
     *             }]
     *     })
     */
    createSpans(request: SpanBatchWrite, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __createSpans;
    /**
     * Update multiple spans
     *
     * @param {OpikApi.SpanBatchUpdate} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.spans.batchUpdateSpans({
     *         ids: ["ids"],
     *         update: {
     *             traceId: "trace_id"
     *         }
     *     })
     */
    batchUpdateSpans(request: SpanBatchUpdate, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __batchUpdateSpans;
    /**
     * Get spans by project_name or project_id and optionally by trace_id and/or type
     *
     * @param {OpikApi.GetSpansByProjectRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.getSpansByProject()
     */
    getSpansByProject(request?: GetSpansByProjectRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<SpanPagePublic>;
    private __getSpansByProject;
    /**
     * Create span
     *
     * @param {OpikApi.SpanWrite} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.ConflictError}
     *
     * @example
     *     await client.spans.createSpan({
     *         startTime: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    createSpan(request: SpanWrite, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __createSpan;
    /**
     * Get span by id
     *
     * @param {string} id
     * @param {OpikApi.GetSpanByIdRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.getSpanById("id")
     */
    getSpanById(id: string, request?: GetSpanByIdRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<SpanPublic>;
    private __getSpanById;
    /**
     * Delete span by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteSpanByIdRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotImplementedError}
     *
     * @example
     *     await client.spans.deleteSpanById("id")
     */
    deleteSpanById(id: string, request?: DeleteSpanByIdRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteSpanById;
    /**
     * Update span by id
     *
     * @param {string} id
     * @param {OpikApi.UpdateSpanRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.updateSpan("id", {
     *         body: {
     *             traceId: "trace_id"
     *         }
     *     })
     */
    updateSpan(id: string, request: UpdateSpanRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __updateSpan;
    /**
     * Delete span comments
     *
     * @param {OpikApi.BatchDelete} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.deleteSpanComments({
     *         ids: ["ids"]
     *     })
     */
    deleteSpanComments(request: BatchDelete, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteSpanComments;
    /**
     * Delete span feedback score
     *
     * @param {string} id
     * @param {OpikApi.DeleteSpanFeedbackScoreRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.deleteSpanFeedbackScore("id", {
     *         body: {
     *             name: "name"
     *         }
     *     })
     */
    deleteSpanFeedbackScore(id: string, request: DeleteSpanFeedbackScoreRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteSpanFeedbackScore;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNames1Request} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.findFeedbackScoreNames1()
     */
    findFeedbackScoreNames1(request?: FindFeedbackScoreNames1Request, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<string[]>;
    private __findFeedbackScoreNames1;
    /**
     * Get span comment
     *
     * @param {string} spanId
     * @param {string} commentId
     * @param {OpikApi.GetSpanCommentRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.getSpanComment("spanId", "commentId")
     */
    getSpanComment(spanId: string, commentId: string, request?: GetSpanCommentRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<Comment>;
    private __getSpanComment;
    /**
     * Get span stats
     *
     * @param {OpikApi.GetSpanStatsRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.getSpanStats()
     */
    getSpanStats(request?: GetSpanStatsRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<ProjectStatsPublic>;
    private __getSpanStats;
    /**
     * Batch feedback scoring for spans
     *
     * @param {OpikApi.FeedbackScoreBatch} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.spans.scoreBatchOfSpans({
     *         scores: [{
     *                 name: "name",
     *                 value: 1.1,
     *                 source: "ui",
     *                 id: "id"
     *             }]
     *     })
     */
    scoreBatchOfSpans(request: FeedbackScoreBatch, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __scoreBatchOfSpans;
    /**
     * Search spans
     * @throws {@link OpikApi.BadRequestError}
     */
    searchSpans(request?: SpanSearchStreamRequestPublic, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __searchSpans;
    /**
     * Update span comment by id
     *
     * @param {string} commentId
     * @param {OpikApi.UpdateSpanCommentRequest} request
     * @param {SpansClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.spans.updateSpanComment("commentId", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    updateSpanComment(commentId: string, request: UpdateSpanCommentRequest, requestOptions?: SpansClient.RequestOptions): HttpResponsePromise<void>;
    private __updateSpanComment;
}

declare namespace SystemUsageClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * System usage related resource
 */
declare class SystemUsageClient {
    protected readonly _options: NormalizedClientOptions<SystemUsageClient.Options>;
    constructor(options?: SystemUsageClient.Options);
    /**
     * Get datasets information for BI events per user per workspace
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getDatasetBiInfo()
     */
    getDatasetBiInfo(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<BiInformationResponse>;
    private __getDatasetBiInfo;
    /**
     * Get experiments information for BI events per user per workspace
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getExperimentBiInfo()
     */
    getExperimentBiInfo(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<BiInformationResponse>;
    private __getExperimentBiInfo;
    /**
     * Get spans information for BI events per user per workspace
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getSpansBiInfo()
     */
    getSpansBiInfo(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<BiInformationResponse>;
    private __getSpansBiInfo;
    /**
     * Get spans count on previous day for all available workspaces
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getSpansCountForWorkspaces()
     */
    getSpansCountForWorkspaces(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<SpansCountResponse>;
    private __getSpansCountForWorkspaces;
    /**
     * Get traces information for BI events per user per workspace
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getTracesBiInfo()
     */
    getTracesBiInfo(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<BiInformationResponse>;
    private __getTracesBiInfo;
    /**
     * Get traces count on previous day for all available workspaces
     *
     * @param {SystemUsageClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.systemUsage.getTracesCountForWorkspaces()
     */
    getTracesCountForWorkspaces(requestOptions?: SystemUsageClient.RequestOptions): HttpResponsePromise<TraceCountResponse>;
    private __getTracesCountForWorkspaces;
}

declare namespace TracesClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Trace related resources
 */
declare class TracesClient {
    protected readonly _options: NormalizedClientOptions<TracesClient.Options>;
    constructor(options?: TracesClient.Options);
    /**
     * Add thread comment
     *
     * @param {string} id
     * @param {OpikApi.AddThreadCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.addThreadComment("id", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    addThreadComment(id: string, request: AddThreadCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __addThreadComment;
    /**
     * Add trace comment
     *
     * @param {string} id
     * @param {OpikApi.AddTraceCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.addTraceComment("id", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    addTraceComment(id: string, request: AddTraceCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __addTraceComment;
    /**
     * Add trace feedback score
     *
     * @param {string} id
     * @param {OpikApi.AddTraceFeedbackScoreRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.addTraceFeedbackScore("id", {
     *         body: {
     *             name: "name",
     *             value: 1.1,
     *             source: "ui"
     *         }
     *     })
     */
    addTraceFeedbackScore(id: string, request: AddTraceFeedbackScoreRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __addTraceFeedbackScore;
    /**
     * Create traces
     *
     * @param {OpikApi.TraceBatchWrite} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.createTraces({
     *         traces: [{
     *                 startTime: new Date("2024-01-15T09:30:00.000Z")
     *             }]
     *     })
     */
    createTraces(request: TraceBatchWrite, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __createTraces;
    /**
     * Update multiple traces
     *
     * @param {OpikApi.TraceBatchUpdate} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.traces.batchUpdateTraces({
     *         ids: ["ids"],
     *         update: {}
     *     })
     */
    batchUpdateTraces(request: TraceBatchUpdate, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __batchUpdateTraces;
    /**
     * Update multiple threads
     *
     * @param {OpikApi.TraceThreadBatchUpdate} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.traces.batchUpdateThreads({
     *         ids: ["ids"],
     *         update: {}
     *     })
     */
    batchUpdateThreads(request: TraceThreadBatchUpdate, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __batchUpdateThreads;
    /**
     * Close one or multiple trace threads. Supports both single thread_id and multiple thread_ids for batch operations.
     *
     * @param {OpikApi.TraceThreadBatchIdentifier} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.closeTraceThread()
     */
    closeTraceThread(request?: TraceThreadBatchIdentifier, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __closeTraceThread;
    /**
     * Get traces by project_name or project_id
     *
     * @param {OpikApi.GetTracesByProjectRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTracesByProject()
     */
    getTracesByProject(request?: GetTracesByProjectRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<TracePagePublic>;
    private __getTracesByProject;
    /**
     * Get trace
     *
     * @param {OpikApi.TraceWrite} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.createTrace({
     *         startTime: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    createTrace(request: TraceWrite, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __createTrace;
    /**
     * Get trace by id
     *
     * @param {string} id
     * @param {OpikApi.GetTraceByIdRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceById("id")
     */
    getTraceById(id: string, request?: GetTraceByIdRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<TracePublic>;
    private __getTraceById;
    /**
     * Delete trace by id
     *
     * @param {string} id
     * @param {OpikApi.DeleteTraceByIdRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceById("id")
     */
    deleteTraceById(id: string, request?: DeleteTraceByIdRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteTraceById;
    /**
     * Update trace by id
     *
     * @param {string} id
     * @param {OpikApi.UpdateTraceRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.updateTrace("id", {
     *         body: {}
     *     })
     */
    updateTrace(id: string, request: UpdateTraceRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __updateTrace;
    /**
     * Delete thread comments
     *
     * @param {OpikApi.BatchDelete} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteThreadComments({
     *         ids: ["ids"]
     *     })
     */
    deleteThreadComments(request: BatchDelete, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteThreadComments;
    /**
     * Delete thread feedback scores
     *
     * @param {OpikApi.DeleteThreadFeedbackScores} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteThreadFeedbackScores({
     *         projectName: "project_name",
     *         threadId: "thread_id",
     *         names: ["names"]
     *     })
     */
    deleteThreadFeedbackScores(request: DeleteThreadFeedbackScores, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteThreadFeedbackScores;
    /**
     * Delete trace comments
     *
     * @param {OpikApi.BatchDelete} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceComments({
     *         ids: ["ids"]
     *     })
     */
    deleteTraceComments(request: BatchDelete, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteTraceComments;
    /**
     * Delete trace feedback score
     *
     * @param {string} id
     * @param {OpikApi.DeleteTraceFeedbackScoreRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceFeedbackScore("id", {
     *         body: {
     *             name: "name"
     *         }
     *     })
     */
    deleteTraceFeedbackScore(id: string, request: DeleteTraceFeedbackScoreRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteTraceFeedbackScore;
    /**
     * Delete trace threads
     *
     * @param {OpikApi.DeleteTraceThreads} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraceThreads({
     *         threadIds: ["thread_ids"]
     *     })
     */
    deleteTraceThreads(request: DeleteTraceThreads, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteTraceThreads;
    /**
     * Delete traces
     *
     * @param {OpikApi.BatchDelete} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.deleteTraces({
     *         ids: ["ids"]
     *     })
     */
    deleteTraces(request: BatchDelete, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteTraces;
    /**
     * Find Feedback Score names
     *
     * @param {OpikApi.FindFeedbackScoreNames2Request} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.findFeedbackScoreNames2()
     */
    findFeedbackScoreNames2(request?: FindFeedbackScoreNames2Request, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<string[]>;
    private __findFeedbackScoreNames2;
    /**
     * Find Trace Threads Feedback Score names
     *
     * @param {OpikApi.FindTraceThreadsFeedbackScoreNamesRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.findTraceThreadsFeedbackScoreNames()
     */
    findTraceThreadsFeedbackScoreNames(request?: FindTraceThreadsFeedbackScoreNamesRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<string[]>;
    private __findTraceThreadsFeedbackScoreNames;
    /**
     * Get trace stats
     *
     * @param {OpikApi.GetTraceStatsRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceStats()
     */
    getTraceStats(request?: GetTraceStatsRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<ProjectStatsPublic>;
    private __getTraceStats;
    /**
     * Get thread comment
     *
     * @param {string} threadId
     * @param {string} commentId
     * @param {OpikApi.GetThreadCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.getThreadComment("threadId", "commentId")
     */
    getThreadComment(threadId: string, commentId: string, request?: GetThreadCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<Comment>;
    private __getThreadComment;
    /**
     * Get trace thread stats
     *
     * @param {OpikApi.GetTraceThreadStatsRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceThreadStats()
     */
    getTraceThreadStats(request?: GetTraceThreadStatsRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<ProjectStatsPublic>;
    private __getTraceThreadStats;
    /**
     * Get trace comment
     *
     * @param {string} traceId
     * @param {string} commentId
     * @param {OpikApi.GetTraceCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.getTraceComment("traceId", "commentId")
     */
    getTraceComment(traceId: string, commentId: string, request?: GetTraceCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<Comment>;
    private __getTraceComment;
    /**
     * Get trace thread
     *
     * @param {OpikApi.TraceThreadIdentifier} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.getTraceThread({
     *         threadId: "thread_id"
     *     })
     */
    getTraceThread(request: TraceThreadIdentifier, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<TraceThread>;
    private __getTraceThread;
    /**
     * Get trace threads
     *
     * @param {OpikApi.GetTraceThreadsRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.getTraceThreads()
     */
    getTraceThreads(request?: GetTraceThreadsRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<TraceThreadPage>;
    private __getTraceThreads;
    /**
     * Open trace thread
     *
     * @param {OpikApi.TraceThreadIdentifier} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.openTraceThread({
     *         threadId: "thread_id"
     *     })
     */
    openTraceThread(request: TraceThreadIdentifier, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __openTraceThread;
    /**
     * Batch feedback scoring for threads
     *
     * @param {OpikApi.FeedbackScoreBatchThread} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.scoreBatchOfThreads({
     *         scores: [{
     *                 name: "name",
     *                 value: 1.1,
     *                 source: "ui",
     *                 threadId: "thread_id"
     *             }]
     *     })
     */
    scoreBatchOfThreads(request: FeedbackScoreBatchThread, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __scoreBatchOfThreads;
    /**
     * Batch feedback scoring for traces
     *
     * @param {OpikApi.FeedbackScoreBatch} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.traces.scoreBatchOfTraces({
     *         scores: [{
     *                 name: "name",
     *                 value: 1.1,
     *                 source: "ui",
     *                 id: "id"
     *             }]
     *     })
     */
    scoreBatchOfTraces(request: FeedbackScoreBatch, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __scoreBatchOfTraces;
    /**
     * Search trace threads
     * @throws {@link OpikApi.BadRequestError}
     */
    searchTraceThreads(request?: TraceThreadSearchStreamRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __searchTraceThreads;
    /**
     * Search traces
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnauthorizedError}
     */
    searchTraces(request?: TraceSearchStreamRequestPublic, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<ReadableStream<Uint8Array>>;
    private __searchTraces;
    /**
     * Update thread
     *
     * @param {string} threadModelId
     * @param {OpikApi.UpdateThreadRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.updateThread("threadModelId", {
     *         body: {}
     *     })
     */
    updateThread(threadModelId: string, request: UpdateThreadRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __updateThread;
    /**
     * Update thread comment by id
     *
     * @param {string} commentId
     * @param {OpikApi.UpdateThreadCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.updateThreadComment("commentId", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    updateThreadComment(commentId: string, request: UpdateThreadCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __updateThreadComment;
    /**
     * Update trace comment by id
     *
     * @param {string} commentId
     * @param {OpikApi.UpdateTraceCommentRequest} request
     * @param {TracesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.traces.updateTraceComment("commentId", {
     *         body: {
     *             text: "text"
     *         }
     *     })
     */
    updateTraceComment(commentId: string, request: UpdateTraceCommentRequest, requestOptions?: TracesClient.RequestOptions): HttpResponsePromise<void>;
    private __updateTraceComment;
}

declare namespace WelcomeWizardClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Welcome wizard tracking resources
 */
declare class WelcomeWizardClient {
    protected readonly _options: NormalizedClientOptions<WelcomeWizardClient.Options>;
    constructor(options?: WelcomeWizardClient.Options);
    /**
     * Get welcome wizard tracking status for the current workspace
     *
     * @param {WelcomeWizardClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.welcomeWizard.getWelcomeWizardStatus()
     */
    getWelcomeWizardStatus(requestOptions?: WelcomeWizardClient.RequestOptions): HttpResponsePromise<WelcomeWizardTracking>;
    private __getWelcomeWizardStatus;
    /**
     * Submit welcome wizard with user information
     *
     * @param {OpikApi.WelcomeWizardSubmission} request
     * @param {WelcomeWizardClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.welcomeWizard.submitWelcomeWizard()
     */
    submitWelcomeWizard(request?: WelcomeWizardSubmission, requestOptions?: WelcomeWizardClient.RequestOptions): HttpResponsePromise<void>;
    private __submitWelcomeWizard;
}

declare namespace WorkspacesClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
/**
 * Workspace related resources
 */
declare class WorkspacesClient {
    protected readonly _options: NormalizedClientOptions<WorkspacesClient.Options>;
    constructor(options?: WorkspacesClient.Options);
    /**
     * Get costs summary
     *
     * @param {OpikApi.WorkspaceMetricsSummaryRequest} request
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.workspaces.costsSummary({
     *         intervalStart: new Date("2024-01-15T09:30:00.000Z"),
     *         intervalEnd: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    costsSummary(request: WorkspaceMetricsSummaryRequest, requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<Result>;
    private __costsSummary;
    /**
     * Get workspace configuration
     *
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.workspaces.getWorkspaceConfiguration()
     */
    getWorkspaceConfiguration(requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<WorkspaceConfiguration>;
    private __getWorkspaceConfiguration;
    /**
     * Upsert workspace configuration
     *
     * @param {OpikApi.WorkspaceConfiguration} request
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     * @throws {@link OpikApi.UnprocessableEntityError}
     *
     * @example
     *     await client.workspaces.upsertWorkspaceConfiguration({})
     */
    upsertWorkspaceConfiguration(request: WorkspaceConfiguration, requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<WorkspaceConfiguration>;
    private __upsertWorkspaceConfiguration;
    /**
     * Delete workspace configuration
     *
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.NotFoundError}
     *
     * @example
     *     await client.workspaces.deleteWorkspaceConfiguration()
     */
    deleteWorkspaceConfiguration(requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<void>;
    private __deleteWorkspaceConfiguration;
    /**
     * Get cost daily data
     *
     * @param {OpikApi.WorkspaceMetricsSummaryRequest} request
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.workspaces.getCost({
     *         intervalStart: new Date("2024-01-15T09:30:00.000Z"),
     *         intervalEnd: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    getCost(request: WorkspaceMetricsSummaryRequest, requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<WorkspaceMetricResponse>;
    private __getCost;
    /**
     * Get metric daily data
     *
     * @param {OpikApi.WorkspaceMetricsSummaryRequest} request
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.workspaces.getMetric({
     *         intervalStart: new Date("2024-01-15T09:30:00.000Z"),
     *         intervalEnd: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    getMetric(request: WorkspaceMetricsSummaryRequest, requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<WorkspaceMetricResponse>;
    private __getMetric;
    /**
     * Get metrics summary
     *
     * @param {OpikApi.WorkspaceMetricsSummaryRequest} request
     * @param {WorkspacesClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link OpikApi.BadRequestError}
     *
     * @example
     *     await client.workspaces.metricsSummary({
     *         intervalStart: new Date("2024-01-15T09:30:00.000Z"),
     *         intervalEnd: new Date("2024-01-15T09:30:00.000Z")
     *     })
     */
    metricsSummary(request: WorkspaceMetricsSummaryRequest, requestOptions?: WorkspacesClient.RequestOptions): HttpResponsePromise<WorkspaceMetricsSummaryResponse>;
    private __metricsSummary;
}

declare namespace OpikApiClient {
    type Options = BaseClientOptions;
    interface RequestOptions extends BaseRequestOptions {
    }
}
declare class OpikApiClient {
    protected readonly _options: NormalizedClientOptions<OpikApiClient.Options>;
    protected _systemUsage: SystemUsageClient | undefined;
    protected _alerts: AlertsClient | undefined;
    protected _annotationQueues: AnnotationQueuesClient | undefined;
    protected _attachments: AttachmentsClient | undefined;
    protected _check: CheckClient | undefined;
    protected _automationRuleEvaluators: AutomationRuleEvaluatorsClient | undefined;
    protected _chatCompletions: ChatCompletionsClient | undefined;
    protected _dashboards: DashboardsClient | undefined;
    protected _datasets: DatasetsClient | undefined;
    protected _experiments: ExperimentsClient | undefined;
    protected _feedbackDefinitions: FeedbackDefinitionsClient | undefined;
    protected _guardrails: GuardrailsClient | undefined;
    protected _llmProviderKey: LlmProviderKeyClient | undefined;
    protected _manualEvaluation: ManualEvaluationClient | undefined;
    protected _ollama: OllamaClient | undefined;
    protected _openTelemetryIngestion: OpenTelemetryIngestionClient | undefined;
    protected _optimizations: OptimizationsClient | undefined;
    protected _projects: ProjectsClient | undefined;
    protected _prompts: PromptsClient | undefined;
    protected _serviceToggles: ServiceTogglesClient | undefined;
    protected _spans: SpansClient | undefined;
    protected _traces: TracesClient | undefined;
    protected _welcomeWizard: WelcomeWizardClient | undefined;
    protected _workspaces: WorkspacesClient | undefined;
    protected _redirect: RedirectClient | undefined;
    constructor(options?: OpikApiClient.Options);
    get systemUsage(): SystemUsageClient;
    get alerts(): AlertsClient;
    get annotationQueues(): AnnotationQueuesClient;
    get attachments(): AttachmentsClient;
    get check(): CheckClient;
    get automationRuleEvaluators(): AutomationRuleEvaluatorsClient;
    get chatCompletions(): ChatCompletionsClient;
    get dashboards(): DashboardsClient;
    get datasets(): DatasetsClient;
    get experiments(): ExperimentsClient;
    get feedbackDefinitions(): FeedbackDefinitionsClient;
    get guardrails(): GuardrailsClient;
    get llmProviderKey(): LlmProviderKeyClient;
    get manualEvaluation(): ManualEvaluationClient;
    get ollama(): OllamaClient;
    get openTelemetryIngestion(): OpenTelemetryIngestionClient;
    get optimizations(): OptimizationsClient;
    get projects(): ProjectsClient;
    get prompts(): PromptsClient;
    get serviceToggles(): ServiceTogglesClient;
    get spans(): SpansClient;
    get traces(): TracesClient;
    get welcomeWizard(): WelcomeWizardClient;
    get workspaces(): WorkspacesClient;
    get redirect(): RedirectClient;
    /**
     * @param {OpikApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.isAlive()
     */
    isAlive(requestOptions?: OpikApiClient.RequestOptions): HttpResponsePromise<unknown>;
    private __isAlive;
    /**
     * @param {OpikApiClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.version()
     */
    version(requestOptions?: OpikApiClient.RequestOptions): HttpResponsePromise<unknown>;
    private __version;
}

type RequestOptions = OpikApiClient.RequestOptions;

interface OpikConfig {
    apiKey: string;
    apiUrl?: string;
    projectName: string;
    workspaceName: string;
    requestOptions?: RequestOptions;
    batchDelayMs?: number;
    holdUntilFlush?: boolean;
}
interface ConstructorOpikConfig extends OpikConfig {
    headers?: Record<string, string>;
}

/**
 * Supported template engine types for prompts
 * Re-exported from REST API with uppercase values for consistency
 */
declare const PromptType: {
    /** Mustache template syntax with {{variable}} placeholders */
    readonly MUSTACHE: "mustache";
    /** Jinja2 template syntax with {% %} blocks and {{ }} variables */
    readonly JINJA2: "jinja2";
};
type PromptType = (typeof PromptType)[keyof typeof PromptType];
/**
 * Template structure types for prompts
 */
declare const PromptTemplateStructure: {
    /** Text-based prompt with a single template string */
    readonly Text: "text";
    /** Chat-based prompt with an array of messages */
    readonly Chat: "chat";
};
type PromptTemplateStructure = (typeof PromptTemplateStructure)[keyof typeof PromptTemplateStructure];
/**
 * Common options shared between text and chat prompts
 * Used internally for prompt creation logic
 */
interface CommonPromptOptions {
    /** Optional prompt ID (generated if not provided) */
    promptId?: string;
    /** Optional description for the prompt */
    description?: string;
    /** Optional metadata for tracking and filtering */
    metadata?: JsonNodeWrite;
    /** Optional change description for version tracking */
    changeDescription?: string;
    /** Template engine type, defaults to mustache */
    type?: PromptType;
    /** Optional tags for categorization */
    tags?: string[];
}
/**
 * Configuration options for creating a new prompt
 * Extends REST API PromptWrite with renamed 'prompt' field
 */
interface CreatePromptOptions extends CommonPromptOptions {
    /** Name of the prompt (unique identifier) */
    name: string;
    /** Template text content with placeholders */
    prompt: string;
}
/**
 * Options for retrieving a specific prompt version
 * Re-exported from REST API PromptVersionRetrieveDetail
 */
type GetPromptOptions = PromptVersionRetrieveDetail;
/**
 * Variables to be substituted into prompt template.
 */
type PromptVariables = Record<string, unknown>;
/**
 * Data structure for creating a PromptVersion instance
 */
interface PromptVersionData {
    name: string;
    prompt: string;
    commit: string;
    promptId: string;
    versionId: string;
    type: PromptType;
    metadata?: JsonNode;
    changeDescription?: string;
    tags?: string[];
    createdAt?: Date;
    createdBy?: string;
}
/**
 * Content part for multimodal chat messages
 */
interface ContentPart {
    type: string;
    [key: string]: unknown;
}
/**
 * Message content can be a string or array of content parts
 */
type MessageContent = string | ContentPart[];
/**
 * Chat message with role and content
 */
interface ChatMessage {
    role: string;
    content: MessageContent;
}
/**
 * Modality name for supported content types
 */
type ModalityName = "vision" | "video";
/**
 * Mapping of modalities to whether they are supported
 */
type SupportedModalities = Partial<Record<ModalityName, boolean>>;
/**
 * Configuration options for creating a new chat prompt
 */
interface CreateChatPromptOptions extends CommonPromptOptions {
    /** Name of the prompt (unique identifier) */
    name: string;
    /** Array of chat messages with role and content */
    messages: ChatMessage[];
    /** Whether to validate template placeholders */
    validatePlaceholders?: boolean;
}

/**
 * Represents a specific immutable snapshot of a prompt template at a point in time.
 * Pure data object with formatting capabilities.
 */
declare class PromptVersion {
    readonly id: string;
    readonly name: string;
    readonly prompt: string;
    readonly commit: string;
    readonly type: PromptType;
    readonly metadata?: JsonNode;
    readonly changeDescription?: string;
    readonly tags?: string[];
    readonly createdAt?: Date;
    readonly createdBy?: string;
    constructor(data: PromptVersionData);
    /**
     * Format the prompt template with the provided variables
     */
    format(variables: PromptVariables): string;
    /**
     * Get human-readable version age (e.g., "2 days ago", "Today")
     */
    getVersionAge(): string;
    /**
     * Get formatted version information string
     * Format: "[commitHash] YYYY-MM-DD by user@email.com - Change description"
     */
    getVersionInfo(): string;
    /**
     * Compare this version's template with another version and return a formatted diff.
     * Displays a git-style unified diff showing additions, deletions, and changes.
     * For chat prompts, provides intelligent formatting with structured message display.
     * The diff is automatically logged to the terminal and also returned as a string.
     * The output is colored and formatted for terminal display.
     *
     * @param other - The version to compare against
     * @returns A formatted string showing the differences between versions
     *
     * @example
     * ```typescript
     * const currentVersion = await prompt.getVersion("commit123");
     * const previousVersion = await prompt.getVersion("commit456");
     *
     * // Logs diff to terminal and returns it
     * const diff = currentVersion.compareTo(previousVersion);
     * ```
     */
    compareTo(other: PromptVersion): string;
    /**
     * Check if a prompt string is a chat prompt (JSON array of messages)
     */
    private isChatPrompt;
    /**
     * Format chat prompt string (JSON) for human-readable comparison.
     */
    private formatChatPromptString;
    /**
     * Factory method to create PromptVersion from API response
     */
    static fromApiResponse(name: string, apiResponse: PromptVersionDetail): PromptVersion;
}

/**
 * Base data interface for all prompt types
 */
interface BasePromptData {
    promptId: string;
    versionId: string;
    name: string;
    commit?: string;
    metadata?: JsonNode;
    type?: PromptType;
    changeDescription?: string;
    description?: string;
    tags?: string[];
    templateStructure?: PromptTemplateStructure;
}
/**
 * Abstract base class for all prompt types.
 * Provides common functionality for versioning, property updates, and deletion.
 */
declare abstract class BasePrompt {
    readonly id: string;
    readonly versionId: string;
    readonly commit: string | undefined;
    readonly type: PromptType;
    readonly changeDescription: string | undefined;
    readonly templateStructure: PromptTemplateStructure;
    protected _name: string;
    protected _description: string | undefined;
    protected _tags: string[];
    protected readonly _metadata: JsonNode | undefined;
    protected readonly opik: OpikClient;
    constructor(data: BasePromptData, opik: OpikClient);
    get name(): string;
    get description(): string | undefined;
    get tags(): readonly string[] | undefined;
    /**
     * Read-only metadata property.
     * Returns deep copy to prevent external mutation.
     */
    get metadata(): JsonNode | undefined;
    /**
     * Updates prompt properties (name, description, and/or tags).
     * Performs immediate update (no batching).
     *
     * @param updates - Partial updates with optional name, description, and tags
     * @returns Promise resolving to this prompt instance for method chaining
     */
    updateProperties(updates: {
        name?: string;
        description?: string;
        tags?: string[];
    }): Promise<this>;
    /**
     * Deletes this prompt from the backend.
     * Performs immediate deletion (no batching).
     */
    delete(): Promise<void>;
    /**
     * Retrieves all version history for this prompt.
     * Fetches and returns complete version history, sorted by creation date (newest first).
     * Automatically handles pagination to fetch all versions.
     *
     * @param options - Optional filtering, sorting, and search parameters
     * @returns Promise resolving to array of all PromptVersion instances for this prompt
     */
    getVersions(options?: {
        search?: string;
        sorting?: string;
        filters?: string;
    }): Promise<PromptVersion[]>;
    /**
     * Helper method to restore a version.
     * Used by subclasses in their useVersion implementations.
     *
     * @param version - PromptVersion object to restore
     * @returns Promise resolving to the API response for the restored version
     */
    protected restoreVersion(version: PromptVersion): Promise<PromptVersionDetail>;
    /**
     * Helper method to retrieve a version by commit hash.
     * Used by subclasses in their getVersion implementations.
     *
     * @param commit - Commit hash (8-char short form or full)
     * @returns Promise resolving to the API response or null if not found
     */
    protected retrieveVersionByCommit(commit: string): Promise<PromptVersionDetail | null>;
    /**
     * Get a specific version by commit hash.
     * Returns a new instance of the appropriate prompt type.
     *
     * @param commit - Commit hash (8-char short form or full)
     * @returns Promise resolving to prompt instance or null if not found
     */
    abstract getVersion(commit: string): Promise<BasePrompt | null>;
    /**
     * Restores a specific version by creating a new version with content from the specified version.
     *
     * @param version - PromptVersion object to restore
     * @returns Promise resolving to a new prompt instance with the restored version
     */
    abstract useVersion(version: PromptVersion): Promise<BasePrompt>;
}

interface PromptData extends BasePromptData {
    prompt: string;
}
/**
 * Domain object representing a versioned text prompt template.
 * Provides immutable access to prompt properties and template formatting.
 * Integrates with backend for persistence and version management.
 */
declare class Prompt extends BasePrompt {
    readonly prompt: string;
    /**
     * Creates a new Prompt instance.
     * This should not be created directly, use OpikClient.createPrompt() instead.
     */
    constructor(data: PromptData, opik: OpikClient);
    /**
     * Returns the template string for this text prompt.
     * Alias for the `prompt` property for consistency with ChatPrompt.
     */
    get template(): string;
    /**
     * Formats prompt template by substituting variables.
     * Validates that all template placeholders are provided (for Mustache templates).
     *
     * @param variables - Object with values to substitute into template
     * @returns Formatted prompt text with variables substituted
     * @throws PromptValidationError if template processing or validation fails
     *
     * @example
     * ```typescript
     * const prompt = new Prompt({
     *   name: "greeting",
     *   prompt: "Hello {{name}}, your score is {{score}}",
     *   type: "mustache"
     * }, client);
     *
     * // Valid - all placeholders provided
     * prompt.format({ name: "Alice", score: 95 });
     * // Returns: "Hello Alice, your score is 95"
     *
     * // Invalid - missing 'score' placeholder
     * prompt.format({ name: "Alice" });
     * // Throws: PromptValidationError
     * ```
     */
    format(variables: PromptVariables): string;
    /**
     * Static factory method to create Prompt from backend API response.
     *
     * @param name - Name of the prompt
     * @param apiResponse - REST API PromptVersionDetail response
     * @param opik - OpikClient instance
     * @param promptPublicData - Optional PromptPublic data containing description and tags
     * @returns Prompt instance constructed from response data
     * @throws PromptValidationError if response structure invalid
     */
    static fromApiResponse(promptData: PromptPublic, apiResponse: PromptVersionDetail, opik: OpikClient): Prompt;
    /**
     * Restores a specific version by creating a new version with content from the specified version.
     * The version must be obtained from the backend (e.g., via getVersions()).
     * Returns a new Prompt instance with the restored content as the latest version.
     *
     * @param version - PromptVersion object to restore (must be from backend)
     * @returns Promise resolving to a new Prompt instance with the restored version
     * @throws OpikApiError if REST API call fails
     *
     * @example
     * ```typescript
     * const prompt = await client.getPrompt({ name: "my-prompt" });
     *
     * // Get all versions
     * const versions = await prompt.getVersions();
     *
     * // Restore a specific version
     * const targetVersion = versions.find(v => v.commit === "abc123de");
     * if (targetVersion) {
     *   const restoredPrompt = await prompt.useVersion(targetVersion);
     *   console.log(`Restored to commit: ${restoredPrompt.commit}`);
     *   console.log(`New template: ${restoredPrompt.prompt}`);
     *
     *   // Continue using the restored prompt
     *   const formatted = restoredPrompt.format({ name: "World" });
     * }
     * ```
     */
    useVersion(version: PromptVersion): Promise<Prompt>;
    /**
     * Get a Prompt with a specific version by commit hash.
     *
     * @param commit - Commit hash (8-char short form or full)
     * @returns Prompt instance representing that version, or null if not found
     *
     * @example
     * ```typescript
     * const prompt = await client.getPrompt({ name: "greeting" });
     *
     * // Get a specific version directly as a Prompt
     * const versionedPrompt = await prompt.getVersion("abc123de");
     * if (versionedPrompt) {
     *   const text = versionedPrompt.format({ name: "Alice" });
     * }
     * ```
     */
    getVersion(commit: string): Promise<Prompt | null>;
}

/**
 * A feedback score for batch operations.
 *
 * Derived from API's FeedbackScoreBatchItem, excluding internal fields (source, projectId, author)
 * that are managed by the SDK. Used with `logTracesFeedbackScores` and `logSpansFeedbackScores`.
 * Matches Python SDK's `BatchFeedbackScoreDict`.
 *
 * @property id - The trace or span ID to attach the score to
 * @property name - The name of the feedback metric (e.g., "accuracy", "helpfulness")
 * @property value - The numerical score value
 * @property categoryName - Optional category for the score
 * @property reason - Optional explanation for the score
 * @property projectName - Optional project name (defaults to client's project)
 */
type FeedbackScoreData = Omit<FeedbackScoreBatchItem, "source" | "projectId" | "author">;
/**
 * Extended TraceUpdate type that includes prompts field.
 * Allows associating prompt versions with trace updates.
 */
interface TraceUpdateData extends Omit<TraceUpdate, "projectId"> {
    prompts?: Prompt[];
}
/**
 * Extended SpanUpdate type that includes prompts field.
 * Allows associating prompt versions with span updates.
 */
interface SpanUpdateData extends Omit<SpanUpdate$1, "traceId" | "parentSpanId" | "projectId" | "projectName"> {
    prompts?: Prompt[];
}

interface SavedSpan extends Span$1 {
    id: string;
}
declare class Span {
    data: SavedSpan;
    private opik;
    private childSpans;
    constructor(data: SavedSpan, opik: OpikClient);
    end: () => this;
    score: (score: {
        name: string;
        categoryName?: string;
        value: number;
        reason?: string;
    }) => void;
    update: (updates: SpanUpdateData) => this;
    span: (spanData: Omit<Span$1, "startTime" | "traceId" | "parentSpanId" | "projectId" | "projectName" | "id"> & {
        startTime?: Date;
    }) => Span;
}

interface SavedTrace extends Trace$1 {
    id: string;
}
interface SpanData extends Omit<Span$1, "startTime" | "traceId"> {
    startTime?: Date;
}
declare class Trace {
    data: SavedTrace;
    private opik;
    private spans;
    constructor(data: SavedTrace, opik: OpikClient);
    end: () => this;
    score: (score: {
        name: string;
        categoryName?: string;
        value: number;
        reason?: string;
    }) => void;
    span: (spanData: SpanData) => Span;
    update: (updates: TraceUpdateData) => this;
}

interface BatchQueueOptions {
    delay?: number;
    enableCreateBatch?: boolean;
    enableUpdateBatch?: boolean;
    enableDeleteBatch?: boolean;
    createBatchSize?: number;
    updateBatchSize?: number;
    deleteBatchSize?: number;
    name?: string;
}
declare abstract class BatchQueue<EntityData = object, EntityId = string> {
    private readonly createQueue;
    private readonly updateQueue;
    private readonly deleteQueue;
    private readonly name;
    constructor({ delay, enableCreateBatch, enableUpdateBatch, enableDeleteBatch, createBatchSize, updateBatchSize, deleteBatchSize, name, }?: BatchQueueOptions);
    protected abstract createEntities(entities: EntityData[]): Promise<void>;
    protected abstract getEntity(id: EntityId): Promise<EntityData | undefined>;
    protected abstract updateEntity(id: EntityId, updates: Partial<EntityData>): Promise<void>;
    protected abstract deleteEntities(ids: EntityId[]): Promise<void>;
    protected abstract getId(entity: EntityData): EntityId;
    create: (entity: EntityData) => void;
    get: (id: EntityId) => Promise<EntityData | undefined>;
    update: (id: EntityId, updates: Partial<EntityData>) => void;
    delete: (id: EntityId) => void;
    flush: () => Promise<void>;
}

interface OpikApiClientTempOptions extends OpikApiClient.Options {
    requestOptions?: RequestOptions;
}
declare class OpikApiClientTemp extends OpikApiClient {
    requestOptions: RequestOptions;
    constructor(options?: OpikApiClientTempOptions);
    setHeaders: (headers: Record<string, string>) => void;
}

type SpanUpdate = Partial<SavedSpan> & {
    traceId: string;
};
declare class SpanBatchQueue extends BatchQueue<SavedSpan> {
    private readonly api;
    constructor(api: OpikApiClientTemp, delay?: number);
    protected getId(entity: SavedSpan): string;
    protected createEntities(spans: SavedSpan[]): Promise<void>;
    protected getEntity(id: string): Promise<SavedSpan>;
    protected updateEntity(id: string, updates: SpanUpdate): Promise<void>;
    protected deleteEntities(ids: string[]): Promise<void>;
}

type FeedbackScoreId$1 = {
    id: string;
    name: string;
};
declare class SpanFeedbackScoresBatchQueue extends BatchQueue<FeedbackScoreBatchItem, FeedbackScoreId$1> {
    private readonly api;
    constructor(api: OpikApiClientTemp, delay?: number);
    protected getId(entity: FeedbackScoreBatchItem): {
        id: string;
        name: string;
    };
    protected createEntities(scores: FeedbackScoreBatchItem[]): Promise<void>;
    protected getEntity(): Promise<FeedbackScoreBatchItem | undefined>;
    protected updateEntity(): Promise<void>;
    protected deleteEntities(scoreIds: FeedbackScoreId$1[]): Promise<void>;
}

declare class TraceBatchQueue extends BatchQueue<SavedTrace> {
    private readonly api;
    constructor(api: OpikApiClientTemp, delay?: number);
    protected getId(entity: SavedTrace): string;
    protected createEntities(traces: SavedTrace[]): Promise<void>;
    protected getEntity(id: string): Promise<SavedTrace>;
    protected updateEntity(id: string, updates: Partial<SavedTrace>): Promise<void>;
    protected deleteEntities(ids: string[]): Promise<void>;
}

type FeedbackScoreId = {
    id: string;
    name: string;
};
declare class TraceFeedbackScoresBatchQueue extends BatchQueue<FeedbackScoreBatchItem, FeedbackScoreId> {
    private readonly api;
    constructor(api: OpikApiClientTemp, delay?: number);
    protected getId(entity: FeedbackScoreBatchItem): {
        id: string;
        name: string;
    };
    protected createEntities(scores: FeedbackScoreBatchItem[]): Promise<void>;
    protected getEntity(): Promise<FeedbackScoreBatchItem | undefined>;
    protected updateEntity(): Promise<void>;
    protected deleteEntities(scoreIds: FeedbackScoreId[]): Promise<void>;
}

/**
 * Batch queue for dataset operations that allows efficient batching of dataset CRUD operations.
 * Extends the generic BatchQueue to provide specific implementations for dataset resources.
 */
declare class DatasetBatchQueue extends BatchQueue<DatasetWrite> {
    private readonly api;
    /**
     * Creates a new DatasetBatchQueue instance.
     *
     * @param api The OpikApiClient instance used to communicate with the API
     * @param delay Optional delay in milliseconds before flushing the queue (defaults to 300ms)
     */
    constructor(api: OpikApiClientTemp, delay?: number);
    /**
     * Gets the ID of a dataset entity.
     *
     * @param entity The dataset entity
     * @returns The ID of the dataset
     */
    protected getId(entity: DatasetWrite): string;
    /**
     * Creates multiple dataset entities in a batch.
     *
     * @param datasets The array of datasets to create
     */
    protected createEntities(datasets: DatasetWrite[]): Promise<void>;
    /**
     * Retrieves a dataset by its ID.
     *
     * @param id The ID of the dataset to retrieve
     * @returns The retrieved dataset or undefined if not found
     */
    protected getEntity(id: string): Promise<DatasetPublic | undefined>;
    /**
     * Updates a dataset by its ID with the provided updates.
     *
     * @param id The ID of the dataset to update
     * @param updates Partial dataset properties to update
     */
    protected updateEntity(id: string, updates: Partial<DatasetWrite>): Promise<void>;
    /**
     * Deletes multiple datasets by their IDs.
     *
     * @param ids Array of dataset IDs to delete
     */
    protected deleteEntities(ids: string[]): Promise<void>;
}

type DatasetItemData = JsonNode & {
    id?: string;
};

interface DatasetData {
    name: string;
    description?: string;
    id?: string;
}
declare class Dataset<T extends DatasetItemData = DatasetItemData> {
    private opik;
    readonly id: string;
    readonly name: string;
    readonly description?: string;
    private idToHash;
    private hashes;
    /**
     * Configuration object for creating a new Dataset instance.
     * This should not be created directly, use static factory methods instead.
     */
    constructor({ name, description, id }: DatasetData, opik: OpikClient);
    /**
     * Insert new items into the dataset.
     *
     * @param items List of objects to add to the dataset
     */
    insert(items: T[]): Promise<void>;
    /**
     * Update existing items in the dataset.
     * You need to provide the full item object as it will override what has been supplied previously.
     *
     * @param items List of objects to update in the dataset
     */
    update(items: T[]): Promise<void>;
    /**
     * Delete items from the dataset.
     *
     * @param itemIds List of item ids to delete
     */
    delete(itemIds: string[]): Promise<void>;
    /**
     * Delete all items from the dataset.
     */
    clear(): Promise<void>;
    /**
     * Retrieve a fixed number of dataset items.
     *
     * @param nbSamples The number of samples to retrieve. If not set - all items are returned
     * @param lastRetrievedId Optional ID of the last retrieved item for pagination
     * @returns A list of objects representing the dataset items
     */
    getItems(nbSamples?: number, lastRetrievedId?: string): Promise<(T & {
        id: string;
    })[]>;
    private getItemsAsDataclasses;
    /**
     * Insert items from a JSON string array into the dataset.
     *
     * @param jsonArray JSON string of format: "[{...}, {...}, {...}]" where every object is transformed into a dataset item
     * @param keysMapping Optional dictionary that maps JSON keys to dataset item field names (e.g., {'Expected output': 'expected_output'})
     * @param ignoreKeys Optional array of keys that should be ignored when constructing dataset items
     */
    insertFromJson(jsonArray: string, keysMapping?: Record<string, string>, ignoreKeys?: string[]): Promise<void>;
    /**
     * Convert the dataset to a JSON string.
     *
     * @param keysMapping Optional dictionary that maps dataset item field names to output JSON keys
     * @returns A JSON string representation of all items in the dataset
     */
    toJson(keysMapping?: Record<string, string>): Promise<string>;
    /**
     * Retrieves all items from the dataset, deduplicates them, and returns them.
     *
     * @returns A list of deduplicated dataset items
     */
    private getDeduplicatedItems;
    /**
     * Clears both hash tracking data structures
     */
    private clearHashState;
    syncHashes(): Promise<void>;
}

/**
 * References to a dataset item and trace in an experiment.
 */
declare class ExperimentItemReferences {
    readonly datasetItemId: string;
    readonly traceId: string;
    constructor(params: {
        datasetItemId: string;
        traceId: string;
    });
}
/**
 * Content of an experiment item including evaluation data and feedback scores.
 */
declare class ExperimentItemContent {
    readonly id?: string;
    readonly datasetItemId: string;
    readonly traceId: string;
    readonly datasetItemData?: JsonListStringCompare;
    readonly evaluationTaskOutput?: JsonListStringCompare;
    readonly feedbackScores: FeedbackScore[];
    constructor(params: {
        id?: string;
        datasetItemId: string;
        traceId: string;
        datasetItemData?: JsonListStringCompare;
        evaluationTaskOutput?: JsonListStringCompare;
        feedbackScores: FeedbackScore[];
    });
    /**
     * Creates an ExperimentItemContent from a REST API ExperimentItemCompare object.
     *
     * @param value The REST API ExperimentItemCompare object
     * @returns A new ExperimentItemContent instance
     */
    static fromRestExperimentItemCompare(value: ExperimentItemCompare): ExperimentItemContent;
}

interface ExperimentData {
    id?: string;
    name?: string;
    datasetName: string;
    prompts?: Prompt[];
}
/**
 * Represents an Experiment in Opik, linking traces and dataset items
 */
declare class Experiment {
    private opik;
    readonly id: string;
    private _name?;
    readonly datasetName: string;
    readonly prompts?: Prompt[];
    /**
     * Creates a new Experiment instance.
     * This should not be created directly, use static factory methods instead.
     */
    constructor({ id, name, datasetName, prompts }: ExperimentData, opik: OpikClient);
    /**
     * Gets the experiment name. If not provided during construction,
     * lazy-loads it from the backend API.
     */
    get name(): string | undefined;
    /**
     * Async method to ensure the name is loaded from backend if needed.
     * Call this method before accessing name if you need to ensure it's loaded.
     */
    ensureNameLoaded(): Promise<string>;
    /**
     * Creates new experiment items by linking existing traces and dataset items
     *
     * @param experimentItemReferences List of references linking traces with dataset items
     */
    insert(experimentItemReferences: ExperimentItemReferences[]): Promise<void>;
    /**
     * Retrieves experiment items with options to limit results and truncate data
     *
     * @param options Options for retrieving items
     * @returns Promise resolving to a list of experiment items
     */
    getItems(options?: {
        maxResults?: number;
        truncate?: boolean;
    }): Promise<ExperimentItemContent[]>;
    getUrl(): Promise<string>;
}

interface ChatPromptData extends BasePromptData {
    messages: ChatMessage[];
}
/**
 * Domain object representing a versioned chat prompt template.
 * Provides immutable access to chat message templates and formatting.
 * Integrates with backend for persistence and version management.
 */
declare class ChatPrompt extends BasePrompt {
    readonly messages: ChatMessage[];
    private readonly chatTemplate;
    /**
     * Creates a new ChatPrompt instance.
     * This should not be created directly, use OpikClient.createChatPrompt() instead.
     */
    constructor(data: ChatPromptData, opik: OpikClient);
    /**
     * Returns the template messages for this chat prompt.
     * Alias for the `messages` property for consistency with Prompt.
     */
    get template(): ChatMessage[];
    /**
     * Formats chat template by substituting variables in messages.
     *
     * @param variables - Object with values to substitute into template
     * @param supportedModalities - Optional specification of which modalities are supported.
     *   When a modality is not supported (false or not specified), structured content
     *   parts (e.g., images, videos) are replaced with text placeholders like
     *   "<<<image>>>" or "<<<video>>>". When supported (true), the structured content
     *   is preserved as-is. Defaults to all modalities supported.
     * @returns Array of formatted chat messages with variables substituted
     * @throws PromptValidationError if template processing fails
     *
     * @example
     * ```typescript
     * const chatPrompt = new ChatPrompt({
     *   name: "assistant",
     *   messages: [
     *     { role: "system", content: "You are a {{role}}" },
     *     { role: "user", content: "Help me with {{task}}" }
     *   ],
     *   type: "mustache"
     * }, client);
     *
     * // Format with all modalities supported
     * const messages = chatPrompt.format({
     *   role: "helpful assistant",
     *   task: "coding"
     * });
     *
     * // Format with limited modalities
     * const textOnly = chatPrompt.format(
     *   { role: "assistant", task: "coding" },
     *   { vision: false, video: false }
     * );
     * ```
     */
    format(variables: PromptVariables, supportedModalities?: SupportedModalities): ChatMessage[];
    /**
     * Static factory method to create ChatPrompt from backend API response.
     *
     * @param promptData - PromptPublic data containing name, description, tags
     * @param apiResponse - REST API PromptVersionDetail response
     * @param opik - OpikClient instance
     * @returns ChatPrompt instance constructed from response data
     * @throws PromptValidationError if response structure invalid
     */
    static fromApiResponse(promptData: PromptPublic, apiResponse: PromptVersionDetail, opik: OpikClient): ChatPrompt;
    /**
     * Restores a specific version by creating a new version with content from the specified version.
     * The version must be obtained from the backend (e.g., via getVersions()).
     * Returns a new ChatPrompt instance with the restored content as the latest version.
     *
     * @param version - PromptVersion object to restore (must be from backend)
     * @returns Promise resolving to a new ChatPrompt instance with the restored version
     * @throws OpikApiError if REST API call fails
     *
     * @example
     * ```typescript
     * const chatPrompt = await client.getChatPrompt({ name: "my-chat-prompt" });
     *
     * // Get all versions
     * const versions = await chatPrompt.getVersions();
     *
     * // Restore a specific version
     * const targetVersion = versions.find(v => v.commit === "abc123de");
     * if (targetVersion) {
     *   const restoredPrompt = await chatPrompt.useVersion(targetVersion);
     *   console.log(`Restored to commit: ${restoredPrompt.commit}`);
     *
     *   // Continue using the restored prompt
     *   const formatted = restoredPrompt.format({ name: "World" });
     * }
     * ```
     */
    useVersion(version: PromptVersion): Promise<ChatPrompt>;
    /**
     * Get a ChatPrompt with a specific version by commit hash.
     *
     * @param commit - Commit hash (8-char short form or full)
     * @returns ChatPrompt instance representing that version, or null if not found
     *
     * @example
     * ```typescript
     * const chatPrompt = await client.getChatPrompt({ name: "greeting" });
     *
     * // Get a specific version directly as a ChatPrompt
     * const versionedPrompt = await chatPrompt.getVersion("abc123de");
     * if (versionedPrompt) {
     *   const messages = versionedPrompt.format({ name: "Alice" });
     * }
     * ```
     */
    getVersion(commit: string): Promise<ChatPrompt | null>;
}

interface TraceData extends Omit<Trace$1, "startTime"> {
    startTime?: Date;
}
declare class OpikClient {
    api: OpikApiClientTemp;
    config: OpikConfig;
    spanBatchQueue: SpanBatchQueue;
    traceBatchQueue: TraceBatchQueue;
    spanFeedbackScoresBatchQueue: SpanFeedbackScoresBatchQueue;
    traceFeedbackScoresBatchQueue: TraceFeedbackScoresBatchQueue;
    datasetBatchQueue: DatasetBatchQueue;
    private lastProjectNameLogged;
    constructor(explicitConfig?: Partial<ConstructorOpikConfig>);
    private displayTraceLog;
    trace: (traceData: TraceData) => Trace;
    /**
     * Retrieves an existing dataset by name
     *
     * @param name The name of the dataset to retrieve
     * @returns A Dataset object associated with the specified name
     * @throws Error if the dataset doesn't exist
     */
    getDataset: <T extends DatasetItemData = DatasetItemData>(name: string) => Promise<Dataset<T>>;
    /**
     * Creates a new dataset with the given name and optional description
     *
     * @param name The name of the dataset
     * @param description Optional description of the dataset
     * @returns The created Dataset object
     */
    createDataset: <T extends DatasetItemData = DatasetItemData>(name: string, description?: string) => Promise<Dataset<T>>;
    /**
     * Retrieves an existing dataset by name or creates a new one if it doesn't exist.
     *
     * @param name The name of the dataset
     * @param description Optional description of the dataset (used if created)
     * @returns A promise that resolves to the existing or newly created Dataset object
     */
    getOrCreateDataset: <T extends DatasetItemData = DatasetItemData>(name: string, description?: string) => Promise<Dataset<T>>;
    /**
     * Returns all datasets up to the specified limit
     *
     * @param maxResults Maximum number of datasets to return (default: 100)
     * @returns List of Dataset objects
     */
    getDatasets: <T extends DatasetItemData = DatasetItemData>(maxResults?: number) => Promise<Dataset<T>[]>;
    /**
     * Deletes a dataset by name
     *
     * @param name The name of the dataset to delete
     */
    deleteDataset: (name: string) => Promise<void>;
    /**
     * Creates a new experiment with the given dataset name and optional parameters
     *
     * @param datasetName The name of the dataset to associate with the experiment
     * @param name Optional name for the experiment (if not provided, a generated name will be used)
     * @param experimentConfig Optional experiment configuration parameters
     * @param prompts Optional array of Prompt objects to link with the experiment
     * @param type Optional experiment type (defaults to "regular")
     * @param optimizationId Optional ID of an optimization associated with the experiment
     * @returns The created Experiment object
     */
    createExperiment: ({ datasetName, name, experimentConfig, prompts, type, optimizationId, }: {
        datasetName: string;
        name?: string;
        experimentConfig?: Record<string, unknown>;
        prompts?: Prompt[];
        type?: ExperimentType;
        optimizationId?: string;
    }) => Promise<Experiment>;
    /**
     * Updates an experiment by ID
     *
     * @param id The ID of the experiment
     * @param experimentUpdate Object containing the fields to update
     * @param experimentUpdate.name Optional new name for the experiment
     * @param experimentUpdate.experimentConfig Optional new configuration for the experiment
     * @returns Promise that resolves when the experiment is updated
     * @throws {Error} If id is not provided or if neither name nor experimentConfig is provided
     */
    updateExperiment: (id: string, experimentUpdate: {
        name?: string;
        experimentConfig?: Record<string, unknown>;
    }) => Promise<void>;
    /**
     * Gets an experiment by its unique ID
     *
     * @param id The unique identifier of the experiment
     * @returns The Experiment object
     */
    getExperimentById: (id: string) => Promise<Experiment>;
    /**
     * Gets experiments by name (can return multiple experiments with the same name)
     *
     * @param name The name of the experiments to retrieve
     * @returns A list of Experiment objects with the given name
     */
    getExperimentsByName: (name: string) => Promise<Experiment[]>;
    /**
     * Gets a single experiment by name (returns the first match if multiple exist)
     *
     * @param name The name of the experiment to retrieve
     * @returns The Experiment object
     */
    getExperiment: (name: string) => Promise<Experiment>;
    /**
     * Gets all experiments associated with a dataset
     *
     * @param datasetName The name of the dataset
     * @param maxResults Maximum number of experiments to return (default: 100)
     * @returns A list of Experiment objects associated with the dataset
     * @throws {DatasetNotFoundError} If the dataset doesn't exist
     */
    getDatasetExperiments: (datasetName: string, maxResults?: number) => Promise<Experiment[]>;
    /**
     * Deletes an experiment by ID
     *
     * @param id The ID of the experiment to delete
     */
    deleteExperiment: (id: string) => Promise<void>;
    /**
     * Internal helper for creating prompts (text or chat).
     * Handles common logic: version checking, creation, and property updates.
     *
     * @param name - Prompt name
     * @param template - Template string (raw text or JSON-serialized messages)
     * @param templateStructure - Text or Chat structure
     * @param options - Common prompt options (metadata, type, description, tags)
     * @param validateStructure - Callback to validate template structure against existing prompt
     * @param createInstance - Factory function to create Prompt or ChatPrompt instance
     * @param logContext - Context string for logging (e.g., "prompt" or "chat prompt")
     * @returns Promise resolving to Prompt or ChatPrompt instance
     */
    private createPromptInternal;
    /**
     * Creates a new prompt or new version if content differs.
     *
     * Key Behaviors:
     * - Smart Versioning: Only creates a new version if template, metadata, or type differ from latest
     * - Idempotent: Returns existing version if identical (no duplicate versions)
     * - 404 Handling: Gracefully handles first-time prompt creation
     * - Uses create_prompt_version endpoint (not create_prompt which is for containers)
     * - Synchronous: Returns immediately with the created/retrieved version
     *
     * @param options - Prompt configuration
     * @returns Promise resolving to Prompt instance
     * @throws PromptValidationError if parameters invalid
     */
    createPrompt: (options: CreatePromptOptions) => Promise<Prompt>;
    /**
     * Creates a new chat prompt or returns existing one if identical.
     * Chat prompts use message arrays instead of string templates.
     * Idempotent: returns existing version if messages, metadata, and type match.
     *
     * @param options - Chat prompt configuration with messages array
     * @returns Promise resolving to ChatPrompt instance
     * @throws PromptTemplateStructureMismatch if a text prompt with same name exists
     *
     * @example
     * ```typescript
     * const chatPrompt = await client.createChatPrompt({
     *   name: "assistant-prompt",
     *   messages: [
     *     { role: "system", content: "You are a helpful assistant" },
     *     { role: "user", content: "Help me with {{task}}" }
     *   ],
     *   type: "mustache"
     * });
     * ```
     */
    createChatPrompt: (options: CreateChatPromptOptions) => Promise<ChatPrompt>;
    /**
     * Retrieves a text prompt by name and optional version.
     * Throws PromptTemplateStructureMismatch if the prompt is a chat prompt.
     *
     * @param options - Prompt name and optional commit hash
     * @returns Promise resolving to Prompt or null if not found
     * @throws PromptTemplateStructureMismatch if prompt exists but is a chat prompt
     */
    getPrompt: (options: GetPromptOptions) => Promise<Prompt | null>;
    /**
     * Retrieves a chat prompt by name and optional version.
     * Throws PromptTemplateStructureMismatch if the prompt is a text prompt.
     *
     * @param options - Prompt name and optional commit hash
     * @returns Promise resolving to ChatPrompt or null if not found
     * @throws PromptTemplateStructureMismatch if prompt exists but is a text prompt
     *
     * @example
     * ```typescript
     * const chatPrompt = await client.getChatPrompt({ name: "assistant-prompt" });
     * if (chatPrompt) {
     *   const messages = chatPrompt.format({ task: "coding" });
     * }
     * ```
     */
    getChatPrompt: (options: GetPromptOptions) => Promise<ChatPrompt | null>;
    /**
     * Searches prompts with optional OQL filtering.
     *
     * @param filterString - Optional OQL filter string to narrow down search
     *
     * Supported OQL format: `<COLUMN> <OPERATOR> <VALUE> [AND <COLUMN> <OPERATOR> <VALUE>]*`
     *
     * Supported columns:
     * - `id`, `name`: String fields
     * - `tags`: List field (use "contains" operator only)
     * - `created_by`: String field
     *
     * Supported operators by column:
     * - `id`: =, !=, contains, not_contains, starts_with, ends_with, >, <
     * - `name`: =, !=, contains, not_contains, starts_with, ends_with, >, <
     * - `created_by`: =, !=, contains, not_contains, starts_with, ends_with, >, <
     * - `tags`: contains (only)
     *
     * @returns Promise resolving to array of matching latest prompt versions
     * @throws Error if OQL filter syntax is invalid
     *
     * @example
     * ```typescript
     * // Get all prompts
     * const allPrompts = await client.searchPrompts();
     *
     * // Filter by tag
     * const prompts = await client.searchPrompts('tags contains "alpha"');
     *
     * // Filter by multiple criteria
     * const prompts = await client.searchPrompts(
     *   'tags contains "alpha" AND name contains "summary"'
     * );
     *
     * // Filter by creator
     * const prompts = await client.searchPrompts('created_by = "user@example.com"');
     * ```
     */
    searchPrompts: (filterString?: string) => Promise<(Prompt | ChatPrompt)[]>;
    /**
     * Deletes multiple prompts and all their versions in batch.
     * Performs synchronous deletion (no batching).
     *
     * @param ids - Array of prompt container IDs to delete
     */
    deletePrompts: (ids: string[]) => Promise<void>;
    /**
     * Search for traces in the given project. Optionally, you can wait for at least a certain number of traces
     * to be found before returning within the specified timeout.
     *
     * @param projectName - The name of the project to search in. Defaults to the project configured on the Client.
     * @param filterString - Filter using Opik Query Language (OQL). Format: `<COLUMN> <OPERATOR> <VALUE> [AND ...]`
     *   Common columns: `id`, `name`, `start_time`, `end_time`, `input`, `output`, `status`, `tags`, `metadata.*`, `feedback_scores.*`, `usage.*`
     *   Common operators: `=`, `!=`, `>`, `<`, `>=`, `<=`, `contains`, `not_contains`, `starts_with`, `ends_with`
     *   Use ISO 8601 format for dates (e.g., "2024-01-01T00:00:00Z")
     * @param maxResults - Maximum number of traces to return (default: 1000)
     * @param truncate - Whether to truncate image data in input, output, or metadata (default: true)
     * @param waitForAtLeast - Minimum number of traces to wait for before returning
     * @param waitForTimeout - Timeout for waiting in seconds (default: 60)
     *
     * @returns Promise resolving to array of traces matching the search criteria
     * @throws {SearchTimeoutError} If waitForAtLeast traces are not found within the specified timeout
     *
     * @example
     * ```typescript
     * // Get all traces in a project
     * const traces = await client.searchTraces({ projectName: "My Project" });
     *
     * // Filter by date and metadata
     * const filtered = await client.searchTraces({
     *   projectName: "My Project",
     *   filterString: 'start_time >= "2024-01-01T00:00:00Z" AND metadata.model = "gpt-4"'
     * });
     *
     * // Wait for at least 10 traces
     * const traces = await client.searchTraces({
     *   projectName: "My Project",
     *   waitForAtLeast: 10,
     *   waitForTimeout: 30
     * });
     * ```
     */
    searchTraces: (options?: {
        projectName?: string;
        filterString?: string;
        maxResults?: number;
        truncate?: boolean;
        waitForAtLeast?: number;
        waitForTimeout?: number;
    }) => Promise<TracePublic[]>;
    private logFeedbackScores;
    /**
     * Log feedback scores to existing traces in batch.
     *
     * @param scores - Array of feedback score data with trace IDs
     *
     * @example
     * ```typescript
     * client.logTracesFeedbackScores([
     *   { id: "trace-id-1", name: "quality", value: 0.9, reason: "Good response" },
     *   { id: "trace-id-2", name: "relevance", value: 0.8 }
     * ]);
     * await client.flush();
     * ```
     */
    logTracesFeedbackScores(scores: FeedbackScoreData[]): void;
    /**
     * Log feedback scores to existing spans in batch.
     *
     * @param scores - Array of feedback score data with span IDs
     *
     * @example
     * ```typescript
     * client.logSpansFeedbackScores([
     *   { id: "span-id-1", name: "accuracy", value: 0.95 },
     *   { id: "span-id-2", name: "completeness", value: 0.85, reason: "Missing details" }
     * ]);
     * await client.flush();
     * ```
     */
    logSpansFeedbackScores(scores: FeedbackScoreData[]): void;
    flush: () => Promise<void>;
    /**
     * Updates tags for one or more prompt versions in a single batch operation.
     *
     * @param versionIds - Array of prompt version IDs to update
     * @param options - Update options
     * @param options.tags - Tags to set or merge:
     *   - `[]`: Clear all tags (when mergeTags is false or unspecified)
     *   - `['tag1', 'tag2']`: Set or merge tags (based on mergeTags)
     * @param options.mergeTags - If true, adds new tags to existing tags (union). If false, replaces all existing tags (default: false)
     * @returns Promise that resolves when update is complete
     * @throws OpikApiError if update fails
     *
     * @example
     * ```typescript
     * // Replace tags on multiple versions (default behavior)
     * await client.updatePromptVersionTags(["version-id-1", "version-id-2"], {
     *   tags: ["production", "v2"]
     * });
     *
     * // Merge new tags with existing tags
     * await client.updatePromptVersionTags(["version-id-1"], {
     *   tags: ["hotfix"],
     *   mergeTags: true
     * });
     *
     * // Clear all tags
     * await client.updatePromptVersionTags(["version-id-1"], {
     *   tags: []
     * });
     * ```
     */
    updatePromptVersionTags: (versionIds: string[], options?: {
        tags?: string[] | null;
        mergeTags?: boolean;
    }) => Promise<void>;
}

type TrackContext = {
    span?: Span;
    trace?: Trace;
} | {
    span: Span;
    trace: Trace;
};
declare const getTrackContext: () => Required<TrackContext> | undefined;
type TrackOptions = {
    name?: string;
    projectName?: string;
    type?: SpanType;
    /**
     * Optional function to enrich the span with additional data extracted from the result.
     * Called before the span is finalized with the success result.
     *
     * @param result - The return value from the tracked function
     * @returns An object with fields to merge into the span (usage, model, provider, metadata, etc.)
     */
    enrichSpan?: (result: any) => Record<string, unknown>;
};
type OriginalFunction = (...args: any[]) => any;
declare function track(optionsOrOriginalFunction: TrackOptions | OriginalFunction, originalFunction?: OriginalFunction): OriginalFunction;

declare const generateId: () => string;

declare const flushAll: () => Promise<void>;

declare const logLevels: {
    readonly SILLY: 0;
    readonly TRACE: 1;
    readonly DEBUG: 2;
    readonly INFO: 3;
    readonly WARN: 4;
    readonly ERROR: 5;
    readonly FATAL: 6;
};
declare const logger: Logger$1<unknown>;
declare const setLoggerLevel: (level: keyof typeof logLevels) => void;
declare const disableLogger: () => void;

/**
 * Evaluation task function type
 * Takes a dataset item as input and returns a result object
 */
type EvaluationTask<T = Record<string, unknown>> = (datasetItem: T) => Promise<Record<string, unknown>> | Record<string, unknown>;
/**
 * Type for mapping between dataset keys and scoring metric inputs
 */
type ScoringKeyMappingType = Record<string, string>;
/**
 * Represents the result of an evaluation experiment
 */
type EvaluationResult = {
    /** ID of the experiment */
    experimentId: string;
    /** Name of the experiment */
    experimentName?: string;
    /** Test results for all evaluated items */
    testResults: EvaluationTestResult[];
    /** Optional URL to view detailed results in the Opik platform */
    resultUrl?: string;
};
/**
 * Represents the result of a metric calculation.
 */
type EvaluationScoreResult = {
    /** Name of the metric */
    name: string;
    /** Score value (typically between 0.0 and 1.0) */
    value: number;
    /** Optional reason for the score */
    reason?: string;
    /** Whether the scoring failed */
    scoringFailed?: boolean;
};
/**
 * Represents a single test case in the evaluation.
 */
type EvaluationTestCase = {
    /** ID of the trace associated with this test case */
    traceId: string;
    /** ID of the dataset item used for this test case */
    datasetItemId: string;
    /** Inputs for scoring metrics */
    scoringInputs: Record<string, unknown>;
    /** Output from the task execution */
    taskOutput: Record<string, unknown>;
};
/**
 * Represents the result of a test case evaluation.
 */
type EvaluationTestResult = {
    /** The test case this result is for */
    testCase: EvaluationTestCase;
    /** Results from all metrics for this test case */
    scoreResults: EvaluationScoreResult[];
};

declare abstract class BaseMetric<T extends z.ZodObject<z.ZodRawShape> = z.ZodObject<z.ZodRawShape>> {
    /**
     * The name of the metric
     */
    readonly name: string;
    /**
     * Whether this metric should be tracked
     */
    readonly trackMetric: boolean;
    /**
     * Zod schema for validating input parameters to the score method
     */
    abstract readonly validationSchema: T;
    protected constructor(name: string, trackMetric?: boolean);
    /**
     * Compute the score using validated input
     * @param input - The validated input of type inferred from the schema
     */
    abstract score(input: unknown): EvaluationScoreResult | EvaluationScoreResult[] | Promise<EvaluationScoreResult> | Promise<EvaluationScoreResult[]>;
}

interface EvaluateOptions<T = Record<string, unknown>> {
    /** The dataset to evaluate against, containing inputs and expected outputs */
    dataset: Dataset<T extends DatasetItemData ? T : DatasetItemData & T>;
    /** The specific LLM task to perform (e.g., classification, generation, question-answering) */
    task: EvaluationTask<T>;
    /** Optional array of metrics to evaluate model performance (e.g., accuracy, F1 score) */
    scoringMetrics?: BaseMetric[];
    /** Optional name for this evaluation experiment for tracking and reporting */
    experimentName?: string;
    /** Optional project identifier to associate this experiment with */
    projectName?: string;
    /** Optional configuration settings for the experiment as key-value pairs */
    experimentConfig?: Record<string, unknown>;
    /** Optional array of Prompt objects to link with the experiment for tracking */
    prompts?: Prompt[];
    /** Optional number of samples to evaluate from the dataset (defaults to all if not specified) */
    nbSamples?: number;
    /**
     * Optional Opik client instance to use for tracking
     */
    client?: OpikClient;
    /**
     * Optional mapping between dataset keys and scoring metric inputs
     * Allows renaming keys from dataset or task output to match what metrics expect
     */
    scoringKeyMapping?: ScoringKeyMappingType;
}
declare function evaluate<T = Record<string, unknown>>(options: EvaluateOptions<T>): Promise<EvaluationResult>;

/**
 * System message containing system instructions.
 *
 * Note: using the "system" part of the prompt is strongly preferred
 * to increase the resilience against prompt injection attacks,
 * and because not all providers support several system messages.
 */
type OpikSystemMessage = SystemModelMessage;
/**
 * User message containing user input.
 */
type OpikUserMessage = UserModelMessage;
/**
 * Assistant message containing model response.
 */
type OpikAssistantMessage = AssistantModelMessage;
/**
 * Tool message containing tool call results.
 */
type OpikToolMessage = ToolModelMessage;
/**
 * Union type of all message types.
 * This is the main type to use for message arrays in LLM conversations.
 *
 * Provider-agnostic interface that can be adapted to any LLM provider.
 */
type OpikMessage = ModelMessage;
/**
 * Abstract base class for all LLM model providers in Opik evaluation system.
 *
 * This interface allows different LLM providers (OpenAI, Anthropic, etc.) to be used
 * interchangeably in evaluation tasks and metrics.
 *
 * The interface is intentionally provider-agnostic and does not depend on any
 * specific SDK's types (like Vercel AI SDK, LangChain, etc.)
 *
 * @example
 * ```typescript
 * class MyCustomModel extends OpikBaseModel {
 *   constructor() {
 *     super('my-model-name');
 *   }
 *
 *   async generateString(input: string): Promise<string> {
 *     // Your implementation
 *     return 'response';
 *   }
 *
 *   async generateProviderResponse(messages: OpikMessage[]): Promise<unknown> {
 *     // Your implementation - return whatever your provider returns
 *     return {
 *       text: 'response',
 *       usage: { promptTokens: 10, completionTokens: 5 },
 *       // ... other provider-specific fields
 *     };
 *   }
 * }
 * ```
 */
declare abstract class OpikBaseModel {
    readonly modelName: string;
    /**
     * Creates a new model instance.
     *
     * @param modelName - The name of the model (e.g., 'gpt-4o', 'claude-3-opus')
     */
    constructor(modelName: string);
    /**
     * Simplified interface to generate a string output from the model.
     *
     * This is the primary method for simple text generation tasks.
     *
     * @param input - The input string/prompt to send to the model
     * @param responseFormat - Optional Zod schema for structured output validation
     * @param options - Optional provider-specific configuration
     * @returns The generated text response (or JSON string if responseFormat is provided)
     *
     * @example
     * ```typescript
     * const model = new VercelAIChatModel('gpt-4o');
     *
     * // Simple text generation
     * const response = await model.generateString('What is 2+2?');
     * console.log(response); // "2+2 equals 4"
     *
     * // Structured output with Zod schema
     * const schema = z.object({ score: z.boolean(), reason: z.array(z.string()) });
     * const structuredResponse = await model.generateString('Evaluate...', schema);
     * console.log(structuredResponse); // '{"score": true, "reason": ["..."]}'
     * ```
     */
    abstract generateString(input: string, responseFormat?: z.ZodSchema, options?: Record<string, unknown>): Promise<string>;
    /**
     * Generate a provider-specific response object.
     *
     * This method provides access to the raw provider response, which may include
     * additional metadata like token usage, model info, etc.
     *
     * The return type is intentionally `unknown` to allow each provider implementation
     * to return its own native response type.
     *
     * @param messages - Array of messages in Opik format
     * @param options - Optional provider-specific configuration
     * @returns The provider's raw response object
     *
     * @example
     * ```typescript
     * const model = new VercelAIChatModel('gpt-4o');
     * const response = await model.generateProviderResponse([
     *   { role: 'user', content: 'Hello!' }
     * ]);
     * // Response type depends on the provider implementation
     * ```
     */
    abstract generateProviderResponse(messages: OpikMessage[], options?: Record<string, unknown>): Promise<unknown>;
}

/**
 * Union type of all supported model IDs from OpenAI, Anthropic, and Google Gemini.
 *
 * @example
 * ```typescript
 * // Valid model IDs
 * const model1: SupportedModelId = "gpt-4o";
 * const model2: SupportedModelId = "claude-3-5-sonnet-latest";
 * const model3: SupportedModelId = "gemini-2.0-flash";
 * ```
 */
type SupportedModelId = OpenAIChatModelId | AnthropicMessagesModelId | GoogleGenerativeAIModelId;
/**
 * OpenAI provider-specific options.
 * Extends the official OpenAI provider settings with consistent apiKey support.
 */
interface OpenAIProviderOptions extends Omit<OpenAIProviderSettings, "apiKey"> {
    /** API key for OpenAI. Falls back to OPENAI_API_KEY environment variable if not provided. */
    apiKey?: string;
}
/**
 * Anthropic provider-specific options.
 * Extends the official Anthropic provider settings with consistent apiKey support.
 */
interface AnthropicProviderOptions extends Omit<AnthropicProviderSettings, "apiKey"> {
    /** API key for Anthropic. Falls back to ANTHROPIC_API_KEY environment variable if not provided. */
    apiKey?: string;
}
/**
 * Google Generative AI provider-specific options.
 * Extends the official Google provider settings with consistent apiKey support.
 */
interface GoogleProviderOptions extends Omit<GoogleGenerativeAIProviderSettings, "apiKey"> {
    /** API key for Google. Falls back to GOOGLE_API_KEY environment variable if not provided. */
    apiKey?: string;
}
/**
 * Union type of all possible provider configuration options.
 */
type AllProviderOptions = OpenAIProviderOptions | AnthropicProviderOptions | GoogleProviderOptions;
/**
 * Conditional type that maps model ID to the correct provider options.
 * This enables TypeScript to automatically infer the correct options type based on the model ID.
 *
 * @example
 * ```typescript
 * // TypeScript infers OpenAIProviderOptions
 * const options1: ProviderOptionsForModel<"gpt-4o"> = {
 *   apiKey: "sk-...",
 *   organization: "org-123" //  Valid OpenAI option
 * };
 *
 * // TypeScript infers AnthropicProviderOptions
 * const options2: ProviderOptionsForModel<"claude-3-5-sonnet-latest"> = {
 *   apiKey: "sk-ant-...",
 * };
 * ```
 */
type ProviderOptionsForModel<T extends SupportedModelId> = T extends OpenAIChatModelId ? OpenAIProviderOptions : T extends AnthropicMessagesModelId ? AnthropicProviderOptions : T extends GoogleGenerativeAIModelId ? GoogleProviderOptions : never;
/**
 * Detects the provider from the model ID and creates the appropriate provider instance.
 * Uses pattern matching to automatically determine which provider to use.
 *
 * @param modelId - Model ID (e.g., "gpt-4o", "claude-3-5-sonnet-latest", "gemini-2.0-flash")
 * @param options - Provider-specific configuration options
 * @returns Provider-specific model instance ready for use with Vercel AI SDK
 *
 * @throws {ModelConfigurationError} If the provider cannot be detected or API key is missing
 *
 * @example
 * ```typescript
 * // OpenAI with organization
 * const openaiModel = detectProvider("gpt-4o", {
 *   apiKey: "sk-...",
 *   organization: "org-123"
 * });
 *
 * // Anthropic
 * const anthropicModel = detectProvider("claude-3-5-sonnet-latest", {
 *   apiKey: "sk-ant-...",
 * });
 *
 * // Gemini
 * const geminiModel = detectProvider("gemini-2.0-flash", {
 *   apiKey: "...",
 * });
 * ```
 */
declare function detectProvider(modelId: SupportedModelId, options?: Record<string, unknown>): LanguageModel;

type VercelAIChatModelOptions = {
    trackGenerations?: boolean;
} & Record<string, unknown>;
/**
 * LLM model implementation using Vercel AI SDK with multi-provider support.
 *
 * This class wraps the Vercel AI SDK's `generateText` function to provide
 * a consistent interface for multiple LLM providers in the Opik evaluation system.
 *
 * Supports:
 * - Direct LanguageModel instances for maximum flexibility
 * - Typed model IDs with automatic provider detection:
 *   - OpenAI: `"gpt-4o"`, `"gpt-4-turbo"`, `"o1"`, etc.
 *   - Anthropic: `"claude-3-5-sonnet-latest"`, `"claude-3-opus"`, etc.
 *   - Google Gemini: `"gemini-2.0-flash"`, `"gemini-1.5-pro"`, etc.
 *
 * @example
 * ```typescript
 * // Using typed model ID
 * const model1 = new VercelAIChatModel("gpt-4o", {
 *   apiKey: "sk-...",
 *   organization: "org-123"
 * });
 *
 * // Using LanguageModel instance directly
 * const customModel = openai("gpt-4o");
 * const model2 = new VercelAIChatModel(customModel);
 * ```
 */
declare class VercelAIChatModel extends OpikBaseModel {
    /**
     * The underlying AI model from the provider SDK.
     */
    private readonly model;
    /**
     * Private tracked wrapper for generateText SDK method.
     */
    private _generateText;
    /**
     * Creates a new VercelAIChatModel instance with a LanguageModel.
     *
     * @param model - A LanguageModel instance
     */
    constructor(model: LanguageModel, options?: VercelAIChatModelOptions);
    /**
     * Creates a new VercelAIChatModel instance with a typed model ID.
     *
     * @param modelId - The model ID (e.g., 'gpt-4o', 'claude-3-5-sonnet-latest', 'gemini-2.0-flash')
     * @param options - Provider-specific configuration options
     */
    constructor(modelId: SupportedModelId, options?: VercelAIChatModelOptions);
    /**
     * Generate a string response from the model.
     *
     * @param input - The prompt/input text to send to the model
     * @param responseFormat - Optional Zod schema for structured output validation
     * @param options - Optional generation parameters (temperature, maxTokens, etc.)
     * @returns The generated text response (or JSON string if responseFormat is provided)
     *
     * @throws {ModelGenerationError} If text generation fails
     *
     * @example
     * ```typescript
     * const model = new VercelAIChatModel("gpt-4o");
     *
     * // Simple text generation
     * const response = await model.generateString("What is 2+2?");
     * console.log(response); // "2+2 equals 4"
     *
     * // Structured output with Zod schema
     * const schema = z.object({ score: z.boolean(), reason: z.array(z.string()) });
     * const structuredResponse = await model.generateString("Evaluate...", schema);
     * console.log(structuredResponse); // '{"score": true, "reason": ["..."]}'
     * ```
     */
    generateString(input: string, responseFormat?: z.ZodSchema, options?: Record<string, unknown>): Promise<string>;
    /**
     * Generate a provider-specific response object.
     *
     * Returns the full response object from Vercel AI SDK, which includes
     * text, usage information, and other metadata. When trackGenerations is enabled,
     * automatically tracks the generation with usage and metadata.
     *
     * @param messages - Array of conversation messages in Opik format
     * @param options - Optional generation parameters
     * @returns The full Vercel AI SDK GenerateTextResult
     *
     * @throws {ModelGenerationError} If generation fails
     *
     * @example
     * ```typescript
     * const model = new VercelAIChatModel("gpt-4o");
     * const response = await model.generateProviderResponse([
     *   { role: 'user', content: 'Hello!' }
     * ]);
     * console.log(response.text);
     * console.log(response.usage);
     * ```
     */
    generateProviderResponse(messages: OpikMessage[], options?: Record<string, unknown>): Promise<unknown>;
}

/**
 * Factory function to create model instances with type-safe provider options.
 *
 * Supports multiple providers (OpenAI, Anthropic, Google Gemini) with automatic
 * provider detection based on model ID patterns.
 *
 * @param modelId - Model ID (e.g., 'gpt-4o', 'claude-3-5-sonnet-latest', 'gemini-2.0-flash')
 * @param options - Optional provider-specific configuration options
 * @returns An OpikBaseModel instance
 *
 * @example
 * ```typescript
 * // OpenAI with organization
 * const model1 = createModel('gpt-4o', {
 *   apiKey: 'sk-...',
 *   organization: 'org-123'
 * });
 *
 * // Anthropic
 * const model2 = createModel('claude-3-5-sonnet-latest', {
 *   apiKey: 'sk-ant-...',
 * });
 *
 * // Gemini
 * const model3 = createModel('gemini-2.0-flash', {
 *   apiKey: '...',
 * });
 * ```
 */
declare function createModel(modelId: SupportedModelId, options?: VercelAIChatModelOptions): OpikBaseModel;
/**
 * Wraps a pre-configured LanguageModel instance for use in Opik evaluations.
 *
 * Use this when you need maximum flexibility and want to configure the model
 * yourself using the Vercel AI SDK provider packages.
 *
 * @param languageModel - A pre-configured LanguageModel instance from Vercel AI SDK
 * @param options - Optional configuration options (trackGenerations defaults to true)
 * @returns An OpikBaseModel instance
 *
 * @example
 * ```typescript
 * import { openai } from '@ai-sdk/openai';
 * import { anthropic } from '@ai-sdk/anthropic';
 *
 * // OpenAI with custom settings
 * const customOpenAI = openai('gpt-4o', {
 *   structuredOutputs: true,
 * });
 * const model1 = createModelFromInstance(customOpenAI);
 *
 * // Anthropic with custom settings
 * const customAnthropic = anthropic('claude-3-5-sonnet-latest', {
 *   cacheControl: true,
 * });
 * const model2 = createModelFromInstance(customAnthropic);
 * ```
 */
declare function createModelFromInstance(languageModel: LanguageModel, options?: VercelAIChatModelOptions): OpikBaseModel;
/**
 * Resolves a model identifier to an OpikBaseModel instance.
 *
 * This function implements a resolution strategy that handles multiple input types:
 * 1. undefined/null  Creates default model (gpt-4o)
 * 2. string  Creates model from model ID
 * 3. OpikBaseModel  Returns as-is
 * 4. LanguageModel  Wraps in OpikBaseModel adapter
 *
 * @param model - Model identifier, instance, or undefined for default
 * @returns OpikBaseModel instance ready for evaluation
 * @throws {Error} When model type is invalid or unsupported
 *
 * @example
 * ```typescript
 * import { resolveModel } from 'opik/evaluation/models';
 * import { openai } from '@ai-sdk/openai';
 *
 * // Using default model
 * const model1 = resolveModel();
 *
 * // Using model ID
 * const model2 = resolveModel('gpt-4o');
 *
 * // Using OpikBaseModel instance
 * const model3 = resolveModel(new VercelAIChatModel('gpt-4o'));
 *
 * // Using LanguageModel instance
 * const model4 = resolveModel(openai('gpt-4o'));
 * ```
 */
declare function resolveModel(model?: SupportedModelId | LanguageModel | OpikBaseModel, options?: VercelAIChatModelOptions): OpikBaseModel;

/**
 * Base error class for all model-related errors.
 */
declare class ModelError extends Error {
    constructor(message: string);
}
/**
 * Error thrown when model generation fails.
 *
 * This can happen due to API errors, network issues, invalid inputs, etc.
 */
declare class ModelGenerationError extends ModelError {
    readonly cause?: Error | undefined;
    /**
     * Creates a new ModelGenerationError.
     *
     * @param message - Error message describing what went wrong
     * @param cause - Optional underlying error that caused this error
     */
    constructor(message: string, cause?: Error | undefined);
}
/**
 * Error thrown when model configuration is invalid.
 */
declare class ModelConfigurationError extends ModelError {
    constructor(message: string);
}

/**
 * Options for evaluating prompt templates against a dataset.
 * Extends EvaluateOptions but replaces 'task' with prompt-specific fields.
 */
interface EvaluatePromptOptions extends Omit<EvaluateOptions, "task"> {
    /** Message templates with {{placeholders}} to be formatted with dataset variables */
    messages: OpikMessage[];
    /** Model to use for generation. Can be model ID string, LanguageModel instance, or OpikBaseModel instance. Defaults to gpt-4o */
    model?: SupportedModelId | LanguageModel | OpikBaseModel;
    /** Template engine type for variable substitution. Defaults to mustache */
    templateType?: PromptType;
    /** Temperature setting for model generation (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic. */
    temperature?: number;
    /** Random seed for reproducible model outputs. Useful for testing and ensuring consistent results. */
    seed?: number;
}
/**
 * Evaluates prompt templates by formatting messages with dataset variables and generating LLM responses.
 *
 * This is a convenience wrapper around the `evaluate` function that handles prompt template formatting
 * and model invocation automatically. It formats message templates with dataset item variables using
 * the specified template engine (Mustache or Jinja2), generates responses using the provided model,
 * and evaluates results using the specified metrics.
 *
 * @param options - Configuration options for prompt evaluation
 * @returns Promise resolving to evaluation results with experiment metadata
 *
 * @example
 * ```typescript
 * import { evaluatePrompt } from 'opik/evaluation';
 * import { Equals } from 'opik/evaluation/metrics';
 *
 * const dataset = await client.getDataset('my-dataset');
 *
 * // Using model ID string with temperature and seed for reproducibility
 * const result1 = await evaluatePrompt({
 *   dataset,
 *   messages: [
 *     { role: 'user', content: 'Translate to {{language}}: {{text}}' }
 *   ],
 *   model: 'gpt-4o', // or omit to use default model
 *   temperature: 0.7,
 *   seed: 42,
 *   scoringMetrics: [new Equals()],
 * });
 *
 * // Using pre-configured LanguageModel instance
 * import { openai } from '@ai-sdk/openai';
 * const customModel = openai('gpt-4o', { structuredOutputs: true });
 * const result2 = await evaluatePrompt({
 *   dataset,
 *   messages: [
 *     { role: 'user', content: 'Translate to {{language}}: {{text}}' }
 *   ],
 *   model: customModel,
 *   scoringMetrics: [new Equals()],
 * });
 * ```
 */
declare function evaluatePrompt(options: EvaluatePromptOptions): Promise<EvaluationResult>;

declare const validationSchema$7: z.ZodObject<{
    output: z.ZodUnknown;
    expected: z.ZodUnknown;
}, "strip", z.ZodTypeAny, {
    output?: unknown;
    expected?: unknown;
}, {
    output?: unknown;
    expected?: unknown;
}>;
type Input$7 = z.infer<typeof validationSchema$7>;
/**
 * ExactMatch metric - checks if the actual output exactly matches the expected output.
 * Simple metric for exact string matching.
 */
declare class ExactMatch extends BaseMetric {
    /**
     * Creates a new ExactMatch metric
     * @param name Optional name for the metric (defaults to "exact_match")
     * @param trackMetric Whether to track the metric
     */
    constructor(name?: string, trackMetric?: boolean);
    validationSchema: z.ZodObject<{
        output: z.ZodUnknown;
        expected: z.ZodUnknown;
    }, "strip", z.ZodTypeAny, {
        output?: unknown;
        expected?: unknown;
    }, {
        output?: unknown;
        expected?: unknown;
    }>;
    /**
     * Calculates a score based on exact match between output and expected
     * @param input Actual output to evaluate, must include `output` and `expected` properties
     * @returns Score result (1.0 for match, 0.0 for no match)
     */
    score(input: Input$7): Promise<EvaluationScoreResult>;
}

declare const validationSchema$6: z.ZodObject<{
    output: z.ZodString;
    substring: z.ZodString;
}, "strip", z.ZodTypeAny, {
    substring: string;
    output: string;
}, {
    substring: string;
    output: string;
}>;
type Input$6 = z.infer<typeof validationSchema$6>;
/**
 * Contains metric - checks if the actual output contains the substring string.
 * Simple metric for substring matching.
 */
declare class Contains extends BaseMetric {
    private caseSensitive;
    /**
     * Creates a new Contains metric
     * @param name Optional name for the metric (defaults to "contains")
     * @param trackMetric Whether to track the metric
     * @param caseSensitive Whether the match should be case-sensitive (defaults to false)
     */
    constructor(name?: string, trackMetric?: boolean, caseSensitive?: boolean);
    validationSchema: z.ZodObject<{
        output: z.ZodString;
        substring: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        substring: string;
        output: string;
    }, {
        substring: string;
        output: string;
    }>;
    /**
     * Calculates a score based on whether output contains substring
     * @param input Actual output to evaluate, must include `output` and `substring` properties
     * @returns Score result (1.0 if found, 0.0 if not found)
     */
    score(input: Input$6): Promise<EvaluationScoreResult>;
}

declare const validationSchema$5: z.ZodObject<{
    output: z.ZodString;
    pattern: z.ZodString;
    flags: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    output: string;
    pattern: string;
    flags?: string | undefined;
}, {
    output: string;
    pattern: string;
    flags?: string | undefined;
}>;
type Input$5 = z.infer<typeof validationSchema$5>;
/**
 * RegexMatch metric - checks if the actual output matches a regex pattern.
 * Useful for flexible pattern matching.
 */
declare class RegexMatch extends BaseMetric {
    /**
     * Creates a new RegexMatch metric
     * @param name Optional name for the metric (defaults to "regex_match")
     * @param trackMetric Whether to track the metric
     */
    constructor(name?: string, trackMetric?: boolean);
    validationSchema: z.ZodObject<{
        output: z.ZodString;
        pattern: z.ZodString;
        flags: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        output: string;
        pattern: string;
        flags?: string | undefined;
    }, {
        output: string;
        pattern: string;
        flags?: string | undefined;
    }>;
    /**
     * Calculates a score based on regex match
     * @param input Actual output to evaluate, must include `output`, `pattern`, and optional `flags` properties
     * @returns Score result (1.0 for match, 0.0 for no match)
     */
    score(input: Input$5): Promise<EvaluationScoreResult>;
}

declare const validationSchema$4: z.ZodObject<{
    output: z.ZodUnknown;
}, "strip", z.ZodTypeAny, {
    output?: unknown;
}, {
    output?: unknown;
}>;
type Input$4 = z.infer<typeof validationSchema$4>;
/**
 * IsJson metric - checks if a given output string is valid JSON.
 */
declare class IsJson extends BaseMetric {
    /**
     * Creates a new IsJson metric
     * @param name Optional name for the metric (defaults to "is_json_metric")
     * @param trackMetric Whether to track the metric
     */
    constructor(name?: string, trackMetric?: boolean);
    validationSchema: z.ZodObject<{
        output: z.ZodUnknown;
    }, "strip", z.ZodTypeAny, {
        output?: unknown;
    }, {
        output?: unknown;
    }>;
    /**
     * Calculates a score based on whether output is a valid JSON
     * @param input Actual output to evaluate
     * @returns Score result (1.0 if valid json, 0.0 if not valid json)
     */
    score(input: Input$4): Promise<EvaluationScoreResult>;
}

/**
 * Advanced model settings for LLM generation.
 * These settings are passed through to the Vercel AI SDK and provider.
 *
 * @see https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#parameters
 */
interface LLMJudgeModelSettings {
    /** Nucleus sampling - alternative to temperature */
    topP?: number;
    /** Top-K sampling for limiting token choices */
    topK?: number;
    /** Presence penalty to reduce repetition */
    presencePenalty?: number;
    /** Frequency penalty to reduce phrase repetition */
    frequencyPenalty?: number;
    /** Sequences that stop generation when encountered */
    stopSequences?: string[];
    /** Additional provider-specific settings */
    [key: string]: unknown;
}
/**
 * Abstract base class for all LLM judge metrics.
 *
 * This class provides common functionality for metrics that use language models
 * to evaluate content, including:
 * - Model initialization and management
 * - Model settings (temperature, seed, maxTokens, etc.)
 * - Consistent API across all LLM judge metrics
 *
 * Subclasses should implement the score() method to define their evaluation logic.
 *
 * @example
 * ```typescript
 * class MyMetric extends BaseLLMJudgeMetric {
 *   constructor(options) {
 *     super('my_metric', options);
 *   }
 *
 *   async score(input) {
 *     const options = this.buildModelOptions();
 *     const result = await this.model.generateString(prompt, schema, options);
 *     return parseResult(result);
 *   }
 * }
 * ```
 */
declare abstract class BaseLLMJudgeMetric extends BaseMetric {
    /**
     * The language model instance used for evaluation
     */
    protected readonly model: OpikBaseModel;
    /**
     * Temperature setting for model generation (0 = deterministic, higher = creative)
     */
    private readonly temperature?;
    /**
     * Seed for reproducible model outputs
     */
    private readonly seed?;
    /**
     * Maximum number of tokens to generate
     */
    private readonly maxTokens?;
    /**
     * Advanced model settings
     */
    private readonly modelSettings?;
    /**
     * Creates a new LLM judge metric.
     *
     * @param name - The name of the metric
     * @param options - Configuration options
     * @param options.model - The language model to use. Can be a string (model ID), LanguageModel instance, or OpikBaseModel instance. Defaults to 'gpt-4o'.
     * @param options.trackMetric - Whether to track the metric. Defaults to true.
     * @param options.temperature - Temperature setting (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic.
     * @param options.seed - Random seed for reproducible outputs. Useful for testing and debugging.
     * @param options.maxTokens - Maximum number of tokens to generate in the response.
     * @param options.modelSettings - Advanced model settings (topP, topK, presencePenalty, etc.)
     */
    protected constructor(name: string, options?: {
        model?: SupportedModelId | LanguageModel | OpikBaseModel;
        trackMetric?: boolean;
        temperature?: number;
        seed?: number;
        maxTokens?: number;
        modelSettings?: LLMJudgeModelSettings;
    });
    /**
     * Initializes the model instance.
     *
     * @param model - Model identifier or instance
     * @returns Initialized OpikBaseModel instance
     * @private
     */
    private initModel;
    /**
     * Builds the options object to pass to model generation calls.
     *
     * This method merges explicit parameters (temperature, seed, maxTokens)
     * with the modelSettings object. Explicit parameters take precedence.
     *
     * Only defined values are included in the returned object.
     *
     * @returns Options object for model.generateString() calls
     * @protected
     */
    protected buildModelOptions(): Record<string, unknown>;
}

/**
 * Few-shot example for Moderation metric.
 */
interface FewShotExampleModeration {
    /** The output text that was evaluated */
    output: string;
    /** The moderation score (0.0-1.0) */
    score: number;
    /** Explanation for the score */
    reason: string;
}
/**
 * Few-shot example for Hallucination metric.
 */
interface FewShotExampleHallucination {
    /** Title/description of the example */
    title?: string;
    /** The input/question */
    input: string;
    /** The context information */
    context: string[];
    /** The output text that was evaluated */
    output: string;
    /** The hallucination score (0.0-1.0, where 1.0 = hallucination detected) */
    score: number;
    /** Explanation for the score */
    reason: string;
}
/**
 * Few-shot example for AnswerRelevance metric with context.
 */
interface FewShotExampleAnswerRelevanceWithContext {
    /** Title/description of the example */
    title: string;
    /** The input/question */
    input: string;
    /** The output text that was evaluated */
    output: string;
    /** The context information */
    context: string[];
    /** The answer relevance score (0.0-1.0) */
    answer_relevance_score: number;
    /** Explanation for the score */
    reason: string;
}
/**
 * Few-shot example for AnswerRelevance metric without context.
 */
interface FewShotExampleAnswerRelevanceNoContext {
    /** Title/description of the example */
    title: string;
    /** The input/question */
    input: string;
    /** The output text that was evaluated */
    output: string;
    /** The answer relevance score (0.0-1.0) */
    answer_relevance_score: number;
    /** Explanation for the score */
    reason: string;
}
/**
 * Standard response format for LLM judge metrics.
 *
 * This interface represents the expected structure of responses
 * from language models when used as judges for evaluation.
 */
interface LLMJudgeResponseFormat {
    /** Numeric score value */
    score: number;
    /** Explanation or justification for the score */
    reason: string;
}

declare const validationSchema$3: z.ZodObject<{
    output: z.ZodString;
}, "strip", z.ZodTypeAny, {
    output: string;
}, {
    output: string;
}>;
type Input$3 = z.infer<typeof validationSchema$3>;
/**
 * Moderation metric - evaluates content safety using an LLM judge.
 *
 * This metric uses a language model to assess the moderation level of given text.
 * It returns a score between 0.0 and 1.0, where higher values indicate more
 * problematic content that violates content policies.
 *
 * The metric checks for:
 * - Violence or gore
 * - Hate speech or discrimination
 * - Sexual content or nudity
 * - Self-harm or suicide
 * - Illegal activities
 * - Personal information or privacy violations
 * - Spam or misleading content
 * - Harassment or bullying
 * - Extremism or radicalization
 * - Profanity or offensive language
 *
 * @example
 * ```typescript
 * import { Moderation } from 'opik/evaluation/metrics';
 *
 * // Using default model (gpt-4o)
 * const metric = new Moderation();
 * const result = await metric.score({ output: "Hello, how can I help you?" });
 * console.log(result.value);  // 0.0 (safe content)
 * console.log(result.reason); // Explanation
 *
 * // Using custom model with temperature and seed
 * const customMetric = new Moderation({
 *   model: 'gpt-4-turbo',
 *   temperature: 0.3,
 *   seed: 42
 * });
 *
 * // Using custom model instance
 * import { openai } from '@ai-sdk/openai';
 * const customModel = openai('gpt-4o');
 * const instanceMetric = new Moderation({ model: customModel });
 *
 * // With advanced settings
 * const advancedMetric = new Moderation({
 *   temperature: 0.5,
 *   maxTokens: 1000,
 *   modelSettings: {
 *     topP: 0.9,
 *     presencePenalty: 0.1
 *   }
 * });
 * ```
 */
declare class Moderation extends BaseLLMJudgeMetric {
    private readonly fewShotExamples;
    /**
     * Creates a new Moderation metric.
     *
     * @param options - Configuration options
     * @param options.model - The language model to use. Can be a string (model ID), LanguageModel instance, or OpikBaseModel instance. Defaults to 'gpt-4o'.
     * @param options.name - The name of the metric. Defaults to "moderation_metric".
     * @param options.fewShotExamples - Optional few-shot examples to guide the model
     * @param options.trackMetric - Whether to track the metric. Defaults to true.
     * @param options.temperature - Temperature setting (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic. See https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#temperature
     * @param options.seed - Random seed for reproducible outputs. Useful for testing and debugging.
     * @param options.maxTokens - Maximum number of tokens to generate in the response.
     * @param options.modelSettings - Advanced model settings (topP, topK, presencePenalty, frequencyPenalty, stopSequences)
     */
    constructor(options?: {
        model?: SupportedModelId | LanguageModel | OpikBaseModel;
        name?: string;
        fewShotExamples?: FewShotExampleModeration[];
        trackMetric?: boolean;
        temperature?: number;
        seed?: number;
        maxTokens?: number;
        modelSettings?: LLMJudgeModelSettings;
    });
    readonly validationSchema: z.ZodObject<{
        output: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        output: string;
    }, {
        output: string;
    }>;
    /**
     * Calculates the moderation score for the given output.
     *
     * @param input - Input containing the output text to evaluate
     * @param input.output - The output text to be evaluated for content safety
     * @returns Score result with value (0.0-1.0) and reason
     *
     * @example
     * ```typescript
     * const metric = new Moderation();
     * const result = await metric.score({
     *   output: "This is a safe message."
     * });
     * console.log(result.value);  // 0.0
     * console.log(result.reason); // "No content policy violations detected..."
     * ```
     */
    score(input: Input$3): Promise<EvaluationScoreResult>;
}

declare const validationSchema$2: z.ZodObject<{
    input: z.ZodString;
    output: z.ZodString;
}, "strip", z.ZodTypeAny, {
    input: string;
    output: string;
}, {
    input: string;
    output: string;
}>;
type Input$2 = z.infer<typeof validationSchema$2>;
/**
 * Usefulness metric - evaluates the usefulness of an AI response using an LLM judge.
 *
 * This metric uses a language model to assess how useful an output is given an input.
 * It returns a score between 0.0 and 1.0, where higher values indicate higher usefulness.
 *
 * The evaluation considers:
 * - Helpfulness: How well it solves the user's problem
 * - Relevance: How well it addresses the specific question
 * - Accuracy: Whether the information is correct and reliable
 * - Depth: Whether it provides sufficient detail and explanation
 * - Creativity: Whether it offers innovative or insightful perspectives
 * - Level of detail: Whether the amount of detail is appropriate
 *
 * @example
 * ```typescript
 * import { Usefulness } from 'opik/evaluation/metrics';
 *
 * // Using default model (gpt-4o)
 * const metric = new Usefulness();
 * const result = await metric.score({
 *   input: "What's the capital of France?",
 *   output: "The capital of France is Paris."
 * });
 * console.log(result.value);  // A float between 0.0 and 1.0
 * console.log(result.reason); // Explanation for the score
 *
 * // Using custom model with temperature and seed
 * const customMetric = new Usefulness({
 *   model: 'gpt-4-turbo',
 *   temperature: 0.7,
 *   seed: 42
 * });
 *
 * // Using custom model instance
 * import { openai } from '@ai-sdk/openai';
 * const customModel = openai('gpt-4o');
 * const instanceMetric = new Usefulness({ model: customModel });
 *
 * // With advanced settings
 * const advancedMetric = new Usefulness({
 *   temperature: 0.5,
 *   maxTokens: 1000,
 *   modelSettings: {
 *     topP: 0.9,
 *     presencePenalty: 0.1
 *   }
 * });
 * ```
 */
declare class Usefulness extends BaseLLMJudgeMetric {
    /**
     * Creates a new Usefulness metric.
     *
     * @param options - Configuration options
     * @param options.model - The language model to use. Can be a string (model ID), LanguageModel instance, or OpikBaseModel instance. Defaults to 'gpt-4o'.
     * @param options.name - The name of the metric. Defaults to "usefulness_metric".
     * @param options.trackMetric - Whether to track the metric. Defaults to true.
     * @param options.temperature - Temperature setting (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic. See https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#temperature
     * @param options.seed - Random seed for reproducible outputs. Useful for testing and debugging.
     * @param options.maxTokens - Maximum number of tokens to generate in the response.
     * @param options.modelSettings - Advanced model settings (topP, topK, presencePenalty, frequencyPenalty, stopSequences)
     */
    constructor(options?: {
        model?: SupportedModelId | LanguageModel | OpikBaseModel;
        name?: string;
        trackMetric?: boolean;
        temperature?: number;
        seed?: number;
        maxTokens?: number;
        modelSettings?: LLMJudgeModelSettings;
    });
    readonly validationSchema: z.ZodObject<{
        input: z.ZodString;
        output: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        input: string;
        output: string;
    }, {
        input: string;
        output: string;
    }>;
    /**
     * Calculates the usefulness score for the given input-output pair.
     *
     * @param input - Input containing the question and response
     * @param input.input - The input text/question that was given to the AI
     * @param input.output - The output text/response generated by the AI
     * @returns Score result with value (0.0-1.0) and reason
     *
     * @example
     * ```typescript
     * const metric = new Usefulness();
     * const result = await metric.score({
     *   input: "How do I make pancakes?",
     *   output: "Mix flour, eggs, and milk. Cook on a hot griddle until golden."
     * });
     * console.log(result.value);  // e.g., 0.8
     * console.log(result.reason); // "The response provides clear, actionable steps..."
     * ```
     */
    score(input: Input$2): Promise<EvaluationScoreResult>;
}

declare const validationSchema$1: z.ZodObject<{
    input: z.ZodString;
    output: z.ZodString;
    context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    input: string;
    output: string;
    context?: string[] | undefined;
}, {
    input: string;
    output: string;
    context?: string[] | undefined;
}>;
type Input$1 = z.infer<typeof validationSchema$1>;
/**
 * Hallucination metric - evaluates whether an LLM's output contains hallucinations.
 *
 * This metric uses a language model to judge if the output is factual or contains
 * hallucinations based on given input and optional context. It returns a score of
 * 1.0 if hallucination is detected, and 0.0 otherwise.
 *
 * The evaluation considers:
 * - With context: Whether the output introduces information beyond the context
 * - With context: Whether the output contradicts the context
 * - Without context: Whether the output contradicts well-established facts
 * - Partial hallucinations where some information is correct but other parts are not
 * - Subtle misattributions or conflations of information
 *
 * @example
 * ```typescript
 * import { Hallucination } from 'opik/evaluation/metrics';
 *
 * // Using default model (gpt-4o)
 * const metric = new Hallucination();
 *
 * // With context
 * const resultWithContext = await metric.score({
 *   input: "What is the capital of France?",
 *   output: "The capital of France is London.",
 *   context: ["The capital of France is Paris."]
 * });
 * console.log(resultWithContext.value);  // 1.0 (hallucination detected)
 * console.log(resultWithContext.reason); // Explanation
 *
 * // Without context (checks against general knowledge)
 * const resultNoContext = await metric.score({
 *   input: "What is the capital of France?",
 *   output: "The capital of France is Paris."
 * });
 * console.log(resultNoContext.value);  // 0.0 (no hallucination)
 *
 * // Using custom model with few-shot examples
 * const customMetric = new Hallucination({
 *   model: 'gpt-4-turbo',
 *   temperature: 0.3,
 *   seed: 42,
 *   fewShotExamples: [
 *     {
 *       input: "Who wrote Hamlet?",
 *       context: ["Shakespeare wrote many plays including Hamlet."],
 *       output: "Charles Dickens wrote Hamlet.",
 *       score: 1.0,
 *       reason: "The output incorrectly attributes Hamlet to Charles Dickens."
 *     }
 *   ]
 * });
 *
 * // With advanced settings
 * const advancedMetric = new Hallucination({
 *   temperature: 0.5,
 *   maxTokens: 1000,
 *   modelSettings: {
 *     topP: 0.9,
 *     presencePenalty: 0.1
 *   }
 * });
 * ```
 */
declare class Hallucination extends BaseLLMJudgeMetric {
    private readonly fewShotExamples;
    /**
     * Creates a new Hallucination metric.
     *
     * @param options - Configuration options
     * @param options.model - The language model to use. Can be a string (model ID), LanguageModel instance, or OpikBaseModel instance. Defaults to 'gpt-4o'.
     * @param options.name - The name of the metric. Defaults to "hallucination_metric".
     * @param options.fewShotExamples - Optional few-shot examples to guide the model
     * @param options.trackMetric - Whether to track the metric. Defaults to true.
     * @param options.temperature - Temperature setting (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic. See https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#temperature
     * @param options.seed - Random seed for reproducible outputs. Useful for testing and debugging.
     * @param options.maxTokens - Maximum number of tokens to generate in the response.
     * @param options.modelSettings - Advanced model settings (topP, topK, presencePenalty, frequencyPenalty, stopSequences)
     */
    constructor(options?: {
        model?: SupportedModelId | LanguageModel | OpikBaseModel;
        name?: string;
        fewShotExamples?: FewShotExampleHallucination[];
        trackMetric?: boolean;
        temperature?: number;
        seed?: number;
        maxTokens?: number;
        modelSettings?: LLMJudgeModelSettings;
    });
    readonly validationSchema: z.ZodObject<{
        input: z.ZodString;
        output: z.ZodString;
        context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        output: string;
        context?: string[] | undefined;
    }, {
        input: string;
        output: string;
        context?: string[] | undefined;
    }>;
    /**
     * Calculates the hallucination score for the given input-output pair.
     *
     * @param input - Input containing the question, response, and optional context
     * @param input.input - The original input/question
     * @param input.output - The LLM's output to evaluate
     * @param input.context - Optional list of context strings. If not provided, hallucinations are evaluated based on general knowledge.
     * @returns Score result with value (0.0-1.0, where 1.0 = hallucination detected, 0.0 = no hallucination) and reason
     *
     * @example
     * ```typescript
     * const metric = new Hallucination();
     *
     * // With context
     * const result = await metric.score({
     *   input: "What is the Eiffel Tower?",
     *   output: "The Eiffel Tower is located in London.",
     *   context: ["The Eiffel Tower is a landmark in Paris, France."]
     * });
     * console.log(result.value);  // High score (hallucination detected)
     *
     * // Without context
     * const result2 = await metric.score({
     *   input: "What is 2+2?",
     *   output: "2+2 equals 4."
     * });
     * console.log(result2.value);  // 0.0 (no hallucination)
     * ```
     */
    score(input: Input$1): Promise<EvaluationScoreResult>;
}

declare const validationSchema: z.ZodObject<{
    input: z.ZodString;
    output: z.ZodString;
    context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    input: string;
    output: string;
    context?: string[] | undefined;
}, {
    input: string;
    output: string;
    context?: string[] | undefined;
}>;
type Input = z.infer<typeof validationSchema>;
/**
 * AnswerRelevance metric - evaluates the relevance of an answer to a given input.
 *
 * This metric uses a language model to assess how well the given output (answer)
 * addresses the provided input (question) within the given context. It returns a score
 * between 0.0 and 1.0, where higher values indicate better answer relevance.
 *
 * The evaluation considers:
 * - How well the answer addresses the specific question
 * - Whether the answer provides relevant information
 * - If any extraneous or off-topic information decreases relevance
 * - With context: How well the answer aligns with the provided context
 * - Without context: How well the answer addresses the input directly
 *
 * @example
 * ```typescript
 * import { AnswerRelevance } from 'opik/evaluation/metrics';
 *
 * // Using default model (gpt-4o)
 * const metric = new AnswerRelevance();
 *
 * // With context (default behavior)
 * const resultWithContext = await metric.score({
 *   input: "What's the capital of France?",
 *   output: "The capital of France is Paris.",
 *   context: ["France is a country in Europe."]
 * });
 * console.log(resultWithContext.value);  // e.g., 0.9
 * console.log(resultWithContext.reason); // Explanation
 *
 * // Without context (requires requireContext: false)
 * const metricNoContext = new AnswerRelevance({ requireContext: false });
 * const resultNoContext = await metricNoContext.score({
 *   input: "What's the capital of France?",
 *   output: "The capital of France is Paris."
 * });
 * console.log(resultNoContext.value);  // e.g., 0.95
 *
 * // Using custom model with few-shot examples
 * const customMetric = new AnswerRelevance({
 *   model: 'gpt-4-turbo',
 *   temperature: 0.3,
 *   seed: 42,
 *   fewShotExamples: [
 *     {
 *       title: "Perfect Answer",
 *       input: "What is TypeScript?",
 *       output: "TypeScript is a typed superset of JavaScript.",
 *       context: ["TypeScript adds static typing to JavaScript."],
 *       answer_relevance_score: 1.0,
 *       reason: "Perfect, direct answer."
 *     }
 *   ]
 * });
 *
 * // With advanced settings
 * const advancedMetric = new AnswerRelevance({
 *   temperature: 0.5,
 *   maxTokens: 1000,
 *   requireContext: false,
 *   modelSettings: {
 *     topP: 0.9,
 *     presencePenalty: 0.1
 *   }
 * });
 * ```
 */
declare class AnswerRelevance extends BaseLLMJudgeMetric {
    private readonly fewShotExamplesWithContext;
    private readonly fewShotExamplesNoContext;
    private readonly requireContext;
    /**
     * Creates a new AnswerRelevance metric.
     *
     * @param options - Configuration options
     * @param options.model - The language model to use. Can be a string (model ID), LanguageModel instance, or OpikBaseModel instance. Defaults to 'gpt-4o'.
     * @param options.name - The name of the metric. Defaults to "answer_relevance_metric".
     * @param options.fewShotExamples - Optional few-shot examples with context to guide the model. If not provided, default examples will be used.
     * @param options.fewShotExamplesNoContext - Optional few-shot examples without context for no-context mode. If not provided, default examples will be used.
     * @param options.requireContext - If set to false, execution in no-context mode is allowed. Defaults to true.
     * @param options.trackMetric - Whether to track the metric. Defaults to true.
     * @param options.temperature - Temperature setting (0.0-2.0). Controls randomness. Lower values make output more focused and deterministic. See https://ai-sdk.dev/docs/reference/ai-sdk-core/generate-text#temperature
     * @param options.seed - Random seed for reproducible outputs. Useful for testing and debugging.
     * @param options.maxTokens - Maximum number of tokens to generate in the response.
     * @param options.modelSettings - Advanced model settings (topP, topK, presencePenalty, frequencyPenalty, stopSequences)
     */
    constructor(options?: {
        model?: SupportedModelId | LanguageModel | OpikBaseModel;
        name?: string;
        fewShotExamples?: FewShotExampleAnswerRelevanceWithContext[];
        fewShotExamplesNoContext?: FewShotExampleAnswerRelevanceNoContext[];
        requireContext?: boolean;
        trackMetric?: boolean;
        temperature?: number;
        seed?: number;
        maxTokens?: number;
        modelSettings?: LLMJudgeModelSettings;
    });
    readonly validationSchema: z.ZodObject<{
        input: z.ZodString;
        output: z.ZodString;
        context: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    }, "strip", z.ZodTypeAny, {
        input: string;
        output: string;
        context?: string[] | undefined;
    }, {
        input: string;
        output: string;
        context?: string[] | undefined;
    }>;
    /**
     * Calculates the answer relevance score for the given input-output pair.
     *
     * @param input - Input containing the question, response, and optional context
     * @param input.input - The input text (question) to be evaluated
     * @param input.output - The output text (answer) to be evaluated
     * @param input.context - Optional list of context strings relevant to the input. If no context is given and requireContext is true, an error will be thrown.
     * @returns Score result with value (0.0-1.0) and reason
     *
     * @example
     * ```typescript
     * const metric = new AnswerRelevance();
     *
     * // With context
     * const result = await metric.score({
     *   input: "How do I install Node.js?",
     *   output: "You can download Node.js from the official website and run the installer.",
     *   context: ["Node.js is a JavaScript runtime built on Chrome's V8 engine."]
     * });
     * console.log(result.value);  // e.g., 0.8
     * console.log(result.reason); // "The answer provides clear installation steps..."
     *
     * // Without context (if requireContext: false)
     * const metricNoContext = new AnswerRelevance({ requireContext: false });
     * const result2 = await metricNoContext.score({
     *   input: "What is the capital of France?",
     *   output: "Paris is the capital of France."
     * });
     * console.log(result2.value);  // e.g., 0.95
     * ```
     */
    score(input: Input): Promise<EvaluationScoreResult>;
}

/**
 * Type definitions for OQL (Opik Query Language) parser
 */
/**
 * Supported column types in OQL queries
 */
type ColumnType = "string" | "date_time" | "dictionary" | "feedback_scores_number" | "list" | "number";
/**
 * Parsed filter expression structure
 */
interface FilterExpression {
    field: string;
    key?: string;
    operator: string;
    value: string;
    type?: ColumnType;
}

/**
 * This file contains the OQL parser and validator. It is currently limited in scope to only support
 * simple filters without "and" or "or" operators.
 *
 * The parser is organized into focused modules:
 * - types.ts: Type definitions
 * - constants.ts: Field and operator definitions
 * - tokenizer.ts: Low-level character parsing
 * - validators.ts: Validation logic
 * - parsers/: Specialized parsers for fields, operators, and values
 */

/**
 * This class implements a parser that can be used to convert a filter string into a list of filters that the BE expects.
 *
 * For example, this class allows you to convert the query string: `input contains "hello"` into
 * `[{field: 'input', operator: 'contains', value: 'hello'}]` as expected by the BE.
 *
 * The parser follows a standard architecture:
 * 1. Tokenization: Convert string into characters (QueryTokenizer)
 * 2. Parsing: Extract structured tokens (FieldParser, OperatorParser, ValueParser)
 * 3. Validation: Ensure tokens are valid (validators)
 * 4. Assembly: Build final filter expressions
 */
declare class OpikQueryLanguage {
    private readonly filterExpressions;
    readonly parsedFilters: string | null;
    constructor(queryString?: string);
    /**
     * Returns the parsed filter expressions
     */
    getFilterExpressions(): FilterExpression[] | null;
    /**
     * Main parsing method that orchestrates the parsing process
     */
    private parse;
    /**
     * Parses a single filter expression (field operator value)
     */
    private parseExpression;
    /**
     * Extracts the field name from a FieldToken for operator validation
     */
    private getFieldName;
    /**
     * Builds a FilterExpression from parsed tokens
     */
    private buildExpression;
    /**
     * Parses a connector (AND/OR) between expressions
     * @returns true if parsing should continue, false otherwise
     */
    private parseConnector;
}

export { type AllProviderOptions, AnswerRelevance, type AnthropicProviderOptions, BaseLLMJudgeMetric, BaseMetric, Contains, type DatasetPublic, type EvaluateOptions, type EvaluatePromptOptions, type EvaluationResult, type EvaluationScoreResult, type EvaluationTask, type EvaluationTestCase, type EvaluationTestResult, ExactMatch, type FeedbackScoreData, type FewShotExampleAnswerRelevanceNoContext, type FewShotExampleAnswerRelevanceWithContext, type FewShotExampleHallucination, type FewShotExampleModeration, type FilterExpression, type GoogleProviderOptions, Hallucination, IsJson, type LLMJudgeModelSettings, type LLMJudgeResponseFormat, ModelConfigurationError, ModelError, ModelGenerationError, Moderation, type OpenAIProviderOptions, OpikClient as Opik, type OpikAssistantMessage, OpikBaseModel, type OpikConfig, type OpikMessage, OpikQueryLanguage, SpanType as OpikSpanType, type OpikSystemMessage, type OpikToolMessage, type OpikUserMessage, Prompt, PromptType, type ProviderOptionsForModel, RegexMatch, type ScoringKeyMappingType, Span, SpanType, type SupportedModelId, Trace, Usefulness, VercelAIChatModel, createModel, createModelFromInstance, detectProvider, disableLogger, evaluate, evaluatePrompt, flushAll, generateId, getTrackContext, logger, resolveModel, setLoggerLevel, track };
